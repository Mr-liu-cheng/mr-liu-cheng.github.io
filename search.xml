<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Assetbundle</title>
    <url>/2025/01/20/Assetbundle/</url>
    <content><![CDATA[<h2 id="了解什么是Assetbundle"><a href="#了解什么是Assetbundle" class="headerlink" title="了解什么是Assetbundle"></a>了解什么是Assetbundle</h2><p>严格来说，AssetBundle是Asset的一个集合，是个压缩包。相比直接使用Asset，它有如下几个好处:</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>AssetBundle</strong></th>
<th><strong>直接使用 Asset</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>内存管理</strong></td>
<td>资源按需加载，支持加载和卸载，减少内存占用</td>
<td>所有资源在场景启动时加载，无法按需卸载，内存占用大</td>
</tr>
<tr>
<td><strong>加载性能</strong></td>
<td>通过按需加载，可以加载所需资源，减少初次加载时间</td>
<td>所有资源在启动时一次性加载，可能导致加载延迟和卡顿</td>
</tr>
<tr>
<td><strong>资源的依赖关系</strong></td>
<td>支持自动管理资源依赖，通过 Manifest 文件解决依赖关系</td>
<td>需要手动管理资源的依赖关系，容易导致丢失依赖</td>
</tr>
<tr>
<td><strong>更新与热更新</strong></td>
<td>支持热更新，通过增量更新机制可以减少更新数据量</td>
<td>不支持热更新，更新时必须重新打包整个项目</td>
</tr>
<tr>
<td><strong>包体大小</strong></td>
<td>可以对 Asset 进行压缩，减小包体大小</td>
<td>资源不压缩，包体较大</td>
</tr>
<tr>
<td><strong>跨平台支持</strong></td>
<td>可以为不同平台打包不同的 AssetBundle</td>
<td>所有平台共享相同的资源，可能导致不必要的资源浪费</td>
</tr>
<tr>
<td><strong>网络加载</strong></td>
<td>可以通过网络加载 AssetBundle，支持按需下载</td>
<td>只能通过本地文件访问，无法通过网络动态加载资源</td>
</tr>
<tr>
<td><strong>调试与编辑</strong></td>
<td>加载后无法直接在编辑器中查看资源，调试较为复杂</td>
<td>直接通过 <code>Inspector</code> 视图可以查看和修改资源</td>
</tr>
<tr>
<td><strong>文件管理</strong></td>
<td><code>AssetBundle</code> 文件可以单独管理，支持多版本和增量更新</td>
<td>所有资源文件都在 <code>Resources</code> 文件夹内，管理较为复杂</td>
</tr>
<tr>
<td><strong>打包与构建</strong></td>
<td>需要额外的打包过程和配置，增加构建时间</td>
<td>无需额外的打包过程，直接将资源嵌入到应用中</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>适合资源量大、需要分阶段加载和更新的项目</td>
<td>适合小型项目或对资源需求不大的应用</td>
</tr>
<tr>
<td><strong>加载的灵活性</strong></td>
<td>加载的方式灵活，可以指定加载单个资源，减少不必要的加载</td>
<td>资源一旦加载就固定，无法动态调整</td>
</tr>
<tr>
<td><strong>依赖问题</strong></td>
<td>自动解决依赖关系，减少开发者手动管理的负担</td>
<td>依赖关系需要开发者手动管理，容易出错</td>
</tr>
</tbody></table>
<h3 id="可以按需加载卸载"><a href="#可以按需加载卸载" class="headerlink" title="可以按需加载卸载"></a>可以按需加载卸载</h3><p>Unity 中的 按需加载和卸载 AssetBundle 的机制，结合了以下几个关键设计：</p>
<ul>
<li>资源分离：头部和内容体分开，按需加载。</li>
<li>内存管理：通过 <strong>PersistentManager</strong> 管理资源生命周期，避免内存泄漏。PersistentManager 负责管理与 AssetBundle 相关的对象及其生命周期，包括跟踪哪些资源被加载到内存中，哪些需要被释放。</li>
<li>依赖关系：通过 Manifest 文件和链式加载&#x2F;卸载管理资源依赖。</li>
<li>增量更新：通过哈希值或 CRC 检查资源的变化，避免不必要的更新。</li>
<li>异步加载：支持异步加载以减少卡顿，提高性能。</li>
<li>清理机制：通过 UnloadUnusedAssets 清理不再使用的资源。</li>
</ul>
<p><strong>为什么场景的ab和资源的ab不能同时打包进同一个ab内?</strong></p>
<ul>
<li>加载方式和生命周期管理不同，容易引发加载和卸载冲突。</li>
<li>场景的修改会导致整个 <code>AssetBundle</code> 重新打包，影响增量更新和资源优化。</li>
<li>场景和资源的内存管理不同，可能导致不必要的内存占用。</li>
</ul>
<h2 id="AssetBundle的打包参数"><a href="#AssetBundle的打包参数" class="headerlink" title="AssetBundle的打包参数"></a>AssetBundle的打包参数</h2><p>当我们调用Unity的API去打AssetBundle的时候，实际上有很多的参数可以供我们选择。如果没有选择合适的参数，就可能会导致在包体，内存以及加载时间等方面造成很多的浪费。</p>
<ul>
<li><p>ChunkBasedCompression：这个参数是压缩AssetBundle的用的。前面提到Android的StreamingAssets是不压缩的。为了减小包体大小，可以使用该参数对AssetBundle进行压缩。它实际上是一个由Unity改良过的LZ4，使它的算法更符合Unity的使用方式。</p>
</li>
<li><p>DisableWriteTypetree：这个其实是会被很多开发者忽略的一个参数，它非常有用，可以帮我们减小AssetBundle包体的大小，同时也可以减小内存，以及减少我们加载这个AssetBundle时的CPU时间。</p>
</li>
</ul>
<h3 id="Typetree为了给Unity跨版本之间做兼容性用的，确定使用同一个版本开发游戏的时候，可以关闭这个选项来增加打包速度和优化占用和加载性能"><a href="#Typetree为了给Unity跨版本之间做兼容性用的，确定使用同一个版本开发游戏的时候，可以关闭这个选项来增加打包速度和优化占用和加载性能" class="headerlink" title="Typetree为了给Unity跨版本之间做兼容性用的，确定使用同一个版本开发游戏的时候，可以关闭这个选项来增加打包速度和优化占用和加载性能"></a><strong>Typetree为了给Unity跨版本之间做兼容性用的，确定使用同一个版本开发游戏的时候，可以关闭这个选项来增加打包速度和优化占用和加载性能</strong></h3><h4 id="热更新场景下："><a href="#热更新场景下：" class="headerlink" title="热更新场景下："></a><strong>热更新场景下：</strong></h4><ul>
<li><strong>如果热更新的资源是使用与线上版本相同的 Unity 版本打包的</strong>，并且游戏 <strong>没有进行过大版本的升级</strong>，则可以通过关闭 <code>Typetree</code> 来减少包体和加载时的内存占用。</li>
<li><strong>如果热更新的资源包含跨版本的更新，或者 Unity 版本发生变化</strong>，就必须开启 <code>Typetree</code>，以确保不同版本的 Unity 可以正确加载这些资源，并且能够兼容较早版本的数据。</li>
</ul>
<h4 id="整体项目升级-Unity-版本的影响："><a href="#整体项目升级-Unity-版本的影响：" class="headerlink" title="整体项目升级 Unity 版本的影响："></a><strong>整体项目升级 Unity 版本的影响：</strong></h4><ul>
<li>如果你 <strong>整体升级了 Unity 版本</strong>，并且整个项目迁移到了新的 Unity 版本，那么 <code>Typetree</code> 会有影响，具体表现为：<ul>
<li>如果开启了 <code>Typetree</code>，它会保证在不同版本的 Unity 下的兼容性，使得在新版本 Unity 中加载旧版本的资源时不会出错。</li>
<li>如果 **关闭 <code>Typetree</code>**，在升级 Unity 版本后，可能会导致在加载旧版本打包的资源时出现兼容性问题，尤其是当类型定义发生变化时（比如类的字段顺序、类型名称等发生变化）。</li>
</ul>
</li>
</ul>
<p>为了避免影响 <code>Typetree</code>，在进行热更新时，以下是可以做和不能做的操作。</p>
<table>
<thead>
<tr>
<th><strong>可以做的操作</strong></th>
<th><strong>不能做的操作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>新增脚本类和资源</td>
<td>修改现有脚本类的字段名称、类型、顺序</td>
</tr>
<tr>
<td>新增 AssetBundle</td>
<td>删除字段、方法或资源</td>
</tr>
<tr>
<td>修改资源加载方式</td>
<td>修改资源的结构或依赖关系</td>
</tr>
<tr>
<td>增加新的字段或方法</td>
<td>修改现有资源的字段类型或顺序</td>
</tr>
<tr>
<td>修改 AssetBundle 的压缩格式（不改变资源结构）</td>
<td>修改 AssetBundle 内部资源的组织方式或压缩方式</td>
</tr>
</tbody></table>
<p>在进行热更新时，保持资源和脚本的兼容性非常重要，尤其是确保 <strong>现有资源的结构和字段保持不变</strong>，这样可以避免因不兼容导致的加载失败和数据丢失。如果需要进行大的修改，最好考虑全新的资源和模块，而不是修改已有的内容。</p>
<p>DisableLoadAssetByFileName，DisableLoadAssetByFileNameWithExtension：当我们加载好一个AssetBundle然后使用LoadAsset加载Asset的时候，需要传递Asset的路径名称。这个名称有三种写法，分别是Asset的文件名，Asset的文件名+扩展名，Asset的全路径，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">AssetBundle ab = AssetBundle.LoadFromFile(Path.Combine</span><br><span class="line">(Application.streamingAssetsPath, <span class="string">&quot;sphere&quot;</span>));</span><br><span class="line"><span class="comment">// 第一种和第二种比较慢的，因为它AssetBundle被加载成功后产生的</span></span><br><span class="line">Instantiate(ab.LoadAsset(<span class="string">&quot;Sphere&quot;</span>));</span><br><span class="line">Instantiate(ab.LoadAsset(<span class="string">&quot;Sphere.prefab&quot;</span>));</span><br><span class="line">Instantiate(ab.LoadAsset(<span class="string">&quot;Assets/Sphere.prefab&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>当我们没有Disable打AssetBundle的时候，实际上是算了一个Hash进去的，当通过文件名去找Asset的时候，它会去生成这个文件名的原路径，然后去对比。 如果我们确定我们的加载Asset的方式是用全路径加载的话，那么就可以把它关闭掉</p>
<h2 id="怎么实现增量更新"><a href="#怎么实现增量更新" class="headerlink" title="怎么实现增量更新"></a>怎么实现增量更新</h2><h3 id="AssetBundle增量更新的实现原理"><a href="#AssetBundle增量更新的实现原理" class="headerlink" title="AssetBundle增量更新的实现原理"></a><strong>AssetBundle增量更新的实现原理</strong></h3><p>在Unity中，增量更新的目的是使得用户在每次更新时只下载那些确实发生变化的资源，从而减少下载量和节省带宽。</p>
<p>增量更新的核心思想是对比当前版本和上一版本的AssetBundle内容，找出其中的差异，然后仅下载发生变化的部分。具体来说，增量更新通常依赖于以下几种方式来判断哪些资源发生了变化。</p>
<h3 id="判断增量更新的依据"><a href="#判断增量更新的依据" class="headerlink" title="判断增量更新的依据"></a><strong>判断增量更新的依据</strong></h3><h4 id="1-文件的MD5值（哈希值）"><a href="#1-文件的MD5值（哈希值）" class="headerlink" title="1. 文件的MD5值（哈希值）"></a>1. <strong>文件的MD5值（哈希值）</strong></h4><ul>
<li><strong>原理</strong>：通过计算两个版本的 <code>AssetBundle</code> 文件的MD5值（或其他哈希算法），如果值不同，则表示文件内容发生了变化。可以用这个方式来判断 <code>AssetBundle</code> 是否需要更新。</li>
<li><strong>适用场景</strong>：适用于当 <code>AssetBundle</code> 中的资源内容发生了变化时，计算文件的哈希值可以直接比较两个版本的 <code>AssetBundle</code> 内容。</li>
<li><strong>问题</strong>：如果AssetBundle中有细微变化（如小幅修改），但整体资源内容没变，MD5值依然会不同，这就导致每次修改都会进行完整的资源更新。</li>
</ul>
<h4 id="2-通过-manifest-文件进行比对"><a href="#2-通过-manifest-文件进行比对" class="headerlink" title="2. 通过 .manifest 文件进行比对"></a>2. <strong>通过 <code>.manifest</code> 文件进行比对</strong></h4><ul>
<li><strong>原理</strong>：在打包时，Unity会生成一个 <code>.manifest</code> 文件，该文件包含了 <code>AssetBundle</code> 文件的元数据（如文件的依赖关系、哈希值等）。通过比较新旧版本的 <code>.manifest</code> 文件，可以判断哪些资源发生了变化。</li>
<li><strong>适用场景</strong>：通过计算 <code>.manifest</code> 中每个资源文件的哈希值或者CRC值，来判断资源是否发生变化。这种方式通常比较准确，可以追踪到哪些具体资源发生了变化。</li>
<li><strong>操作步骤</strong>：<ol>
<li>在热更新时，获取上一个版本的 <code>.manifest</code> 文件的内容。</li>
<li>比较新旧版本 <code>.manifest</code> 文件中的 <code>AssetFileHash</code> 字段，找出哪些文件发生变化。</li>
<li>对比新旧版本的资源，更新改变的部分。</li>
</ol>
</li>
</ul>
<h4 id="3-资源的-AssetFileHash（文件哈希）"><a href="#3-资源的-AssetFileHash（文件哈希）" class="headerlink" title="3. 资源的 AssetFileHash（文件哈希）"></a>3. <strong>资源的 <code>AssetFileHash</code>（文件哈希）</strong></h4><ul>
<li><strong>原理</strong>：Unity的 <code>.manifest</code> 文件中记录了每个资源的 <code>AssetFileHash</code>。该字段是每个资源的内容的哈希值，可以用来判断资源本身是否发生了变化。</li>
<li><strong>适用场景</strong>：特别适合跟踪资源文件的变化，如脚本、纹理、模型、音频等。</li>
<li><strong>操作步骤</strong>：<ol>
<li>每次打包时计算每个资源的哈希值，并记录在 <code>.manifest</code> 文件中。</li>
<li>在更新过程中，通过比较两次打包的 <code>AssetFileHash</code> 判断哪些资源内容发生了变化。</li>
<li>如果某个资源的哈希值发生变化，则表明该资源内容更新了，可以下载新的 <code>AssetBundle</code>。</li>
</ol>
</li>
</ul>
<h4 id="4-资源的依赖关系"><a href="#4-资源的依赖关系" class="headerlink" title="4. 资源的依赖关系"></a>4. <strong>资源的依赖关系</strong></h4><ul>
<li><strong>原理</strong>：AssetBundle之间可能会有依赖关系。当某个资源或 <code>AssetBundle</code> 的内容发生变化时，可能会影响依赖该资源或 <code>AssetBundle</code> 的其他资源。通过检查这些依赖关系，可以判断哪些 <code>AssetBundle</code> 必须被更新。</li>
<li><strong>适用场景</strong>：适用于有复杂依赖关系的场景，或者多个资源之间有链接依赖的情况（如材质、模型、动画等）。</li>
<li><strong>操作步骤</strong>：<ol>
<li>在 <code>.manifest</code> 文件中检查资源的依赖关系。</li>
<li>如果某个资源的依赖发生变化，则该资源及其依赖的 <code>AssetBundle</code> 都需要进行更新。</li>
<li>通过检查依赖链来找出需要更新的 <code>AssetBundle</code>。</li>
</ol>
</li>
</ul>
<h3 id="实现增量更新的步骤"><a href="#实现增量更新的步骤" class="headerlink" title="实现增量更新的步骤"></a><strong>实现增量更新的步骤</strong></h3><ol>
<li><p><strong>生成和保存 <code>AssetBundle</code> 的 <code>.manifest</code> 文件</strong><br>每次打包时，Unity会生成一个 <code>.manifest</code> 文件，记录了打包资源的元数据。确保在热更新过程中可以访问和保存该文件，以便后续对比。</p>
</li>
<li><p><strong>比对 <code>.manifest</code> 文件</strong><br>在新版本打包后，比较新旧版本 <code>.manifest</code> 文件中的资源 <code>AssetFileHash</code> 字段，判断哪些资源发生了变化。</p>
</li>
<li><p><strong>计算变化的资源</strong><br>如果某个资源的 <code>AssetFileHash</code> 不同，说明该资源发生了变化。这些变化的资源会被打包成新的 <code>AssetBundle</code>。</p>
</li>
<li><p><strong>仅下载变化的资源</strong><br>在客户端进行更新时，只下载发生变化的 <code>AssetBundle</code>。这样可以大大减小更新的下载量。</p>
</li>
<li><p><strong>管理依赖关系</strong><br>如果某个资源的依赖发生了变化，需要更新依赖该资源的 <code>AssetBundle</code>。因此，依赖链的管理是增量更新的重要部分。</p>
</li>
<li><p><strong>应用新的 <code>AssetBundle</code></strong><br>客户端加载更新后的 <code>AssetBundle</code>，并加载其中的资源。</p>
</li>
</ol>
<h3 id="增量更新最佳方案"><a href="#增量更新最佳方案" class="headerlink" title="增量更新最佳方案"></a>增量更新最佳方案</h3><p>确保 <strong>准确性</strong> 和 <strong>高效性</strong>，并避免不必要的资源重新加载，<strong>提高增量更新精度</strong> 的最优方法是：</p>
<blockquote>
<p><strong>使用 <code>.manifest</code> 文件中的 <code>AssetFileHash</code> 和 <code>CRC</code> 字段来判断资源是否发生变化</strong></p>
</blockquote>
<p>这个方法结合了 <strong>准确性</strong> 和 <strong>高效性</strong>，且避免了不必要的资源重新加载。</p>
<h4 id="为什么最优？"><a href="#为什么最优？" class="headerlink" title="为什么最优？"></a><strong>为什么最优？</strong></h4><ol>
<li><p><strong>准确性</strong>：</p>
<ul>
<li><code>.manifest</code> 文件中的 <code>AssetFileHash</code> 字段是直接用于标识资源内容是否发生变化的哈希值，它非常精确，能确保只有在资源的内容发生变化时才会被标记为更新。</li>
<li>通过 <code>CRC</code> (Cyclic Redundancy Check) 字段，还可以进一步确保资源的完整性，避免因文件损坏或传输错误导致错误的更新。</li>
</ul>
</li>
<li><p><strong>高效性</strong>：</p>
<ul>
<li><code>.manifest</code> 文件相对较小，且它记录了所有资源的变化信息，因此与直接计算 <code>AssetBundle</code> 或 <code>.meta</code> 文件的哈希值相比，它的性能开销更低，能够快速判断资源变化。</li>
<li>在增量更新时，基于 <code>.manifest</code> 文件的判断方式可以避免每次重新计算整个 <code>AssetBundle</code> 的哈希，从而减少了计算和网络传输的开销。</li>
</ul>
</li>
<li><p><strong>避免不必要的资源重新加载</strong>：</p>
<ul>
<li>通过 <code>AssetFileHash</code> 和 <code>CRC</code> 的对比，只在资源真正发生变化时才进行更新，这样避免了对未修改的资源进行重新加载和下载，节省了带宽和设备的资源。</li>
</ul>
</li>
</ol>
<h4 id="增量更新的流程："><a href="#增量更新的流程：" class="headerlink" title="增量更新的流程："></a><strong>增量更新的流程：</strong></h4><ol>
<li><p><strong>首次发布时</strong>：</p>
<ul>
<li>在初次构建 <code>AssetBundle</code> 时，生成 <code>AssetBundle</code> 的 <code>.manifest</code> 文件，记录每个资源的 <code>AssetFileHash</code> 和 <code>CRC</code> 信息。</li>
<li>发布 <code>AssetBundle</code> 和 <code>.manifest</code> 文件，并确保客户端获取到这些文件。</li>
</ul>
</li>
<li><p><strong>后续更新时</strong>：</p>
<ul>
<li>在每次更新 <code>AssetBundle</code> 时，重新生成 <code>.manifest</code> 文件，并计算其中每个资源的 <code>AssetFileHash</code> 和 <code>CRC</code>。</li>
<li>客户端通过下载新的 <code>.manifest</code> 文件，并与本地存储的 <code>.manifest</code> 进行对比。如果 <code>AssetFileHash</code> 或 <code>CRC</code> 值不同，说明该资源已发生变化，需要下载新的 <code>AssetBundle</code>。</li>
<li>对于没有变化的资源，可以跳过下载和加载，避免不必要的资源重新加载。</li>
</ul>
</li>
<li><p><strong>优势</strong>：</p>
<ul>
<li>使用 <code>.manifest</code> 文件避免了每次都要遍历和检查整个 <code>AssetBundle</code>，大大减少了计算量。</li>
<li>通过 <code>CRC</code> 和 <code>AssetFileHash</code> 判断文件变化，精确到资源级别，确保增量更新的精度。</li>
<li>能有效控制资源加载的时机，只有需要更新的资源才会被重新加载，优化了内存和存储的使用。</li>
</ul>
</li>
</ol>
<hr>
<p> <strong>总结：</strong><br>最优的增量更新方法是 <strong>基于 <code>.manifest</code> 文件中的 <code>AssetFileHash</code> 和 <code>CRC</code> 字段判断资源变化</strong>。它既能保证更新的精确性，又具备较高的效率，避免了不必要的资源重新加载和带宽浪费，适用于大多数的热更新场景。</p>
<hr>
<h3 id="增量更新的优缺点"><a href="#增量更新的优缺点" class="headerlink" title="增量更新的优缺点"></a><strong>增量更新的优缺点</strong></h3><table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>节省带宽：只更新变化的部分，而不是整个 <code>AssetBundle</code>，可以大大减少下载的文件大小。</td>
<td>依赖性复杂：如果多个 <code>AssetBundle</code> 之间有复杂的依赖关系，增量更新可能会变得复杂。</td>
</tr>
<tr>
<td>加速下载：用户只需要下载新更新的资源，更新速度更快。</td>
<td>需要额外的逻辑：需要实现文件哈希比对、资源依赖关系的检查等。</td>
</tr>
<tr>
<td>减少内存占用：避免了不必要的资源加载和占用，提升了性能。</td>
<td>不适用于小变化：对于频繁的小变化，每次都更新可能会带来一定的性能开销。</td>
</tr>
</tbody></table>
<hr>
<p> <strong>总结</strong></p>
<p>增量更新的核心在于通过比对 <code>AssetBundle</code> 的哈希值、<code>manifest</code> 文件或资源的 <code>AssetFileHash</code> 来判断哪些资源发生了变化，然后只下载那些变化的资源。通过这种方式，减少了更新时的带宽占用和下载时间，同时提高了用户体验。不过，这要求开发者能够管理好资源之间的依赖关系，并能够处理增量更新中的各种逻辑细节。</p>
<h2 id="增量更新实现逻辑"><a href="#增量更新实现逻辑" class="headerlink" title="增量更新实现逻辑"></a>增量更新实现逻辑</h2><p>要实现增量更新的机制，使用 <code>.manifest</code> 文件中的 <code>AssetFileHash</code> 和 <code>CRC</code> 字段来判断资源变化，并确保只有变更的资源进行下载和更新，以下是一个基础的代码示例，展示了如何通过比对 <code>.manifest</code> 文件中的哈希值来判断哪些资源需要更新。</p>
<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ol>
<li>获取服务器上的 <code>AssetBundle</code> 和 <code>.manifest</code> 文件。</li>
<li>下载 <code>.manifest</code> 文件，解析出其中的 <code>AssetFileHash</code> 和 <code>CRC</code> 字段。</li>
<li>与本地缓存的 <code>.manifest</code> 进行对比，检查哪些资源发生了变化。</li>
<li>仅下载发生变化的 <code>AssetBundle</code> 文件，并更新本地缓存。</li>
</ol>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Networking;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssetBundleUpdater</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 本地存储路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> localAssetBundleFolder = <span class="string">&quot;Assets/AssetBundles&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> localManifestFile = <span class="string">&quot;Assets/AssetBundles/assetbundle.manifest&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器资源的 URL</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> remoteAssetBundleUrl = <span class="string">&quot;https://example.com/assetbundles&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> remoteManifestUrl = <span class="string">&quot;https://example.com/assetbundles/assetbundle.manifest&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下载 AssetBundle 和 Manifest 文件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Step 1: 下载远程的 manifest 文件</span></span><br><span class="line">        UnityWebRequest manifestRequest = UnityWebRequest.Get(remoteManifestUrl);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> manifestRequest.SendWebRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (manifestRequest.isHttpError || manifestRequest.isNetworkError)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;Failed to download manifest.&quot;</span>);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 2: 解析远程 manifest 文件</span></span><br><span class="line">        AssetBundleManifest remoteManifest = ParseManifest(manifestRequest.downloadHandler.text);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 3: 加载本地 manifest 文件并与远程 manifest 文件对比</span></span><br><span class="line">        <span class="keyword">if</span> (File.Exists(localManifestFile))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> localManifestText = File.ReadAllText(localManifestFile);</span><br><span class="line">            AssetBundleManifest localManifest = ParseManifest(localManifestText);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 4: 对比两个 manifest 文件，找出有变化的资源</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> remoteAsset <span class="keyword">in</span> remoteManifest.GetAllAssetBundles())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> localHash = GetAssetHash(localManifest, remoteAsset);</span><br><span class="line">                <span class="built_in">string</span> remoteHash = remoteManifest.GetAssetFileHash(remoteAsset);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (localHash != remoteHash) <span class="comment">// 如果文件的 hash 值不同，则需要下载更新</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Debug.Log(<span class="string">$&quot;AssetBundle <span class="subst">&#123;remoteAsset&#125;</span> has changed, updating...&quot;</span>);</span><br><span class="line">                    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">DownloadAssetBundle(remoteAsset</span>))</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 本地没有 manifest 文件，执行全量更新</span></span><br><span class="line">            Debug.Log(<span class="string">&quot;No local manifest found, performing full update...&quot;</span>);</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">DownloadAllAssetBundles(remoteManifest</span>))</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存新的 manifest 文件到本地</span></span><br><span class="line">        File.WriteAllText(localManifestFile, manifestRequest.downloadHandler.text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 Manifest 文件，获取其中的 AssetFileHash 和 CRC 字段</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AssetBundleManifest <span class="title">ParseManifest</span>(<span class="params"><span class="built_in">string</span> manifestText</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 自定义解析方式，解析 AssetBundleManifest 文件</span></span><br><span class="line">        <span class="comment">// 假设 AssetBundleManifest 是 JSON 格式</span></span><br><span class="line">        <span class="comment">// 请根据实际情况替换为你们的解析方法</span></span><br><span class="line">        <span class="keyword">return</span> JsonUtility.FromJson&lt;AssetBundleManifest&gt;(manifestText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取资源的 Hash 值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GetAssetHash</span>(<span class="params">AssetBundleManifest manifest, <span class="built_in">string</span> assetName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 返回本地 AssetBundle 的 hash 值</span></span><br><span class="line">        <span class="keyword">return</span> manifest.GetAssetFileHash(assetName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下载更新的 AssetBundle 文件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">DownloadAssetBundle</span>(<span class="params"><span class="built_in">string</span> assetName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        UnityWebRequest request = UnityWebRequest.Get(<span class="string">$&quot;<span class="subst">&#123;remoteAssetBundleUrl&#125;</span>/<span class="subst">&#123;assetName&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> request.SendWebRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.isHttpError || request.isNetworkError)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">$&quot;Failed to download asset bundle: <span class="subst">&#123;assetName&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将更新后的 AssetBundle 保存到本地缓存中</span></span><br><span class="line">        <span class="built_in">string</span> localPath = Path.Combine(localAssetBundleFolder, assetName);</span><br><span class="line">        File.WriteAllBytes(localPath, request.downloadHandler.data);</span><br><span class="line"></span><br><span class="line">        Debug.Log(<span class="string">$&quot;Successfully downloaded and cached asset bundle: <span class="subst">&#123;assetName&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下载所有的 AssetBundle 文件（全量更新）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">DownloadAllAssetBundles</span>(<span class="params">AssetBundleManifest manifest</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> assetBundleName <span class="keyword">in</span> manifest.GetAllAssetBundles())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">DownloadAssetBundle(assetBundleName</span>))</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssetBundleManifest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里的结构体是根据你们实际的 manifest 文件格式进行调整的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>[] assetBundles;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有 AssetBundle 名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span>[] <span class="title">GetAllAssetBundles</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> assetBundles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取资源的 Hash</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetAssetFileHash</span>(<span class="params"><span class="built_in">string</span> assetName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 需要从 .manifest 文件中读取文件的 Hash</span></span><br><span class="line">        <span class="comment">// 你需要根据实际的 manifest 文件结构来修改此方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;somehash&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><ol>
<li><p><strong>Manifest 文件解析</strong>：</p>
<ul>
<li>代码示例中的 <code>AssetBundleManifest</code> 类是根据假设的 JSON 格式解析的，你需要根据你们实际的 <code>.manifest</code> 文件格式来修改这个部分。</li>
<li>如果你们的 <code>.manifest</code> 文件是 XML 格式，或者有自定义结构，你可以使用 <code>XmlUtility</code> 或手动解析来获取资源的 <code>AssetFileHash</code> 和 <code>CRC</code>。</li>
</ul>
</li>
<li><p><strong>增量更新逻辑</strong>：</p>
<ul>
<li>首先下载远程的 <code>manifest</code> 文件，并解析它。</li>
<li>然后读取本地的 <code>manifest</code> 文件，并对比两个文件中的资源哈希（<code>AssetFileHash</code>）。</li>
<li>如果发现远程的资源文件哈希值与本地不一致（即资源发生了变化），就下载对应的 <code>AssetBundle</code>。</li>
<li>如果本地没有 <code>manifest</code> 文件（例如首次更新或清理后的情况），则执行全量更新，下载所有的资源包。</li>
</ul>
</li>
<li><p><strong>本地缓存与下载</strong>：</p>
<ul>
<li>每次更新完成后，将新的 <code>AssetBundle</code> 保存到本地缓存中，这样可以避免重复下载相同的资源。</li>
<li>更新完成后，将新的 <code>manifest</code> 文件保存到本地，以便下次更新时使用。</li>
</ul>
</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>manifest</code> 文件通常会包含资源文件的所有信息，所以它的大小会比 <code>AssetBundle</code> 小很多。</li>
<li>增量更新的关键是根据哈希对比资源的变化，而不是直接对比文件内容，因为 <code>AssetBundle</code> 打包后每次可能会有轻微的不同。</li>
<li>使用这种方法时需要确保客户端和服务器的 <code>manifest</code> 文件结构一致。</li>
</ul>
<p> 总结：<br>这种方法通过基于 <code>AssetBundleManifest</code> 文件中的 <code>AssetFileHash</code> 和 <code>CRC</code> 字段判断资源变化，只更新发生变化的资源，能显著提高增量更新的效率，减少不必要的资源重新加载。</p>
<h2 id="AssetBundle的加载到内存方式"><a href="#AssetBundle的加载到内存方式" class="headerlink" title="AssetBundle的加载到内存方式"></a>AssetBundle的加载到内存方式</h2><p>在 Unity 中，<code>AssetBundle</code> 可以通过多种方式加载，具体的加载方式根据不同的需求（如从磁盘加载、从网络加载、从内存加载等）来选择。以下是所有常见的 <code>AssetBundle</code> 加载方式，包括同步和异步加载方式：</p>
<p>以下是删除了示例代码和卸载方式列后的 Unity AssetBundle 加载方法对比表：</p>
<table>
<thead>
<tr>
<th>加载方法</th>
<th>说明</th>
<th>适用场景</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>AssetBundle.LoadFromFile</code></strong></td>
<td>从指定路径加载 AssetBundle 文件</td>
<td>加载本地存储的 AssetBundle 文件</td>
<td>适用于文件路径已知的本地资源加载。</td>
</tr>
<tr>
<td><strong><code>AssetBundle.LoadFromMemory</code></strong></td>
<td>从内存中加载 AssetBundle 数据</td>
<td>当 AssetBundle 数据已经加载到内存时使用</td>
<td>可以避免文件IO操作，适用于已有内存数据。</td>
</tr>
<tr>
<td><strong><code>AssetBundle.LoadFromStream</code></strong></td>
<td>从流式数据中加载 AssetBundle</td>
<td>当 AssetBundle 是通过流式数据传输时使用</td>
<td>可用于网络加载流数据。</td>
</tr>
<tr>
<td><strong><code>AssetBundle.LoadAsset</code></strong></td>
<td>加载 AssetBundle 中的指定资源</td>
<td>加载 AssetBundle 中单个资源</td>
<td>加载特定资源，常用于内存中加载资源。</td>
</tr>
<tr>
<td><strong><code>AssetBundle.LoadAssetAsync</code></strong></td>
<td>异步加载 AssetBundle 中的指定资源</td>
<td>加载 AssetBundle 中资源时不阻塞主线程</td>
<td>异步操作，避免主线程卡顿。</td>
</tr>
<tr>
<td><strong><code>AssetBundle.LoadAllAssets</code></strong></td>
<td>加载 AssetBundle 中所有资源</td>
<td>加载整个 AssetBundle 内所有资源</td>
<td>适用于需要加载所有资源的情况。</td>
</tr>
<tr>
<td><strong><code>AssetBundle.LoadAllAssetsAsync</code></strong></td>
<td>异步加载 AssetBundle 中所有资源</td>
<td>加载整个 AssetBundle 内所有资源时不阻塞主线程</td>
<td>异步加载整个资源包。</td>
</tr>
<tr>
<td><strong><code>AssetBundle.LoadAssetWithSubAssets</code></strong></td>
<td>加载主资源及其附带的资源</td>
<td>加载主资源及其附带的子资源</td>
<td>加载一个资源以及其所有相关子资源。</td>
</tr>
<tr>
<td><strong><code>WWW</code>（已废弃）</strong></td>
<td>通过 WWW 类加载网络上的 AssetBundle</td>
<td>用于较老版本的 Unity 中加载网络资源</td>
<td>已废弃，推荐使用 <code>UnityWebRequest</code>。</td>
</tr>
<tr>
<td><strong><code>UnityWebRequestAssetBundle</code></strong></td>
<td>通过 <code>UnityWebRequest</code> 加载网络上的 AssetBundle</td>
<td>用于加载远程服务器上的 AssetBundle</td>
<td>推荐使用网络请求加载资源，性能更好。</td>
</tr>
</tbody></table>
<h2 id="CRC-校验"><a href="#CRC-校验" class="headerlink" title="CRC 校验"></a>CRC 校验</h2><p>在 Unity 中，<code>CRC 校验</code> 是在加载 <code>AssetBundle</code> 的过程中进行的，用于确保加载的 <code>AssetBundle</code> 文件没有被篡改或损坏。具体来说，CRC 校验是在 <strong>AssetBundle 文件加载的过程中</strong>，由 Unity 在解析 <code>AssetBundle</code> 文件时自动进行的，通常不需要开发者手动干预。</p>
<h3 id="CRC-校验发生的阶段"><a href="#CRC-校验发生的阶段" class="headerlink" title="CRC 校验发生的阶段"></a>CRC 校验发生的阶段</h3><p>CRC 校验是在 <code>AssetBundle</code> 加载过程中的文件解析阶段进行的。具体而言，CRC 校验会在以下几个步骤中进行：</p>
<ol>
<li><p><strong>文件解析阶段</strong>：<br>当使用 <code>AssetBundle.LoadFromFile()</code> 或 <code>UnityWebRequestAssetBundle.GetAssetBundle()</code> 等加载方法时，Unity 会先读取并解析 <code>AssetBundle</code> 文件的头信息和内容。在这个阶段，Unity 会根据文件头信息中的 CRC 值与实际加载的内容进行比对。</p>
</li>
<li><p><strong>自动校验</strong>：<br>在解析完 <code>AssetBundle</code> 文件的头信息后，Unity 会自动计算并验证该文件的 CRC 值（CRC32）。如果该值与 <code>AssetBundle</code> 文件头中记录的 CRC 值匹配，则表示文件完整，否则会抛出错误，提示文件损坏或不匹配。</p>
</li>
<li><p><strong>加载资源阶段</strong>：<br>一旦 CRC 校验通过，Unity 会继续加载 <code>AssetBundle</code> 中的具体资源。在这个过程中，如果文件本身没有损坏，资源将被加载到内存中供后续使用。</p>
</li>
</ol>
<h3 id="使用-CRC-校验的函数"><a href="#使用-CRC-校验的函数" class="headerlink" title="使用 CRC 校验的函数"></a>使用 CRC 校验的函数</h3><ul>
<li>**AssetBundle.LoadFromFile()**：加载文件时会进行 CRC 校验。</li>
<li>**AssetBundle.LoadFromMemory()**：在内存加载时也会进行 CRC 校验，确保加载的内存数据与 <code>AssetBundle</code> 文件的校验值一致。</li>
<li>**UnityWebRequestAssetBundle.GetAssetBundle()**：使用 <code>UnityWebRequest</code> 下载 <code>AssetBundle</code> 时，CRC 校验也会在文件下载并解析后进行。</li>
</ul>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p>如果使用 <code>UnityWebRequestAssetBundle</code> 来下载并加载资源时，你可以传入一个 <code>CRC</code> 值来确保文件的完整性。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Networking;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssetBundleLoader</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> url = <span class="string">&quot;https://example.com/assetbundle&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下载 AssetBundle</span></span><br><span class="line">        UnityWebRequest www = UnityWebRequestAssetBundle.GetAssetBundle(url, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> www.SendWebRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (www.result != UnityWebRequest.Result.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;Error downloading AssetBundle: &quot;</span> + www.error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 加载成功，获取 AssetBundle</span></span><br><span class="line">            AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(www);</span><br><span class="line">            <span class="keyword">if</span> (bundle != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;AssetBundle loaded successfully&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否总是需要-CRC-校验？"><a href="#是否总是需要-CRC-校验？" class="headerlink" title="是否总是需要 CRC 校验？"></a>是否总是需要 CRC 校验？</h3><p>CRC 校验是确保数据完整性的一种手段，通常会在以下场景下启用：</p>
<ul>
<li><strong>网络传输时</strong>：下载的 <code>AssetBundle</code> 文件可能会被损坏，启用 CRC 校验可以验证文件是否在传输过程中发生了变化。</li>
<li><strong>本地文件校验</strong>：通过文件系统读取的 <code>AssetBundle</code> 也需要 CRC 校验，防止文件在磁盘上发生损坏或篡改。</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>CRC 校验是由 Unity 在加载 <code>AssetBundle</code> 时自动进行的，通常发生在文件解析和资源加载阶段。CRC 校验确保文件在加载前是完整且未损坏的。</p>
<h2 id="AssetBundle-LoadAsset"><a href="#AssetBundle-LoadAsset" class="headerlink" title="AssetBundle.LoadAsset"></a>AssetBundle.LoadAsset</h2><blockquote>
<p>是用于从已经加载到内存中的 AssetBundle 中加载具体的资源（如材质、纹理、Prefab 等）。它不会重新加载整个 AssetBundle 文件，而是提取文件中的单个资源。</p>
</blockquote>
<p>既然我们加载出来了AssetBundle，我们就会想和Resource.load那样去加载一个我们需要的资源出来实例化。</p>
<p>其实，AssetBundle加载资源和Resource.load的加载流程是一样的了，通过Instanceid找全局内是否有该资源的对象，如果没有就通过PresistManager去加载并保存改对象，只不过对于AssetBundle的话，PresistManager保存的对象的标识符是指向包含这个对象的AssetBundle的。</p>
<h2 id="AssetBundle的卸载"><a href="#AssetBundle的卸载" class="headerlink" title="AssetBundle的卸载"></a>AssetBundle的卸载</h2><p>在 Unity 中，AssetBundle 是一种用于将游戏资源打包并按需加载的机制。随着游戏开发中的资源管理变得更加复杂，正确地卸载 AssetBundle 变得至关重要，因为它会直接影响到内存的使用效率和性能。</p>
<h3 id="1-AssetBundle-卸载方法"><a href="#1-AssetBundle-卸载方法" class="headerlink" title="1. AssetBundle 卸载方法"></a>1. <strong>AssetBundle 卸载方法</strong></h3><p>Unity 提供了 <code>AssetBundle.Unload(bool)</code> 方法来卸载已经加载的 AssetBundle。该方法有一个布尔参数 <code>bool unloadAllLoadedObjects</code>，决定是否将与该 AssetBundle 关联的所有资源对象一并卸载。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Unload</span>(<span class="params"><span class="built_in">bool</span> unloadAllLoadedObjects</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>unloadAllLoadedObjects</strong>:<ul>
<li><strong>true</strong>：表示卸载该 AssetBundle 以及所有与其关联的资源对象。</li>
<li><strong>false</strong>：表示仅卸载 AssetBundle 文件的关联，而不卸载已经加载到内存中的资源对象。</li>
</ul>
</li>
</ul>
<h3 id="2-两种卸载模式的区别"><a href="#2-两种卸载模式的区别" class="headerlink" title="2. 两种卸载模式的区别"></a>2. <strong>两种卸载模式的区别</strong></h3><h4 id="2-1-Unload-false"><a href="#2-1-Unload-false" class="headerlink" title="2.1 Unload(false)"></a>2.1 <strong>Unload(false)</strong></h4><ul>
<li><strong>作用</strong>：只会从 <code>PersistentManager</code> 中删除 AssetBundle 文件与内存中已加载的对象的关联，而不会删除这些资源对象本身。</li>
<li><strong>影响</strong>：该对象的内存不会释放，因此，如果你只使用 <code>Unload(false)</code> 卸载，内存中会残留这些对象，并且后续若再次加载 AssetBundle，这些对象会被重新加载，导致内存中的重复数据。</li>
</ul>
<h4 id="2-2-Unload-true"><a href="#2-2-Unload-true" class="headerlink" title="2.2 Unload(true)"></a>2.2 <strong>Unload(true)</strong></h4><ul>
<li><strong>作用</strong>：不仅删除与 AssetBundle 文件相关联的对象，还会释放内存中所有与该 AssetBundle 相关联的对象（即资源对象），如材质、纹理、模型等。</li>
<li><strong>影响</strong>：如果 AssetBundle 中的对象不再被其他部分引用，内存中会释放这些对象，帮助减少内存占用。</li>
</ul>
<h3 id="3-卸载时的注意事项"><a href="#3-卸载时的注意事项" class="headerlink" title="3. 卸载时的注意事项"></a>3. <strong>卸载时的注意事项</strong></h3><h4 id="3-1-依赖关系"><a href="#3-1-依赖关系" class="headerlink" title="3.1 依赖关系"></a>3.1 <strong>依赖关系</strong></h4><p>在实际开发中，一个 AssetBundle 可能会依赖于另一个 AssetBundle。例如，A 包含了 B 包的资源。如果 A 被卸载，而 B 仍然被其他地方使用，<code>Unload(false)</code> 可能会导致 B 资源的内存泄漏。</p>
<p>因此，卸载 AssetBundle 时需要确保它与其他 AssetBundle 之间的依赖关系被正确处理。理想情况下，应该先卸载所有不再需要的 AssetBundle，并确保没有任何资源正在被引用。</p>
<h4 id="3-2-引用计数"><a href="#3-2-引用计数" class="headerlink" title="3.2 引用计数"></a>3.2 <strong>引用计数</strong></h4><p>Unity 使用引用计数机制来管理资源的生命周期。如果一个资源对象被多个 AssetBundle 引用，那么即使卸载了其中一个 AssetBundle，资源本身并不会立刻被卸载，直到所有引用该资源的 AssetBundle 都被卸载或没有其他对象再引用该资源。</p>
<h4 id="3-3-资源的引用管理"><a href="#3-3-资源的引用管理" class="headerlink" title="3.3 资源的引用管理"></a>3.3 <strong>资源的引用管理</strong></h4><p>确保在卸载 AssetBundle 前，先销毁所有不再需要的引用。对于在场景中实例化的对象，应该显式销毁这些对象，否则它们可能会一直占用内存。</p>
<p>例如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Destroy(gameObject);  <span class="comment">// 销毁实例化的对象</span></span><br></pre></td></tr></table></figure>

<p>然后，你可以调用 <code>Resources.UnloadUnusedAssets()</code> 来卸载所有不再使用的资源，进一步减少内存占用。</p>
<h3 id="4-卸载与垃圾回收"><a href="#4-卸载与垃圾回收" class="headerlink" title="4. 卸载与垃圾回收"></a>4. <strong>卸载与垃圾回收</strong></h3><p>卸载 AssetBundle 并不会立即触发垃圾回收。卸载操作会清除 AssetBundle 文件与内存中的对象的关联，但实际的内存释放可能会推迟，直到 Unity 的垃圾回收机制触发时。如果你希望立即释放内存，可以通过调用 <code>Resources.UnloadUnusedAssets()</code> 来帮助清理内存。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Resources.UnloadUnusedAssets();</span><br></pre></td></tr></table></figure>

<p>该方法会强制清理不再使用的资源，并尝试减少内存占用，特别是在大量卸载资源后。</p>
<h3 id="5-常见的-AssetBundle-卸载误区"><a href="#5-常见的-AssetBundle-卸载误区" class="headerlink" title="5. 常见的 AssetBundle 卸载误区"></a>5. <strong>常见的 AssetBundle 卸载误区</strong></h3><ul>
<li><strong>误区 1</strong>：只使用 <code>Unload(false)</code>，而不管理内存中的对象引用。会导致内存泄漏，虽然卸载了 AssetBundle，但内存中的资源对象仍然存在。</li>
<li><strong>误区 2</strong>：在卸载 AssetBundle 后继续访问其中的资源对象。由于对象已经卸载，访问这些对象会导致错误或崩溃。</li>
<li><strong>误区 3</strong>：频繁地加载和卸载 AssetBundle，而没有适当的资源管理策略。这样会导致不必要的内存占用和性能问题，应该避免频繁加载和卸载相同的资源。</li>
</ul>
<h3 id="6-示例：正确使用-AssetBundle-卸载"><a href="#6-示例：正确使用-AssetBundle-卸载" class="headerlink" title="6. 示例：正确使用 AssetBundle 卸载"></a>6. <strong>示例：正确使用 AssetBundle 卸载</strong></h3><p>假设你在游戏中加载了一个 AssetBundle 并实例化了一些对象，接着需要卸载该 AssetBundle 以释放内存。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载 AssetBundle</span></span><br><span class="line">AssetBundle bundle = AssetBundle.LoadFromFile(<span class="string">&quot;path/to/assetbundle&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载并实例化资源</span></span><br><span class="line">GameObject prefab = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;MyPrefab&quot;</span>);</span><br><span class="line">GameObject obj = Instantiate(prefab);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载 AssetBundle</span></span><br><span class="line"><span class="comment">// 先销毁对象引用</span></span><br><span class="line">Destroy(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载 AssetBundle，并释放内存</span></span><br><span class="line">bundle.Unload(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制卸载不再使用的资源</span></span><br><span class="line">Resources.UnloadUnusedAssets();</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>使用 <code>AssetBundle.Unload(true)</code> 可以完全卸载 AssetBundle 和其关联的所有资源对象，释放内存。</li>
<li><code>AssetBundle.Unload(false)</code> 只会断开 AssetBundle 与内存中对象的关联，不会释放内存。</li>
<li>在卸载 AssetBundle 时，必须处理好资源的引用计数和依赖关系，避免内存泄漏。</li>
<li>为了确保内存的彻底释放，可以使用 <code>Resources.UnloadUnusedAssets()</code> 来进一步清理未使用的资源。</li>
<li>request.dispose(): 对于 UnityWebRequestAssetBundle，使用 dispose() 来释放网络请求资源。</li>
</ul>
<p>正确管理 AssetBundle 的加载和卸载，不仅能够提高游戏的性能，减少内存占用，还能避免不必要的资源重复加载，保持游戏的流畅体验。</p>
]]></content>
  </entry>
  <entry>
    <title>C# CLR</title>
    <url>/2025/01/20/C-CLR/</url>
    <content><![CDATA[<p>CLR 是 <strong>Common Language Runtime</strong> 的缩写，翻译为 <strong>公共语言运行时</strong>。它是 .NET 框架的核心组件，负责执行由 .NET 编程语言（如 C#、VB.NET、F# 等）编写的程序。</p>
<h3 id="CLR-的主要功能："><a href="#CLR-的主要功能：" class="headerlink" title="CLR 的主要功能："></a>CLR 的主要功能：</h3><ol>
<li><p><strong>代码执行</strong>：CLR 是 .NET 程序的执行环境，它将中间语言（IL）代码转换为机器代码，使程序能够在不同的操作系统和硬件平台上运行。</p>
</li>
<li><p><strong>内存管理</strong>：CLR 提供了自动垃圾回收功能（GC，Garbage Collection），自动回收不再使用的对象所占用的内存，减少内存泄漏问题。</p>
</li>
<li><p><strong>类型安全</strong>：CLR 确保程序的类型安全，防止程序访问未授权的内存或类型错误。</p>
</li>
<li><p><strong>异常处理</strong>：CLR 提供了统一的异常处理机制，确保不同语言的程序能够一致地处理错误。</p>
</li>
<li><p><strong>跨语言互操作性</strong>：CLR 使得不同编程语言编写的代码能够互操作。例如，C# 编写的代码可以调用 VB.NET 编写的类和方法。</p>
</li>
<li><p><strong>安全性</strong>：CLR 提供了多层次的安全性检查（例如代码访问安全性，CAS）来防止恶意代码的执行。</p>
</li>
</ol>
<h3 id="CLR-主要包含的部分："><a href="#CLR-主要包含的部分：" class="headerlink" title="CLR 主要包含的部分："></a>CLR 主要包含的部分：</h3><ul>
<li><p><strong>JIT 编译器（Just-in-Time Compiler）</strong>：CLR 中的 JIT 编译器负责将中间语言（IL）编译成特定平台上的机器代码。</p>
</li>
<li><p><strong>垃圾回收器（GC）</strong>：CLR 包含一个自动垃圾回收机制，它监控程序的内存使用，自动清理不再使用的对象。</p>
</li>
<li><p><strong>类型系统</strong>：CLR 定义了 .NET 类型系统（包括值类型、引用类型、数组等），并且管理类型的加载和执行。</p>
</li>
<li><p><strong>程序集（Assembly）</strong>：CLR 使用程序集（通常是 .dll 或 .exe 文件）来组织代码，程序集包含了元数据和 IL 代码，供 CLR 运行时执行。</p>
</li>
</ul>
<h3 id="CLR-与其他技术的关系："><a href="#CLR-与其他技术的关系：" class="headerlink" title="CLR 与其他技术的关系："></a>CLR 与其他技术的关系：</h3><ul>
<li><p><strong>.NET Framework</strong>：CLR 是 .NET Framework 的一部分，提供了核心的运行时支持。其他 .NET 组件（如 BCL，Base Class Library）则提供了编程所需的基础类库。</p>
</li>
<li><p>**.NET Core 和 .NET 5&#x2F;6+**：随着 .NET Core 和后来的统一平台 .NET 5&#x2F;6+ 的发展，CLR 在这些新版本中仍然存在，但它在不同平台上的实现进行了优化和统一。</p>
</li>
</ul>
<h3 id="CLR-的作用："><a href="#CLR-的作用：" class="headerlink" title="CLR 的作用："></a>CLR 的作用：</h3><ul>
<li><p><strong>平台独立性</strong>：CLR 使得开发者能够编写跨平台的代码。在不同的操作系统上运行时，CLR 会将中间语言（IL）代码转换为本地机器代码，保证代码可以在各种平台上执行。</p>
</li>
<li><p><strong>语言无关性</strong>：CLR 提供了语言之间的互操作性，不同语言的程序可以在相同的运行时环境下执行，方便跨语言开发。</p>
</li>
</ul>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>CLR 是 .NET 平台的核心，它为程序提供了代码执行、内存管理、类型安全、垃圾回收等功能。通过 CLR，开发者可以编写语言无关、平台无关的代码，在多种平台上运行，并享受 .NET 提供的各种功能支持。</p>
<h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><p><code>CLR</code>（<strong>Common Language Runtime</strong>）与跨平台的关系体现在它作为 .NET 平台的核心组件，为不同平台上的应用程序提供了运行时支持，使得使用 .NET 编写的应用可以在多种平台上运行。这一跨平台能力得到了特别的关注和增强，尤其是随着 <strong>.NET Core</strong> 的发展以及后来的 <strong>.NET 5&#x2F;6+</strong> 的发布，使得 .NET 不再局限于 Windows 平台，而是支持包括 Linux、macOS、iOS、Android、Web 等多种操作系统和设备。</p>
<h3 id="CLR-如何实现跨平台支持："><a href="#CLR-如何实现跨平台支持：" class="headerlink" title="CLR 如何实现跨平台支持："></a>CLR 如何实现跨平台支持：</h3><ol>
<li><p><strong>平台无关性</strong>：</p>
<ul>
<li><strong>中间语言（IL）</strong>：CLR 允许将源代码编译为平台无关的 <strong>中间语言（IL）</strong>，这意味着开发者编写的代码不依赖于特定的硬件或操作系统，而是被编译成中间语言后可以在任何支持 CLR 的平台上运行。</li>
<li>这些中间语言的代码在运行时通过 CLR 进行转换，CLR 将中间语言转换为适合当前操作系统和硬件平台的机器代码。</li>
</ul>
</li>
<li><p><strong>跨语言互操作性</strong>：</p>
<ul>
<li>CLR 支持多种编程语言（例如 C#、F#、VB.NET 等），这些语言都可以编译成相同的中间语言，并运行在 CLR 上。因此，无论在何种平台上，CLR 可以确保不同语言的代码能够互相调用和协作运行。这种语言间的互操作性，进一步增强了跨平台开发的灵活性。</li>
</ul>
</li>
<li><p><strong>运行时环境的适配</strong>：</p>
<ul>
<li>CLR 并不是固定于某一平台的，它的具体实现会根据不同的操作系统和硬件平台进行适配。例如：<ul>
<li><strong>Mono</strong>：这是一个开源的 CLR 实现，最初是为 Linux 和 macOS 提供对 .NET 的支持，后来发展成一个跨平台的框架，支持 iOS、Android 等移动平台。</li>
<li>**.NET Core &#x2F; .NET 5+**：随着 .NET Core 的推出，微软将 CLR 引入了跨平台支持的主流框架中，尤其是在 Linux 和 macOS 上提供了官方支持。<code>dotnet</code> 命令行工具以及 .NET Core runtime 可以在多个平台（如 Linux、macOS、Windows）上运行和部署。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>垃圾回收与内存管理</strong>：</p>
<ul>
<li>CLR 的垃圾回收（GC）机制能够在不同平台上高效地管理内存。无论是 Windows 还是 Linux，CLR 都会根据平台的内存管理特性，优化垃圾回收的执行。</li>
</ul>
</li>
<li><p><strong>平台特定实现</strong>：</p>
<ul>
<li>在跨平台执行时，CLR 通过抽象化平台特定的实现细节，使得相同的 .NET 应用可以在不同平台之间无缝迁移。例如，在 iOS 上运行的 .NET 应用会使用 Mono 或 .NET MAUI（跨平台 UI 框架）来实现特定于 iOS 的功能，而在 Windows 上则使用 Windows 特有的 API。</li>
</ul>
</li>
<li><p><strong>移植和兼容性</strong>：</p>
<ul>
<li>CLR 的设计考虑了不同平台的硬件架构、操作系统特性等差异，因此它能够通过特定的运行时实现（如 Mono 或 .NET Core）来处理各平台上的差异，确保相同的代码可以在多个平台上运行。</li>
</ul>
</li>
</ol>
<h3 id="CLR-与-Unity-的跨平台能力："><a href="#CLR-与-Unity-的跨平台能力：" class="headerlink" title="CLR 与 Unity 的跨平台能力："></a>CLR 与 Unity 的跨平台能力：</h3><p>在 Unity 中，Unity 引擎本身使用的是 <strong>Mono</strong>（早期）或 <strong>IL2CPP</strong>（后期）来支持跨平台开发：</p>
<ul>
<li><strong>Mono</strong> 是 Unity 早期支持的 .NET 实现，它是 CLR 的一个跨平台版本，提供了 C# 脚本的执行和管理功能，支持 Windows、macOS、Linux、iOS、Android 等多种平台。</li>
<li><strong>IL2CPP</strong>（Intermediate Language To C++）是 Unity 的另一种技术，它通过将 C# 代码转换为 C++ 代码，然后使用本地编译器生成目标平台的二进制代码，从而绕过 CLR 的运行时并提高性能。IL2CPP 支持更广泛的平台，包括移动设备、控制台和 WebGL 等。</li>
</ul>
<p>通过这些技术，Unity 实现了广泛的跨平台支持，允许同一份 C# 代码在多种平台上运行。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul>
<li><strong>CLR</strong> 是 .NET 框架的运行时环境，它通过将代码编译成中间语言（IL）并在运行时将其转换为目标平台的机器代码，提供了强大的 <strong>跨平台能力</strong>。</li>
<li><strong>跨平台支持</strong> 体现在 CLR 适配了不同平台（如 Windows、Linux、macOS、移动平台等），并提供了通用的执行环境，这使得 .NET 应用可以在多种操作系统和硬件平台上运行。</li>
<li>在 Unity 中，CLR 的跨平台支持通过 <strong>Mono</strong> 和 <strong>IL2CPP</strong> 实现，确保 Unity 的 C# 脚本可以在多个平台上运行。</li>
</ul>
<p>通过 CLR 和其跨平台机制，开发者可以编写一次代码，在多个平台上运行和部署，极大提高了开发效率。</p>
]]></content>
  </entry>
  <entry>
    <title>Game Framework流程</title>
    <url>/2025/02/05/Game-Framework%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p> <a href="https://gameframework.cn/">Game Framework</a> 是一个基于 Unity 的轻量级游戏开发框架，提供了模块化的架构，包括资源管理、UI管理、事件系统、数据存储等功能。其整体流程大致如下：</p>
<p><strong>教程：</strong></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/426136370">花桑GameFramework解析</a></li>
<li><a href="https://www.lfzxb.top/gameframework-all/">烟雨迷离半世殇GF教程</a></li>
<li><a href="https://www.bilibili.com/medialist/detail/ml759678145">烟雨迷离半世殇GF视频教程</a></li>
<li><a href="https://gameframework.cn/api/index.html">GF API 手册</a></li>
<li><a href="https://gameframework.cn/faq/">常见问题</a></li>
<li><a href="https://blog.csdn.net/qq_26999509/article/details/102758769?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522f6a6e8709f22cf67742712f866f9e7f4%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=f6a6e8709f22cf67742712f866f9e7f4&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-102758769-null-null.nonecase&utm_term=gameframework&spm=1018.2226.3001.4450">源码分析</a></li>
</ul>
<p><strong>参考项目：</strong></p>
<ul>
<li><a href="https://github.com/EllanJiang">GF官方</a>（包涵GameFrameWork 源码，UnityGameFrameWork Package， StarForce 示例工程）</li>
<li><a href="https://github.com/DrFlower/TowerDefense-GameFramework-Demo?tab=readme-ov-file">花桑塔防游戏</a></li>
</ul>
<p><strong>导入插件：</strong></p>
<ol>
<li><a href="https://github.com/EllanJiang/UnityGameFramework">下载</a></li>
<li>解压到游戏 <code>Assets 父级</code>目录下，避免污染 Assets,文件中的框架被封装成dll如下<img src="/.io//image-1.png">要想阅读源码<a href="https://github.com/EllanJiang/GameFramework/">跳转至此</a></li>
<li>手动修改 package.json 为”version”: “1.0.0” ，否则会报错：<br>导入插件报错：Cannot perform upm operation: Unable to add package， version 字段不符合 Semantic Versioning（语义化版本） 规范。</li>
<li>保存文件，然后重新尝试导入。</li>
</ol>
<p><strong>源码导入：</strong></p>
<blockquote>
<p>Q：如何把 GameFramework.dll 换成源码调试和运行？</p>
</blockquote>
<blockquote>
<p>A：首先，强烈建议保持 GameFramework.dll 的现状而不是更换为代码，以防止开发过程中错误的进行修改。如果是想调试其中的代码，可以考虑使用源码自行编译 dll，并连同 pdb 文件覆盖到原有目录，即可跳转进入 dll 内的函数。</p>
</blockquote>
<p>如果一定要更换源码，按以下步骤进行：</p>
<ul>
<li>请先删除掉原来的 GameFramework.dll</li>
<li>将 Game Framework 源码目录拷贝至GameFramework.dll所在的目录下，并在此目录中增加 GameFramework.asmdef 文件（注意需要勾选unsafe选项）。</li>
<li>然后让 UnityGameFramework.Runtime.asmdef 依赖 GameFramework.asmdef，让 UnityGameFramework.Editor.asmdef 同时依赖 GameFramework.asmdef 和 UnityGameFramework.Runtime.asmdef 即可。Runtime.asmdef 文件通常位于 UnityGameFramework&#x2F;Scripts&#x2F;Runtime 目录下，而 UnityGameFramework.Editor.asmdef 文件通常位于 UnityGameFramework&#x2F;Scripts&#x2F;Editor 目录下。</li>
</ul>
<h2 id="Game-Framework-由哪几部分组成？"><a href="#Game-Framework-由哪几部分组成？" class="headerlink" title="Game Framework 由哪几部分组成？"></a>Game Framework 由哪几部分组成？</h2><p>完整的 Game Framework 包含三部分：</p>
<ul>
<li>GameFramework – 封装基础游戏逻辑，如数据管理、资源管理、文件系统、对象池、有限状态机、本地化、事件、实体、网络、界面、声音等，此部分逻辑实现不依赖于 Unity 引擎，以程序集的形式提供。</li>
<li>UnityGameFramework.Runtime – 依赖 UnityEngine.dll 进行对 GameFramework.dll 的补充实现。为了方便兼容 Unity 的各个版本，此部分已经以代码的形式包含在 Unity 插件中。</li>
<li>UnityGameFramework.Editor – 依赖 UnityEditor.dll 进行对工具、Inspector 的实现。为了方便兼容 Unity 的各个版本，此部分已经以代码的形式包含在 Unity 插件中。</li>
</ul>
<h2 id="Game-Framework-框架流程"><a href="#Game-Framework-框架流程" class="headerlink" title="Game Framework 框架流程"></a><strong>Game Framework 框架流程</strong></h2><h3 id="1-启动流程"><a href="#1-启动流程" class="headerlink" title="1. 启动流程"></a><strong>1. 启动流程</strong></h3><ol>
<li><p><strong>入口方法</strong>  </p>
<ul>
<li><code>GameEntry.cs</code> 作为游戏的入口，初始化各个核心模块。</li>
<li>通常在 <code>Awake()</code> 方法中完成框架初始化。</li>
</ul>
</li>
<li><p><strong>初始化框架</strong>  </p>
<ul>
<li><code>GameFramework.Init()</code>，内部初始化各个子模块：<ul>
<li><strong>日志系统</strong></li>
<li><strong>事件系统</strong></li>
<li><strong>数据表管理</strong></li>
<li><strong>资源管理</strong></li>
<li><strong>网络管理</strong></li>
<li><strong>UI管理</strong></li>
<li><strong>音频管理</strong></li>
<li><strong>实体管理</strong></li>
<li><strong>场景管理</strong></li>
<li><strong>配置管理</strong></li>
<li><strong>本地化管理</strong></li>
</ul>
</li>
<li>这些模块通常继承 <code>GameFrameworkModule</code>，在 <code>GameEntry</code> 中注册。</li>
</ul>
</li>
<li><p><strong>加载配置</strong></p>
<ul>
<li>读取本地配置文件（如 <code>Config.json</code>），设置游戏基本参数。</li>
<li>可能从 <code>PlayerPrefs</code> 或服务器拉取用户数据。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-资源管理"><a href="#2-资源管理" class="headerlink" title="2. 资源管理"></a><strong>2. 资源管理</strong></h3><ol>
<li><p><strong>加载资源</strong></p>
<ul>
<li>依赖 <code>ResourceComponent</code> 进行加载，支持：<ul>
<li><strong>本地 AssetBundle</strong></li>
<li><strong>远程下载</strong></li>
</ul>
</li>
<li>采用异步加载，防止主线程卡顿：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ResourceComponent.LoadAssetAsync(<span class="string">&quot;path/to/asset&quot;</span>, OnLoadComplete);</span><br></pre></td></tr></table></figure></li>
<li>支持 <strong>热更新</strong>（可与 <code>VersionCheckComponent</code> 结合）。</li>
</ul>
</li>
<li><p><strong>对象池管理</strong></p>
<ul>
<li><strong>UI 界面</strong>、<strong>实体</strong>、<strong>特效</strong>等资源可通过 <strong>对象池</strong> 管理，提高性能：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GameEntry.ObjectPool.Spawn(<span class="string">&quot;Enemy&quot;</span>);</span><br><span class="line">GameEntry.ObjectPool.Despawn(enemy);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-游戏场景管理"><a href="#3-游戏场景管理" class="headerlink" title="3. 游戏场景管理"></a><strong>3. 游戏场景管理</strong></h3><ol>
<li><p><strong>场景加载</strong></p>
<ul>
<li><code>GameEntry.Scene.LoadScene(&quot;MainScene&quot;);</code></li>
<li>可异步加载 <code>AsyncOperation</code>，防止卡顿：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GameEntry.Scene.LoadSceneAsync(<span class="string">&quot;BattleScene&quot;</span>, OnSceneLoaded);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>切换场景</strong></p>
<ul>
<li>场景切换前可触发 <strong>存档</strong>、<strong>释放资源</strong>、<strong>播放过场动画</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-UI管理"><a href="#4-UI管理" class="headerlink" title="4. UI管理"></a><strong>4. UI管理</strong></h3><ol>
<li><p><strong>打开 UI</strong></p>
<ul>
<li>通过 <code>UIComponent</code> 加载 UI 预制体：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GameEntry.UI.OpenUIForm(UIFormId.MainMenu);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>关闭 UI</strong></p>
<ul>
<li><code>GameEntry.UI.CloseUIForm(mainMenuForm);</code></li>
<li>UI 通过 <code>EventComponent</code> 监听数据变更，支持 MVC 结构。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-事件与消息系统"><a href="#5-事件与消息系统" class="headerlink" title="5. 事件与消息系统"></a><strong>5. 事件与消息系统</strong></h3><ol>
<li><p><strong>订阅事件</strong></p>
<ul>
<li>采用 <strong>事件驱动</strong> 模式，减少组件间耦合：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GameEntry.Event.Subscribe(EventId.PlayerDead, OnPlayerDead);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>触发事件</strong></p>
<ul>
<li>组件间通过事件通信：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GameEntry.Event.Fire(<span class="keyword">this</span>, <span class="keyword">new</span> PlayerDeadEventArgs());</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>消息传递</strong></p>
<ul>
<li>适用于 <strong>网络同步</strong>，例如：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GameEntry.Network.Send(<span class="keyword">new</span> PlayerMovePacket());</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="6-实体（角色、怪物）管理"><a href="#6-实体（角色、怪物）管理" class="headerlink" title="6. 实体（角色、怪物）管理"></a><strong>6. 实体（角色、怪物）管理</strong></h3><ol>
<li><p><strong>创建实体</strong></p>
<ul>
<li>通过 <code>EntityComponent</code> 生成角色、敌人、NPC 等：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GameEntry.Entity.ShowEntity(EntityId.Player, <span class="string">&quot;Assets/Player.prefab&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>实体回收</strong></p>
<ul>
<li><code>GameEntry.Entity.HideEntity(player);</code></li>
<li>结合对象池减少资源消耗。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="7-数据存储"><a href="#7-数据存储" class="headerlink" title="7. 数据存储"></a><strong>7. 数据存储</strong></h3><ol>
<li><p><strong>本地存储</strong></p>
<ul>
<li>采用 <code>PlayerPrefs</code> 存储 <strong>简单数据</strong>：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">PlayerPrefs.SetInt(<span class="string">&quot;HighScore&quot;</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>存档管理</strong></p>
<ul>
<li>复杂数据采用 <code>SaveComponent</code> 或 <code>Json</code> 文件存储：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GameEntry.Save.SaveToFile(<span class="string">&quot;save.json&quot;</span>, saveData);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="8-音效与BGM管理"><a href="#8-音效与BGM管理" class="headerlink" title="8. 音效与BGM管理"></a><strong>8. 音效与BGM管理</strong></h3><ol>
<li><p><strong>播放音效</strong></p>
<ul>
<li><code>GameEntry.Sound.PlaySound(&quot;Sound/Click&quot;);</code></li>
</ul>
</li>
<li><p><strong>背景音乐</strong></p>
<ul>
<li><code>GameEntry.Sound.PlayMusic(&quot;Music/BattleTheme&quot;);</code></li>
</ul>
</li>
<li><p><strong>音量控制</strong></p>
<ul>
<li><code>GameEntry.Sound.SetVolume(0.5f);</code></li>
</ul>
</li>
</ol>
<hr>
<h3 id="9-热更新（可选）"><a href="#9-热更新（可选）" class="headerlink" title="9. 热更新（可选）"></a><strong>9. 热更新（可选）</strong></h3><ol>
<li><p><strong>检查版本</strong></p>
<ul>
<li><code>GameEntry.Version.CheckUpdate();</code></li>
<li>若有更新，则下载新的资源并热加载。</li>
</ul>
</li>
<li><p><strong>更新资源</strong></p>
<ul>
<li>采用 <strong>AssetBundle 或 Addressables</strong>：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GameEntry.Resource.UpdateResources();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="10-退出游戏"><a href="#10-退出游戏" class="headerlink" title="10. 退出游戏"></a><strong>10. 退出游戏</strong></h3><ol>
<li><p><strong>游戏暂停</strong></p>
<ul>
<li><code>Time.timeScale = 0;</code></li>
</ul>
</li>
<li><p><strong>存档并退出</strong></p>
<ul>
<li><code>GameEntry.Save.SaveAll();</code></li>
<li><code>Application.Quit();</code></li>
</ul>
</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Game Framework 框架提供了一套完整的游戏开发流程：</p>
<ol>
<li><strong>初始化框架</strong></li>
<li><strong>加载配置</strong></li>
<li><strong>资源管理</strong></li>
<li><strong>UI管理</strong></li>
<li><strong>事件驱动</strong></li>
<li><strong>实体管理</strong></li>
<li><strong>数据存储</strong></li>
<li><strong>音效管理</strong></li>
<li><strong>热更新</strong></li>
<li><strong>游戏退出</strong></li>
</ol>
<p>整个流程以 <strong>模块化架构</strong> 运行，降低耦合，提高开发效率。在实际项目中，可以根据需求扩展新的 <strong>组件（Component）</strong>，如 <strong>AI 系统</strong>、<strong>战斗系统</strong>、<strong>成就系统</strong> 等。</p>
<p>如果你需要具体的代码实现，或者对某个模块有深入的问题，可以继续交流！😊</p>
<h2 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h2><p>Game Framework，字面意思是游戏框架，基于Unity游戏引擎，将开发过程中常用的游戏模块封装起来，很大程度上规范了流程，提升了开发速度，保证了产品质量。</p>
<p>游戏框架提供了以下19个内置模块，后续还将开发更多模块供游戏开发者使用。： </p>
<ol>
<li><p><strong>Config</strong>——保存一些全局的只读游戏配置，比如玩家的初始速度，游戏的初始音量等。  </p>
</li>
<li><p><strong>数据节点</strong>——在树结构中保存任意类型的数据，以便在游戏运行时管理各种数据。  </p>
</li>
<li><p><strong>数据表</strong>——用于以预配置表格（如 Microsoft Excel 表格）的形式调用游戏数据。表格的格式可以自定义。  </p>
</li>
<li><p><strong>调试器</strong>——在 Unity 编辑器或开发版本中运行游戏时显示调试器窗口，以方便查看运行时日志和调试消息。用户可以将自己的功能注册到调试器窗口并方便地使用它们。  </p>
</li>
<li><p><strong>下载</strong>——提供下载文件的功能。用户可以自由设置同时使用多少个下载器。  </p>
</li>
<li><p><strong>实体</strong>——提供管理实体和实体组的能力，其中实体定义为游戏场景中动态创建的任何对象。它显示或隐藏实体，将一个实体附加到另一个实体（例如武器、马匹或抢夺另一个实体）。实体可以避免在使用后立即被销毁，因此可以回收再利用。  </p>
</li>
<li><p><strong>事件</strong>——为游戏逻辑提供触发或观察事件的机制。游戏框架中的许多模块在操作后都会触发事件，观察这些事件将在很大程度上解耦游戏逻辑模块。用户也可以定义自己的游戏逻辑事件。  </p>
</li>
<li><p><strong>文件系统</strong>——基于磁盘概念的虚拟文件系统，将分散的文件集中管理，优化资源加载时的内存分配，甚至可以分段加载资源，大大提升资源加载的性能。  </p>
</li>
<li><p><strong>FSM</strong>——提供创建、使用和销毁有限状态机的能力。对于某些类似状态机的游戏逻辑来说，使用此模块是个不错的选择。  </p>
</li>
<li><p><strong>本地化</strong>——提供游戏本地化的能力。游戏框架不仅支持文本的本地化，还支持各种资产的本地化。例如，游戏中的烟花效果可以本地化为各种版本，这样玩家在中文版中会看到“新年好”的效果，而在英文版中则会看到“Happy New Year”的效果。  </p>
</li>
<li><p><strong>网络</strong>——提供套接字连接，目前支持 TCP，并且 IPv4 和 IPv6 均有效。用户可以同时与不同的服务器建立多个连接。例如，用户可以连接到普通游戏服务器和另一个用于语音聊天的服务器。如果用户想要使用 ProtoBuf 等协议库，则可以继承并实现“Packet”类。  </p>
</li>
<li><p><strong>对象池</strong>——提供将对象缓存在池中的能力。避免频繁创建和销毁游戏对象，从而提高游戏性能。游戏框架本身使用对象池，用户可以方便地创建和管理自己的池。  </p>
</li>
<li><p><strong>程序</strong>——实际上是游戏整个生命周期的 FSM。通过程序来解耦不同的游戏状态是一个很好的习惯。对于网络游戏，你可能需要检查资源、更新资源、检查服务器列表、选择服务器、登录服务器和创建头像的程序。对于独立游戏，你可能需要在菜单和实际游戏玩法之间切换。用户可以通过简单地子类化和实现“ProcedureBase”类来添加程序。  </p>
</li>
<li><p><strong>Resource</strong>——只提供异步接口来加载资源。为了更好的游戏体验，我们不推荐使用同步方式，Game Framework 本身也使用了一套完整的异步资源加载体系。我们异步加载所有内容，包括简单的数据表、本地化文本，以及复杂的实体、场景、UI 等。同时，Game Framework 提供了默认的内存管理策略（当然，您也可以定义自己的策略）。大多数情况下，在使用 GameObject 实例时，您甚至不需要调用“Instantiate”或“Destroy”。  </p>
</li>
<li><p><strong>场景</strong>——提供管理场景的功能。它支持同时加载多个场景，并且允许用户随时卸载场景。因此可以轻松实现场景的部分加载&#x2F;卸载。  </p>
</li>
<li><p><strong>设置</strong>——通过封装 UnityEngine.PlayerPrefs 或将数据直接保存到磁盘，将玩家数据存储在键值对中。  </p>
</li>
<li><p><strong>声音</strong>——提供管理声音和声音组的功能。用户可以设置音频剪辑的属性，例如音量、剪辑是 2D 还是 3D，甚至可以将剪辑绑定到某个实体以跟随其位置。  </p>
</li>
<li><p><strong>UI</strong>——提供管理用户界面和 UI 组的功能，例如显示或隐藏、激活或停用以及深度更改。无论用户使用 Unity 内置的 uGUI 还是其他 UI 插件（例如 NGUI），他只需子类化“UIFormLogic”并实现自己的 UI 逻辑。UI 可以避免在使用后立即被销毁，从而被回收再利用。  </p>
</li>
<li><p><strong>Web请求</strong>——提供短连接特性，支持 GET 和 POST 方法向服务器发送请求并获取响应数据，并允许用户同时向不同的服务器发送请求。</p>
</li>
</ol>
<h2 id="流程模块"><a href="#流程模块" class="headerlink" title="流程模块"></a>流程模块</h2><p><img src="/.io//image.png"></p>
<p>这些类文件是 <strong>Unity Game Framework (UGF)</strong> 中的 <strong>Procedure</strong>（流程）模块，通常用于管理游戏的状态和流程控制。以下是每个类的大致作用：</p>
<ol>
<li><p><strong>ProcedureBase.cs</strong>  </p>
<ul>
<li>流程基类，定义所有流程的基础行为和接口。  </li>
<li>包含流程的初始化、进入、更新、离开等生命周期方法。</li>
</ul>
</li>
<li><p><strong>ProcedureChangeScene.cs</strong>  </p>
<ul>
<li>处理场景切换的流程。  </li>
<li>常用于在游戏关卡或场景间切换时，加载新场景或卸载旧场景。</li>
</ul>
</li>
<li><p><strong>ProcedureCheckResources.cs</strong>  </p>
<ul>
<li>检查游戏资源的完整性和可用性。  </li>
<li>通常在启动游戏时进行资源校验，以确保游戏能正常运行。</li>
</ul>
</li>
<li><p><strong>ProcedureCheckVersion.cs</strong>  </p>
<ul>
<li>检查游戏版本的流程。  </li>
<li>用于版本更新检测，如与服务器进行版本对比，提示用户更新。</li>
</ul>
</li>
<li><p><strong>ProcedureInitResources.cs</strong>  </p>
<ul>
<li>初始化资源的流程。  </li>
<li>在游戏启动时，预加载或初始化必要的资源。</li>
</ul>
</li>
<li><p><strong>ProcedureLaunch.cs</strong>  </p>
<ul>
<li>启动流程。  </li>
<li>通常是游戏开始的第一个流程，进行基础环境设置，如读取配置、初始化日志等。</li>
</ul>
</li>
<li><p><strong>ProcedureMain.cs</strong>  </p>
<ul>
<li>主游戏流程。  </li>
<li>控制游戏主逻辑的入口，如游戏运行、暂停、恢复等。</li>
</ul>
</li>
<li><p><strong>ProcedureMenu.cs</strong>  </p>
<ul>
<li>菜单流程。  </li>
<li>用于管理游戏主菜单的显示、隐藏及其交互逻辑。</li>
</ul>
</li>
<li><p><strong>ProcedurePreload.cs</strong>  </p>
<ul>
<li>预加载流程。  </li>
<li>提前加载一些常用的资源或场景，以减少游戏中的加载等待时间。</li>
</ul>
</li>
<li><p><strong>ProcedureSplash.cs</strong>  </p>
<ul>
<li>启动画面流程。  </li>
<li>控制启动画面的显示，如 Logo、版权信息等。</li>
</ul>
</li>
<li><p><strong>ProcedureUpdateResources.cs</strong>  </p>
<ul>
<li>资源更新流程。  </li>
<li>检查并下载资源更新包，支持热更新。</li>
</ul>
</li>
<li><p><strong>ProcedureUpdateVersion.cs</strong>  </p>
<ul>
<li>版本更新流程。  </li>
<li>处理游戏版本的更新，如强制更新、下载新版本等。</li>
</ul>
</li>
<li><p><strong>ProcedureVerifyResources.cs</strong>  </p>
<ul>
<li>资源验证流程。  </li>
<li>验证本地资源的完整性，如 MD5 校验，确保资源未被篡改。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a><strong>典型使用场景</strong></h3><ol>
<li><strong>游戏启动</strong>  <ul>
<li>ProcedureLaunch → ProcedureCheckVersion → ProcedureUpdateVersion</li>
</ul>
</li>
<li><strong>资源准备</strong>  <ul>
<li>ProcedureCheckResources → ProcedureInitResources → ProcedurePreload</li>
</ul>
</li>
<li><strong>主菜单</strong>  <ul>
<li>ProcedureSplash → ProcedureMenu</li>
</ul>
</li>
<li><strong>游戏过程</strong>  <ul>
<li>ProcedureMain → ProcedureChangeScene → ProcedureMain</li>
</ul>
</li>
<li><strong>资源更新</strong>  <ul>
<li>ProcedureCheckResources → ProcedureUpdateResources → ProcedureVerifyResources</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><strong>Procedure 模块</strong> 是 UGF 的核心，用于管理游戏的各个状态和流程，提供了一种解耦的方式来处理复杂的游戏逻辑。每个流程都可以单独编写、调试和维护，从而提高了开发效率和代码可维护性。</p>
<h1 id="C-热更新与资源热更新的对应关系。"><a href="#C-热更新与资源热更新的对应关系。" class="headerlink" title="C# 热更新与资源热更新的对应关系。"></a><strong>C# 热更新与资源热更新的对应关系</strong>。</h1><p>下面我将详细说明如何通过 <strong>HybridCLR</strong> 和 <strong>UnityGameFramework</strong> 完整实现 <strong>C# 热更新与资源热更新的下载与加载</strong>，以及它们如何对应和协调工作。</p>
<h3 id="1-C-热更新和资源热更新如何下载："><a href="#1-C-热更新和资源热更新如何下载：" class="headerlink" title="1. C# 热更新和资源热更新如何下载："></a><strong>1. C# 热更新和资源热更新如何下载：</strong></h3><h4 id="1-1-C-热更新的下载与加载"><a href="#1-1-C-热更新的下载与加载" class="headerlink" title="1.1 C# 热更新的下载与加载"></a><strong>1.1 C# 热更新的下载与加载</strong></h4><ol>
<li><p><strong>下载新的程序集：</strong></p>
<ul>
<li><p>C# 代码热更新是通过更新程序集来实现的。新的程序集通常存储在服务器上，并且可以通过 <strong>HTTP 请求</strong> 来下载。</p>
</li>
<li><p>你可以使用 Unity 的 <code>UnityWebRequest</code> 来下载更新的程序集。</p>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Networking;</span><br><span class="line"><span class="keyword">using</span> HybridCLR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HotfixManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> hotfixAssemblyUrl = <span class="string">&quot;https://your-server.com/hotfix/HotfixAssembly.dll&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下载热更新的程序集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DownloadHotfixAssembly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UnityWebRequest request = UnityWebRequest.Get(hotfixAssemblyUrl);</span><br><span class="line">        request.SendWebRequest().completed += (asyncOp) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.result == UnityWebRequest.Result.Success)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">byte</span>[] assemblyBytes = request.downloadHandler.data;</span><br><span class="line">                LoadHotfixAssembly(assemblyBytes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(<span class="string">&quot;Failed to download assembly: &quot;</span> + request.error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载热更新的程序集</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadHotfixAssembly</span>(<span class="params"><span class="built_in">byte</span>[] assemblyBytes</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 HybridCLR 加载新的程序集</span></span><br><span class="line">        RuntimeLoader.LoadAssembly(assemblyBytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这段代码中，<code>DownloadHotfixAssembly</code> 方法使用 <code>UnityWebRequest.Get</code> 从服务器下载更新的程序集，下载完成后会将程序集的字节数据传递给 <code>LoadHotfixAssembly</code> 方法，使用 <strong>HybridCLR</strong> 的 <code>RuntimeLoader.LoadAssembly</code> 方法加载新的程序集。</li>
</ul>
</li>
<li><p><strong>程序集加载后的代码更新：</strong></p>
<ul>
<li>下载并加载新的程序集后，你就可以跳转到新版本的 C# 代码并执行相应的热更新逻辑。此时，游戏中的运行时逻辑会被新的程序集替换。</li>
</ul>
</li>
</ol>
<h4 id="1-2-资源热更新的下载与加载"><a href="#1-2-资源热更新的下载与加载" class="headerlink" title="1.2 资源热更新的下载与加载"></a><strong>1.2 资源热更新的下载与加载</strong></h4><p>资源热更新的过程与 C# 热更新类似，也是通过下载新版本的资源文件来实现。资源可以通过 <strong>AssetBundles</strong>、<strong>Addressables</strong> 或自定义资源包的方式进行管理。</p>
<ol>
<li><p><strong>资源更新包下载：</strong></p>
<ul>
<li><p>通常资源热更新是基于版本控制的，在资源文件夹中会有一个 <code>version.txt</code> 或者 <code>resource_version.dat</code> 文件，记录着最新的资源版本。资源包会根据版本来下载。</p>
</li>
<li><p>使用 <code>UnityWebRequest</code> 下载新的资源包，并且使用 <code>AssetBundle</code> 或其他方法加载更新的资源。</p>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Networking;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResourceManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> resourceUpdateUrl = <span class="string">&quot;https://your-server.com/updates/ResourcePack.assetbundle&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下载更新的资源包</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DownloadResourcePack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UnityWebRequest request = UnityWebRequest.Get(resourceUpdateUrl);</span><br><span class="line">        request.SendWebRequest().completed += (asyncOp) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.result == UnityWebRequest.Result.Success)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">byte</span>[] assetBundleData = request.downloadHandler.data;</span><br><span class="line">                LoadResource(assetBundleData);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(<span class="string">&quot;Failed to download resource pack: &quot;</span> + request.error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载下载的资源包</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadResource</span>(<span class="params"><span class="built_in">byte</span>[] assetBundleData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        AssetBundle assetBundle = AssetBundle.LoadFromMemory(assetBundleData);</span><br><span class="line">        <span class="keyword">if</span> (assetBundle != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 加载资源</span></span><br><span class="line">            <span class="keyword">var</span> asset = assetBundle.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;UpdatedResource&quot;</span>);</span><br><span class="line">            Instantiate(asset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;Failed to load asset bundle.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>加载资源包：</strong></p>
<ul>
<li><code>DownloadResourcePack</code> 方法下载最新版本的资源包（例如 <code>.assetbundle</code> 文件），然后通过 <code>AssetBundle.LoadFromMemory</code> 将其加载到内存中。</li>
<li>使用 <code>assetBundle.LoadAsset&lt;T&gt;()</code> 来加载和实例化资源（比如新的模型或贴图）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-C-热更新与资源热更新的对应关系："><a href="#2-C-热更新与资源热更新的对应关系：" class="headerlink" title="2. C# 热更新与资源热更新的对应关系："></a><strong>2. C# 热更新与资源热更新的对应关系：</strong></h3><h4 id="2-1-如何保持-C-代码和资源的一致性："><a href="#2-1-如何保持-C-代码和资源的一致性：" class="headerlink" title="2.1 如何保持 C# 代码和资源的一致性："></a><strong>2.1 如何保持 C# 代码和资源的一致性：</strong></h4><ol>
<li><p><strong>版本控制同步：</strong></p>
<ul>
<li>当你更新 C# 代码时，可能需要更新与之相关的资源（例如 UI 的新版本，新的场景或新模型）。同样，更新资源时也可能需要配套更新代码（如新的脚本逻辑或组件绑定）。</li>
<li>你可以通过 <strong>版本号同步</strong> 来确保 C# 代码和资源的版本一致。通常，<strong>版本控制文件</strong>（例如 <code>version.txt</code> 或 <code>manifest.json</code>）会记录 C# 代码和资源的版本。</li>
<li>在下载 C# 代码和资源时，首先检查当前版本和最新版本是否一致，如果不一致，则一起更新它们。</li>
</ul>
</li>
<li><p><strong>热更新资源与代码的时序控制：</strong></p>
<ul>
<li>例如，在更新某个资源（如 <code>GameObject</code> 或 <code>UI</code>）时，可能需要相应的 C# 代码来支持这些资源的逻辑。通过在资源包中包含 <strong>资源版本和代码版本</strong>，确保这两者始终同步更新。</li>
<li>在资源下载完成后，下载相应的 C# 热更新程序集，并应用到运行时。</li>
</ul>
</li>
</ol>
<h4 id="2-2-示例流程："><a href="#2-2-示例流程：" class="headerlink" title="2.2 示例流程："></a><strong>2.2 示例流程：</strong></h4><ol>
<li><p><strong>检查版本：</strong></p>
<ul>
<li>客户端首先通过 <code>version.txt</code> 或类似文件检查当前的版本与服务器上资源和 C# 代码的版本。</li>
<li>如果有更新，首先下载新的资源包。</li>
</ul>
</li>
<li><p><strong>下载和加载 C# 热更新代码：</strong></p>
<ul>
<li>下载最新版本的 C# 热更新程序集（通过 HybridCLR），并加载到运行时。</li>
</ul>
</li>
<li><p><strong>更新资源：</strong></p>
<ul>
<li>在加载了新的 C# 程序集后，下载新的资源包并加载更新后的资源。</li>
</ul>
</li>
<li><p><strong>同步执行：</strong></p>
<ul>
<li>确保 <strong>C# 代码</strong> 和 <strong>资源</strong> 的版本是相互匹配的。比如，更新了一个 UI 组件的资源时，对应的 C# 脚本也需要同时更新，以保证逻辑正确。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-总结："><a href="#3-总结：" class="headerlink" title="3. 总结："></a><strong>3. 总结：</strong></h3><ul>
<li><strong>C# 热更新</strong>：通过 HybridCLR 下载和加载更新的程序集，确保新的逻辑和功能生效。</li>
<li><strong>资源热更新</strong>：通过下载并加载新的资源包（如 AssetBundle 或自定义资源格式），并将更新后的资源加载到游戏中。</li>
<li><strong>同步更新</strong>：使用版本控制确保 <strong>C# 代码</strong> 和 <strong>资源</strong> 版本的一致性，避免因版本不匹配而导致的逻辑错误或资源问题。</li>
</ul>
<p>通过这种方式，你可以实现 <strong>灵活的热更新系统</strong>，无论是 <strong>C# 代码</strong> 还是 <strong>游戏资源</strong>，都能够根据需要动态更新，并确保两者的匹配和协调工作。</p>
]]></content>
  </entry>
  <entry>
    <title>GitHub + CDN</title>
    <url>/2025/05/08/GitHub%20+%20CDN/</url>
    <content><![CDATA[<p>使用 <strong>GitHub + CDN</strong> 作为游戏下载官网的试水方案，是一种<strong>低成本、易上手</strong>的方式，适合独立开发者或小团队快速验证游戏需求，同时规避高额服务器和维护成本。以下是具体操作步骤和优化建议：</p>
<hr>
<h3 id="1-核心架构"><a href="#1-核心架构" class="headerlink" title="1. 核心架构"></a><strong>1. 核心架构</strong></h3><pre><code class="highlight mermaid">graph LR
   玩家 --&gt;|访问| GitHub_Pages[GitHub Pages官网]
   GitHub_Pages --&gt;|下载链接| GitHub_Releases[GitHub Releases]
   GitHub_Releases --&gt;|大文件| CDN[CDN缓存]
   CDN --&gt;|回源| 对象存储[Backblaze B2/AWS S3]</code></pre>

<ul>
<li><strong>GitHub Pages</strong>：托管静态官网（HTML&#x2F;CSS&#x2F;JS）。  </li>
<li><strong>GitHub Releases</strong>：存放游戏安装包（小文件直接下载）。  </li>
<li><strong>CDN + 对象存储</strong>：分流大文件（避免GitHub流量限制）。</li>
</ul>
<hr>
<h3 id="2-具体操作步骤"><a href="#2-具体操作步骤" class="headerlink" title="2. 具体操作步骤"></a><strong>2. 具体操作步骤</strong></h3><h4 id="（1）上传游戏文件到GitHub-Releases"><a href="#（1）上传游戏文件到GitHub-Releases" class="headerlink" title="（1）上传游戏文件到GitHub Releases"></a><strong>（1）上传游戏文件到GitHub Releases</strong></h4><ol>
<li>在GitHub仓库中，点击 <strong>“Releases”</strong> → **”Draft a new release”**。  </li>
<li>上传游戏包（如 <code>game_windows_v1.0.zip</code>），版本号命名规范（如 <code>v1.0.0</code>）。  </li>
<li>获取直链：  <ul>
<li>右键文件 → **”Copy link address”**，格式如：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/用户名/仓库名/releases/download/v1.0/game.zip</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="（2）用GitHub-Pages搭建官网"><a href="#（2）用GitHub-Pages搭建官网" class="headerlink" title="（2）用GitHub Pages搭建官网"></a><strong>（2）用GitHub Pages搭建官网</strong></h4><ol>
<li>创建仓库 <code>用户名.github.io</code>（如 <code>MyGame.github.io</code>），启用GitHub Pages。  </li>
<li>编写简易官网HTML，添加下载按钮：  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com/MyGame/repo/releases/latest/download/game.zip&quot;</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">class</span>=<span class="string">&quot;download-button&quot;</span>&gt;</span></span><br><span class="line">   下载游戏（Windows）</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>latest/download</code> 自动指向最新版本。</li>
</ul>
</li>
</ol>
<h4 id="（3）设置CDN分流（应对大文件-高流量）"><a href="#（3）设置CDN分流（应对大文件-高流量）" class="headerlink" title="（3）设置CDN分流（应对大文件&#x2F;高流量）"></a><strong>（3）设置CDN分流（应对大文件&#x2F;高流量）</strong></h4><p><strong>方案A：Cloudflare CDN + Backblaze B2（免费层可用）</strong>  </p>
<ol>
<li>将游戏包上传至 <strong>Backblaze B2</strong>（免费10GB存储，1GB&#x2F;天下载流量）。  </li>
<li>在Cloudflare中：  <ul>
<li>添加B2存储桶为源站，绑定自定义域名（如 <code>download.mygame.com</code>）。  </li>
<li>开启 <strong>Cache Everything</strong> 和 <strong>Brotli压缩</strong>。</li>
</ul>
</li>
<li>替换官网下载链接为CDN地址：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://download.mygame.com/file/game.zip</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>方案B：jsDelivr（免费CDN，适合开源项目）</strong>  </p>
<ol>
<li>通过GitHub Releases的 <code>tag</code> 生成jsDelivr链接：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/用户名/仓库名@v1.0/game.zip</span><br></pre></td></tr></table></figure>
<ul>
<li>需公开仓库，且有版本标签（如 <code>v1.0</code>）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-优化技巧"><a href="#3-优化技巧" class="headerlink" title="3. 优化技巧"></a><strong>3. 优化技巧</strong></h3><h4 id="（1）绕过GitHub流量限制"><a href="#（1）绕过GitHub流量限制" class="headerlink" title="（1）绕过GitHub流量限制"></a><strong>（1）绕过GitHub流量限制</strong></h4><ul>
<li><strong>分卷压缩</strong>：将游戏包拆分为多个小文件（如 <code>part1.zip</code>, <code>part2.zip</code>），减少单文件下载压力。  </li>
<li><strong>多仓库备份</strong>：热门游戏可同步上传到多个GitHub仓库，分散下载请求。</li>
</ul>
<h4 id="（2）提升下载速度"><a href="#（2）提升下载速度" class="headerlink" title="（2）提升下载速度"></a><strong>（2）提升下载速度</strong></h4><ul>
<li><strong>CDN预热</strong>：提前将文件缓存到CDN边缘节点（Cloudflare企业版支持）。  </li>
<li><strong>P2P分发</strong>：在官网集成 <a href="https://webtorrent.io/">WebTorrent</a>，允许玩家互相分享下载。</li>
</ul>
<h4 id="（3）监控与安防"><a href="#（3）监控与安防" class="headerlink" title="（3）监控与安防"></a><strong>（3）监控与安防</strong></h4><ul>
<li><strong>流量统计</strong>：  <ul>
<li>用 <strong>Google Analytics</strong> 跟踪官网访问量。  </li>
<li>在Cloudflare面板查看CDN请求数。</li>
</ul>
</li>
<li><strong>防滥用</strong>：  <ul>
<li>设置Cloudflare防火墙规则，拦截高频IP（如每秒&gt;5次请求）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-适用场景与限制"><a href="#4-适用场景与限制" class="headerlink" title="4. 适用场景与限制"></a><strong>4. 适用场景与限制</strong></h3><table>
<thead>
<tr>
<th>场景</th>
<th>推荐方案</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td><strong>免费游戏试玩</strong></td>
<td>GitHub Releases直链</td>
<td>文件需&lt;2GB，避免频繁更新触发限流。</td>
</tr>
<tr>
<td><strong>开源项目分发</strong></td>
<td>jsDelivr CDN</td>
<td>必须公开仓库，适合Demo或工具类游戏。</td>
</tr>
<tr>
<td><strong>商业游戏早期测试</strong></td>
<td>Cloudflare+B2</td>
<td>超出免费流量后成本可控（$0.01&#x2F;GB）。</td>
</tr>
<tr>
<td><strong>大规模正式发布</strong></td>
<td>需迁移至专业CDN&#x2F;自建</td>
<td>GitHub不适合高并发（&gt;1000次&#x2F;小时）。</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-成本对比"><a href="#5-成本对比" class="headerlink" title="5. 成本对比"></a><strong>5. 成本对比</strong></h3><table>
<thead>
<tr>
<th>方案</th>
<th>存储成本</th>
<th>流量成本（1TB下载）</th>
<th>适用阶段</th>
</tr>
</thead>
<tbody><tr>
<td><strong>GitHub直链</strong></td>
<td>免费</td>
<td>免费（但有限流风险）</td>
<td>原型&#x2F;测试</td>
</tr>
<tr>
<td><strong>Cloudflare+B2</strong></td>
<td>$0.005&#x2F;GB&#x2F;月</td>
<td>$10~$50</td>
<td>小规模发布</td>
</tr>
<tr>
<td><strong>AWS S3+CloudFront</strong></td>
<td>$0.023&#x2F;GB&#x2F;月</td>
<td>$85~$120</td>
<td>中等规模</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><strong>GitHub + CDN试水的最佳实践</strong>：  </p>
<ol>
<li>用 <strong>GitHub Pages</strong> 快速上线官网，<strong>Releases</strong> 托管小文件。  </li>
<li>大文件通过 <strong>Cloudflare + Backblaze B2</strong> 分流，月成本可控制在$10以内。  </li>
<li>监控流量，超出免费层后迁移至专业CDN（如AWS CloudFront）。</li>
</ol>
<p>此方案适合：  </p>
<ul>
<li>独立开发者验证游戏热度。  </li>
<li>开源项目或免费游戏分发。  </li>
<li>规避早期服务器运维成本。</li>
</ul>
]]></content>
      <categories>
        <category>GitHub,CDN</category>
      </categories>
      <tags>
        <tag>GitHub,CDN</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub Actions 没有触发的核心原因</title>
    <url>/2025/05/08/GitHub%20Actions%20%E6%B2%A1%E6%9C%89%E8%A7%A6%E5%8F%91/</url>
    <content><![CDATA[<p>谢谢提供路径信息。</p>
<p>你的 GitHub Actions 没有触发的<strong>核心原因</strong>在于：</p>
<blockquote>
<p>你把 <code>deploy.yml</code> 放在了 <strong><code>mr-liu-cheng.github.io/blog/.github/workflows/deploy.yml</code></strong><br>而它 <strong>应该放在仓库根目录下的 <code>.github/workflows/</code> 中</strong>，即：<br>✅ 正确路径是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mr-liu-cheng.github.io/.github/workflows/deploy.yml</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h2 id="🔧-为什么要这样放？"><a href="#🔧-为什么要这样放？" class="headerlink" title="🔧 为什么要这样放？"></a>🔧 为什么要这样放？</h2><p>GitHub Actions 的工作流只会被识别和执行 <strong>主仓库 <code>.github/workflows/</code> 目录下的 YAML 文件</strong>，这是固定机制，不能嵌套到子目录或子文件夹里（比如你现在的 <code>blog/</code> 子目录）。</p>
<hr>
<h2 id="✅-修复步骤（只需一次性修改）"><a href="#✅-修复步骤（只需一次性修改）" class="headerlink" title="✅ 修复步骤（只需一次性修改）"></a>✅ 修复步骤（只需一次性修改）</h2><p>你可以按下面操作调整：</p>
<h3 id="①-把-deploy-yml-移动到主目录-github-workflows-："><a href="#①-把-deploy-yml-移动到主目录-github-workflows-：" class="headerlink" title="① 把 deploy.yml 移动到主目录 .github/workflows/："></a>① 把 <code>deploy.yml</code> 移动到主目录 <code>.github/workflows/</code>：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从 blog 子目录移回仓库根目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p .github/workflows</span><br><span class="line"><span class="built_in">mv</span> blog/.github/workflows/deploy.yml .github/workflows/deploy.yml</span><br></pre></td></tr></table></figure>

<h3 id="②-提交并推送修改："><a href="#②-提交并推送修改：" class="headerlink" title="② 提交并推送修改："></a>② 提交并推送修改：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .github/workflows/deploy.yml</span><br><span class="line">git commit -m <span class="string">&quot;Fix: Move deploy.yml to correct workflows directory&quot;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<h3 id="③-推送任意文章或文件到-master-分支再试一次："><a href="#③-推送任意文章或文件到-master-分支再试一次：" class="headerlink" title="③ 推送任意文章或文件到 master 分支再试一次："></a>③ 推送任意文章或文件到 <code>master</code> 分支再试一次：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test&quot;</span> &gt;&gt; test.md</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Trigger deployment&quot;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>然后你去 GitHub 页面上看 Actions 选项卡，应该就会触发部署流程了 ✅</p>
<hr>
<h2 id="🚀-补充建议"><a href="#🚀-补充建议" class="headerlink" title="🚀 补充建议"></a>🚀 补充建议</h2><p>如果你有多级子目录结构用于管理博客源码，可以在 <code>blog/</code> 下保留源码，但确保部署 workflow 放在主路径下。</p>
<p>或者用两仓库方案也可以（一个写博客源码，一个部署页面），具体可根据你习惯来。</p>
<hr>
<p>是否需要我给你一份推荐结构的 Hexo 博客项目模板？也可以直接 fork 来用。</p>
]]></content>
      <categories>
        <category>GitHub Actions</category>
      </categories>
      <tags>
        <tag>GitHub Actions</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub Actions部署流程</title>
    <url>/2025/05/08/GitHub%20Actions%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%20%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>我们来逐步<strong>解读你提供的 GitHub Actions 自动部署 Hexo 博客的完整脚本</strong>，帮助你理解每一步在干什么、为什么需要它：</p>
<hr>
<h3 id="🧾-YAML-脚本结构快速回顾"><a href="#🧾-YAML-脚本结构快速回顾" class="headerlink" title="🧾 YAML 脚本结构快速回顾"></a>🧾 YAML 脚本结构快速回顾</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<h4 id="✅-含义："><a href="#✅-含义：" class="headerlink" title="✅ 含义："></a>✅ 含义：</h4><ul>
<li><code>name</code>: 工作流的名称，显示在 GitHub Actions 页中。</li>
<li><code>on.push.branches</code>: 表示当你向 <code>master</code> 分支推送代码时，会自动触发这个部署工作流。</li>
</ul>
<hr>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br></pre></td></tr></table></figure>

<h4 id="✅-含义：-1"><a href="#✅-含义：-1" class="headerlink" title="✅ 含义："></a>✅ 含义：</h4><ul>
<li>定义了一个名为 <code>build</code> 的任务（job）</li>
<li><code>runs-on: ubuntu-latest</code> 表示 GitHub 提供的云服务器上使用最新的 Ubuntu 系统执行任务</li>
</ul>
<hr>
<h3 id="🚀-核心步骤一览"><a href="#🚀-核心步骤一览" class="headerlink" title="🚀 核心步骤一览"></a>🚀 核心步骤一览</h3><hr>
<h4 id="1️⃣-获取仓库代码"><a href="#1️⃣-获取仓库代码" class="headerlink" title="1️⃣ 获取仓库代码"></a>1️⃣ 获取仓库代码</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">repository</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br></pre></td></tr></table></figure>

<p>✅ 使用官方的 <code>checkout</code> Action 把当前仓库的源码拉下来。</p>
<hr>
<h4 id="2️⃣-设置-Node-js-环境"><a href="#2️⃣-设置-Node-js-环境" class="headerlink" title="2️⃣ 设置 Node.js 环境"></a>2️⃣ 设置 Node.js 环境</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">node-version:</span> <span class="string">&#x27;20&#x27;</span></span><br></pre></td></tr></table></figure>

<p>✅ 安装指定版本的 Node.js 环境，因为 Hexo 是基于 Node.js 的静态站点生成器。</p>
<hr>
<h4 id="3️⃣-安装依赖"><a href="#3️⃣-安装依赖" class="headerlink" title="3️⃣ 安装依赖"></a>3️⃣ 安装依赖</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br></pre></td></tr></table></figure>

<p>✅ 安装你 <code>package.json</code> 中定义的所有 Hexo 插件、主题依赖（比如主题支持的 <code>hexo-renderer-*</code>、<code>hexo-generator-*</code> 等）。</p>
<hr>
<h4 id="4️⃣-安装部署插件和-Hexo-CLI"><a href="#4️⃣-安装部署插件和-Hexo-CLI" class="headerlink" title="4️⃣ 安装部署插件和 Hexo CLI"></a>4️⃣ 安装部署插件和 Hexo CLI</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Hexo</span> <span class="string">Git</span> <span class="string">Deployer</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    npm install hexo-deployer-git --save</span></span><br><span class="line"><span class="string">    npm install hexo-cli -g</span></span><br></pre></td></tr></table></figure>

<p>✅ <code>hexo-deployer-git</code>: 用于将生成的静态文件部署到 GitHub Pages<br>✅ <code>hexo-cli -g</code>: 全局安装 Hexo 命令行工具，后面需要执行 <code>hexo generate</code> 命令</p>
<hr>
<h4 id="5️⃣-生成静态页面"><a href="#5️⃣-生成静态页面" class="headerlink" title="5️⃣ 生成静态页面"></a>5️⃣ 生成静态页面</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Clean</span> <span class="string">and</span> <span class="string">Generate</span> <span class="string">Static</span> <span class="string">Files</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    hexo clean</span></span><br><span class="line"><span class="string">    hexo generate</span></span><br></pre></td></tr></table></figure>

<p>✅ <code>hexo clean</code>: 清理之前生成的 <code>public/</code><br>✅ <code>hexo generate</code>: 将 Markdown 和配置转化为静态网站内容，放入 <code>public/</code> 文件夹</p>
<hr>
<h4 id="6️⃣-配置-Git-信息（用于提交）"><a href="#6️⃣-配置-Git-信息（用于提交）" class="headerlink" title="6️⃣ 配置 Git 信息（用于提交）"></a>6️⃣ 配置 Git 信息（用于提交）</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">Git</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    git config --global user.name &#x27;github-actions[bot]&#x27;</span></span><br><span class="line"><span class="string">    git config --global user.email &#x27;github-actions[bot]@users.noreply.github.com&#x27;</span></span><br></pre></td></tr></table></figure>

<p>✅ 配置 Git 用户信息，避免提交时报错。</p>
<hr>
<h4 id="7️⃣-推送到-GitHub-Pages"><a href="#7️⃣-推送到-GitHub-Pages" class="headerlink" title="7️⃣ 推送到 GitHub Pages"></a>7️⃣ 推送到 GitHub Pages</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">GH_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GH_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    cd public/</span></span><br><span class="line"><span class="string">    git init</span></span><br><span class="line"><span class="string">    git add -A</span></span><br><span class="line"><span class="string">    git commit -m &quot;Create by workflows&quot;</span></span><br><span class="line"><span class="string">    git remote add origin https://$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@github.com/Mr-liu-cheng/mr-liu-cheng.github.io.git</span></span><br><span class="line"><span class="string">    git push origin HEAD:gh-pages -f</span></span><br></pre></td></tr></table></figure>

<p>✅ 这段代码作用：</p>
<ul>
<li>进入 Hexo 生成的 <code>public/</code> 静态目录</li>
<li>初始化 Git 仓库</li>
<li>用你设置的 <code>GH_TOKEN</code>（GitHub Token）认证身份</li>
<li>将 <code>public/</code> 目录的内容强制推送到部署仓库（<code>gh-pages</code> 分支）</li>
</ul>
<p>这样 GitHub Pages 就可以用 <code>gh-pages</code> 分支中的内容部署网页。</p>
<hr>
<h3 id="🔒-GH-TOKEN-是干什么用的？"><a href="#🔒-GH-TOKEN-是干什么用的？" class="headerlink" title="🔒 GH_TOKEN 是干什么用的？"></a>🔒 <code>GH_TOKEN</code> 是干什么用的？</h3><p>这是一个 <strong>私密令牌（Personal Access Token）</strong>，用于允许 GitHub Actions 自动推送内容到仓库。</p>
<p>你需要在源仓库的 <strong>Settings &gt; Secrets</strong> 中添加：</p>
<ul>
<li>名称：<code>GH_TOKEN</code></li>
<li>内容：GitHub PAT，要求权限包含：<code>repo</code>（公开仓库也可不选）</li>
</ul>
<hr>
<h3 id="✅-总结：这个-Actions-脚本做了什么？"><a href="#✅-总结：这个-Actions-脚本做了什么？" class="headerlink" title="✅ 总结：这个 Actions 脚本做了什么？"></a>✅ 总结：这个 Actions 脚本做了什么？</h3><p>简要流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你 git push 文章 --&gt; GitHub 触发 Action --&gt; 自动安装依赖并构建静态网站 --&gt; 自动部署 public/ 到 gh-pages</span><br></pre></td></tr></table></figure>

<p>📌 <strong>结果：你写完文章推送后，网页几秒后自动更新，不再需要本地执行 <code>hexo deploy</code> 命令。</strong></p>
<hr>
<p>是否需要我帮你生成一个带图标徽章的 README 标明“本项目使用 GitHub Actions 自动部署”？</p>
]]></content>
      <categories>
        <category>GitHub Actions</category>
      </categories>
      <tags>
        <tag>GitHub Actions</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub action 自动发布博客</title>
    <url>/2025/05/12/GitHub%20action%20%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>完整推荐如下：</p>
<p>✅ 推荐版本（添加 clean、修正路径）</p>
<p>name: Deploy Hexo Blog to GitHub Pages</p>
<p>on:<br>  push:<br>    branches:<br>      - master</p>
<p>jobs:<br>  build-deploy:<br>    runs-on: ubuntu-latest</p>
<pre><code>steps:
  - name: Checkout repository
    uses: actions/checkout@v3

  - name: Setup Node.js
    uses: actions/setup-node@v3
    with:
      node-version: 18

  - name: Install Hexo CLI
    run: npm install -g hexo-cli

  - name: Install dependencies
    run: npm install
    working-directory: blog

  - name: Clean previous builds
    run: hexo clean
    working-directory: blog

  - name: Generate static files
    run: hexo generate
    working-directory: blog

  - name: Deploy to GitHub Pages
    uses: peaceiris/actions-gh-pages@v3
    with:
      github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;
      publish_dir: ./blog/public
</code></pre>
<p>🔍 hexo deploy 是否还需要？</p>
<p>不需要！因为：<br>    •	hexo deploy 是调用 hexo-deployer-git 插件把 public 推到 GitHub。<br>    •	你已经使用了 peaceiris&#x2F;actions-gh-pages，它更灵活稳定，也是 GitHub 官方推荐方式之一。<br>    •	所以你可以直接省略 hexo deploy，让 Actions 帮你部署更好。</p>
<p>是否需要我帮你配置一个同时部署文章和运行本地预览的 dev 构建方案？或者加上自动评论等插件支持？</p>
<p>你在 GitHub 仓库里看不到 public&#x2F; 文件夹 是正常的，因为：</p>
<ol>
<li><p>public&#x2F; 是 Hexo 生成的构建产物，只存在于 GitHub Actions 的临时 Runner 中</p>
<p> •	当你 push 到 master 分支时，GitHub Actions 会：<br> •	克隆你的代码（含 blog&#x2F; 目录）<br> •	安装依赖、执行 hexo generate，生成 public&#x2F; 静态页面<br> •	将 public&#x2F; 目录上传到 gh-pages 分支（用于 GitHub Pages 托管）</p>
<p> 这些操作在 GitHub Actions 的临时环境中进行，不会提交 public&#x2F; 到 master 分支</p>
</li>
<li><p>为什么不把 public&#x2F; 提交到源码里？</p>
</li>
</ol>
<p>这是最佳实践。因为：<br>    •	public&#x2F; 是构建产物，自动生成的<br>    •	提交构建产物到源码分支（如 master）会让 repo 变得臃肿，历史记录难管理<br>    •	CI&#x2F;CD 工具（如 GitHub Actions）已经可以自动构建和发布</p>
<ol start="3">
<li>你可以在哪里看到生成后的 public 内容？</li>
</ol>
<p>在 GitHub 仓库的 gh-pages 分支！</p>
<p>地址格式一般是：</p>
<p><a href="https://github.com/%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BD%A0%E7%9A%84%E4%BB%93%E5%BA%93%E5%90%8D/tree/gh-pages">https://github.com/你的用户名/你的仓库名/tree/gh-pages</a></p>
<p>比如：</p>
<p><a href="https://github.com/mr-liu-cheng/mr-liu-cheng.github.io/tree/gh-pages">https://github.com/mr-liu-cheng/mr-liu-cheng.github.io/tree/gh-pages</a></p>
<p>那里的文件内容就是 hexo generate 后的 public&#x2F; 文件。</p>
<ol start="4">
<li>如果你非要在本地看到 public&#x2F;？</li>
</ol>
<p>可以本地跑：</p>
<p>cd blog<br>hexo clean<br>hexo g</p>
<p>然后就能在 blog&#x2F;public&#x2F; 中看到生成的 HTML 静态页面。</p>
<p>总结：</p>
<p>问题	原因<br>GitHub 仓库里没有 public&#x2F;	它是构建产物，只生成在 GitHub Actions 的临时环境中<br>构建后的页面在哪？	在 gh-pages 分支上，GitHub Pages 用来展示<br>本地要看 public&#x2F;？	自己本地运行 hexo generate 即可</p>
<p>需要我帮你配置自动预览或访问地址验证一下部署成功了吗？</p>
<p>覆盖分支提交</p>
<p>你说的“原来的文件被清空了”，是指 GitHub 仓库中的文件，被 GitHub Actions 的部署流程替换&#x2F;清空了，这确实是有可能的。</p>
<p>我们来详细分析下原因：</p>
<ol>
<li>你使用的是 peaceiris&#x2F;actions-gh-pages</li>
</ol>
<p>它的行为是：<br>部署时会把 gh-pages 分支内容全部清空，然后用你指定的 publish_dir 中的内容覆盖并提交。</p>
<p>也就是说，它不是“追加”，是替换整个 gh-pages 分支，用于 GitHub Pages 展示静态网站。</p>
<p>配置部署檢查：</p>
<p>最后确认几点：</p>
<pre><code>•	你的 Hexo 配置文件 _config.yml、source/ 等确实都在 blog/ 中
•	deploy.yml 脚本中所有 Hexo 命令的 working-directory 都是 blog
•	publish_dir 是 ./blog/public
</code></pre>
<p>部署完成后，可以访问 GitHub Pages 设置页面确认是否启用了 GitHub Pages，并且指向了 gh-pages 分支。</p>
]]></content>
      <categories>
        <category>GitHub Actions</category>
      </categories>
      <tags>
        <tag>GitHub Actions</tag>
      </tags>
  </entry>
  <entry>
    <title>Github-Hexo 部署脚本</title>
    <url>/2025/05/12/Github-Hexo%20%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h1><ul>
<li>根目录，不然是不会有action记录，不会执行</li>
<li>token方式  ，推荐使用GITHUB_TOKEN</li>
<li>分支</li>
<li>相对路径： working-directory: blog，一般不用指定，我是因为创建一层父文件夹隔离导致无法正常访问才不得已需要它</li>
<li>只要你把 GitHub Actions 的 .yml 文件放在 .github&#x2F;workflows&#x2F; 目录下，GitHub 就会自动识别并执行这个工作流，无论文件名是 deploy1.yml、deploy.yml 还是其他名字。</li>
</ul>
<p>代码1：旧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: Deploy Hexo to GitHub Pages</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - master</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">      - name: Checkout repository</span><br><span class="line">        uses: actions/checkout@v2</span><br><span class="line">        with:</span><br><span class="line">          submodules: false  # 禁用子模块检查</span><br><span class="line"></span><br><span class="line">      - name: Setup Node.js</span><br><span class="line">        uses: actions/setup-node@v2</span><br><span class="line">        with:</span><br><span class="line">          node-version: &#x27;20&#x27;</span><br><span class="line"></span><br><span class="line">      - name: Install Dependencies</span><br><span class="line">        run: npm install</span><br><span class="line">        working-directory: blog</span><br><span class="line"></span><br><span class="line">      - name: Install Hexo Git Deployer</span><br><span class="line">        run: |</span><br><span class="line">          npm install hexo-deployer-git --save</span><br><span class="line">          npm install hexo-cli -g</span><br><span class="line">        working-directory: blog</span><br><span class="line"></span><br><span class="line">      - name: Clean and Generate Static Files</span><br><span class="line">        run: |</span><br><span class="line">          hexo clean</span><br><span class="line">          hexo generate</span><br><span class="line">        working-directory: blog</span><br><span class="line"></span><br><span class="line">      - name: Configure Git</span><br><span class="line">        run: |</span><br><span class="line">          git config --global user.name &#x27;github-actions[bot]&#x27;</span><br><span class="line">          git config --global user.email &#x27;github-actions[bot]@users.noreply.github.com&#x27;</span><br><span class="line"></span><br><span class="line">      - name: Deploy to GitHub Pages</span><br><span class="line">        env:</span><br><span class="line">          GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        run: |</span><br><span class="line">          cd blog/public/</span><br><span class="line">          git init</span><br><span class="line">          git config user.name &#x27;github-actions[bot]&#x27;</span><br><span class="line">          git config user.email &#x27;github-actions[bot]@users.noreply.github.com&#x27;</span><br><span class="line">          git add -A</span><br><span class="line">          git commit -m &quot;Create by workflows&quot;</span><br><span class="line">          git branch -M gh-pages</span><br><span class="line">          git remote add origin https://x-access-token:$&#123;GITHUB_TOKEN&#125;@github.com/Mr-liu-cheng/mr-liu-cheng.github.io.git</span><br><span class="line">          git push origin gh-pages --force</span><br></pre></td></tr></table></figure>

<p>代码2：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span> <span class="string">Blog</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span>  <span class="comment"># 你是用 master 而不是 main 分支</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">repository</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Hexo</span> <span class="string">CLI</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">        <span class="attr">working-directory:</span> <span class="string">blog</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Clean</span> <span class="string">old</span> <span class="string">files</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">        <span class="attr">working-directory:</span> <span class="string">blog</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">static</span> <span class="string">files</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">        <span class="attr">working-directory:</span> <span class="string">blog</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./blog/public</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p>这两种方式都能成功部署 Hexo 到 GitHub Pages，但它们实现机制不同，适用于不同场景。我们可以从<strong>安全性、简洁性、维护性、灵活性</strong>等维度对比，给你明确建议。</p>
<hr>
<h2 id="✅-建议优先使用：代码2（推荐）"><a href="#✅-建议优先使用：代码2（推荐）" class="headerlink" title="✅ 建议优先使用：代码2（推荐）"></a>✅ 建议优先使用：<strong>代码2（推荐）</strong></h2><p>使用 <code>peaceiris/actions-gh-pages@v3</code> 这个 Action 更安全、更简洁，是目前社区中最常用的部署方式。</p>
<hr>
<h2 id="✨-对比分析："><a href="#✨-对比分析：" class="headerlink" title="✨ 对比分析："></a>✨ 对比分析：</h2><table>
<thead>
<tr>
<th>比较项</th>
<th>代码1（自己写 push 脚本）</th>
<th>✅ 代码2（使用 peaceiris&#x2F;actions-gh-pages）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>简洁性</strong></td>
<td>❌ 手动写 <code>git init</code>, <code>remote</code>, <code>push</code> 等，代码多</td>
<td>✅ 封装好了所有逻辑，只需设置参数</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>🔐 需要小心 Token 拼接（可能泄露）</td>
<td>✅ 使用官方方式处理 token，内置防泄露</td>
</tr>
<tr>
<td><strong>维护性</strong></td>
<td>❌ 需要自己维护 git 逻辑，容易出错</td>
<td>✅ 官方维护的 Action，可靠稳定</td>
</tr>
<tr>
<td><strong>兼容性</strong></td>
<td>✅ 更灵活（可以用于非 GitHub Pages 部署）</td>
<td>🟡 更专注于 GitHub Pages（但这就是你的目标）</td>
</tr>
<tr>
<td><strong>常见性</strong></td>
<td>❌ 不利于新人阅读维护</td>
<td>✅ 目前 Hexo + GitHub Pages 最通用写法</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-推荐做法："><a href="#✅-推荐做法：" class="headerlink" title="✅ 推荐做法："></a>✅ 推荐做法：</h2><p>如果你只是想<strong>把博客部署到 GitHub Pages（gh-pages 分支）</strong>，建议<strong>使用代码2</strong>，维护简单、安全稳定。</p>
<hr>
<h2 id="⛳-如果你未来要部署到其他仓库或服务器："><a href="#⛳-如果你未来要部署到其他仓库或服务器：" class="headerlink" title="⛳ 如果你未来要部署到其他仓库或服务器："></a>⛳ 如果你未来要部署到其他仓库或服务器：</h2><p>那可以使用代码1那样的「自定义部署逻辑」，比如部署到其他远程仓库、私服、服务器目录等。</p>
<hr>
<p>需要我给你整理一份更完整的推荐 <code>deploy.yml</code> 模板吗？</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>GitHub,Actions,Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Categories 语法</title>
    <url>/2025/05/08/Hexo%20Categories%20%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>你提到的困惑很常见，Hexo 的分类嵌套和并列写法在语法上相似，但实际效果完全不同。下面我用具体例子对比说明它们的区别：</p>
<hr>
<h3 id="1-分类层级嵌套（父子关系）"><a href="#1-分类层级嵌套（父子关系）" class="headerlink" title="1. 分类层级嵌套（父子关系）"></a><strong>1. 分类层级嵌套（父子关系）</strong></h3><h4 id="写法："><a href="#写法：" class="headerlink" title="写法："></a>写法：</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="string">GitHub</span>, <span class="string">Actions</span>]  <span class="comment"># 方括号表示嵌套</span></span><br></pre></td></tr></table></figure>
<h4 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h4><p>生成 <strong>层级分类</strong>，结构为：<br><code>GitHub</code> → <code>Actions</code>（即 “GitHub 是父分类，Actions 是子分类”）<br>文章会归到 <code>GitHub/Actions</code> 下，且自动继承父分类 <code>GitHub</code>。</p>
<h4 id="验证方法："><a href="#验证方法：" class="headerlink" title="验证方法："></a>验证方法：</h4><ul>
<li>在生成的网页中，分类会显示为层级路径（如 <code>GitHub &gt; Actions</code>）。</li>
<li>访问 <code>/categories/GitHub/Actions/</code> 能看到该文章。</li>
</ul>
<hr>
<h3 id="2-多分类并列（独立关系）"><a href="#2-多分类并列（独立关系）" class="headerlink" title="2. 多分类并列（独立关系）"></a><strong>2. 多分类并列（独立关系）</strong></h3><h4 id="写法：-1"><a href="#写法：-1" class="headerlink" title="写法："></a>写法：</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">GitHub</span>   <span class="comment"># 无方括号，独立分类</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Actions</span>  <span class="comment"># 无方括号，独立分类</span></span><br></pre></td></tr></table></figure>
<h4 id="效果：-1"><a href="#效果：-1" class="headerlink" title="效果："></a>效果：</h4><p>生成 <strong>两个独立分类</strong>：  </p>
<ul>
<li><code>GitHub</code>（文章属于此分类）</li>
<li><code>Actions</code>（文章也属于此分类）<br>二者无任何层级关联。</li>
</ul>
<h4 id="验证方法：-1"><a href="#验证方法：-1" class="headerlink" title="验证方法："></a>验证方法：</h4><ul>
<li>网页中会显示两个平级分类标签（如 <code>GitHub</code> 和 <code>Actions</code>）。</li>
<li>访问 <code>/categories/GitHub/</code> 和 <code>/categories/Actions/</code> 都能看到该文章。</li>
</ul>
<hr>
<p>核心区别：方括号 &#96;[] 的作用<br>Hexo 中分类的层级关系完全由 方括号 [] 决定：</p>
<p>带方括号 → 嵌套层级（父子分类）</p>
<ul>
<li>[A, B] &#x3D; 生成 A 为父分类，B 为子分类，路径为 A&#x2F;B。</li>
</ul>
<p>不带方括号 → 独立并列分类</p>
<ul>
<li>A + - B &#x3D; 生成两个独立分类 A 和 B，无层级关系。</li>
</ul>
<h3 id="关键区别总结"><a href="#关键区别总结" class="headerlink" title="关键区别总结"></a><strong>关键区别总结</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>层级嵌套 <code>[A, B]</code></th>
<th>多分类并列 <code>- A</code> + <code>- B</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>分类结构</strong></td>
<td>父子层级（<code>A/B</code>）</td>
<td>独立平级</td>
</tr>
<tr>
<td><strong>文章归属路径</strong></td>
<td>只出现在 <code>A/B</code> 下</td>
<td>同时出现在 <code>A</code> 和 <code>B</code> 下</td>
</tr>
<tr>
<td><strong>语法标志</strong></td>
<td>方括号 <code>[]</code></td>
<td>无方括号，多行 <code>-</code></td>
</tr>
<tr>
<td><strong>典型用途</strong></td>
<td>组织细分内容（如技术栈）</td>
<td>文章跨多个主题</td>
</tr>
</tbody></table>
<hr>
<h3 id="你的案例解析"><a href="#你的案例解析" class="headerlink" title="你的案例解析"></a><strong>你的案例解析</strong></h3><p>你原文中的混合写法：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">Hexo</span>               <span class="comment"># 独立分类</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="string">GitHub</span>, <span class="string">Actions</span>]  <span class="comment"># 嵌套分类（GitHub/Actions）</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">GitHub</span>             <span class="comment"># 独立分类（与嵌套的 GitHub 冲突）</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Actions</span>          <span class="comment"># 语法错误，Hexo 会忽略</span></span><br></pre></td></tr></table></figure>
<p>导致了：</p>
<ol>
<li>独立分类 <code>Hexo</code>。</li>
<li>嵌套分类 <code>GitHub/Actions</code>。</li>
<li>重复的独立分类 <code>GitHub</code>（与嵌套的父分类冲突）。</li>
<li><code>- Actions</code> 因语法错误被忽略。</li>
</ol>
<hr>
<h3 id="正确写法选择"><a href="#正确写法选择" class="headerlink" title="正确写法选择"></a><strong>正确写法选择</strong></h3><p>根据你的需求：</p>
<ul>
<li>如果想将文章归到 <code>Hexo</code> 和 <code>GitHub/Actions</code> 两个分类下：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Hexo</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="string">GitHub</span>, <span class="string">Actions</span>]  <span class="comment"># 明确层级</span></span><br></pre></td></tr></table></figure></li>
<li>如果想归到三个独立分类（不推荐，易混乱）：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">GitHub</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Actions</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Categories</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>HybridCLR 笔记</title>
    <url>/2025/01/13/HybridCLR-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="hybridclr-Package手册"><a href="#hybridclr-Package手册" class="headerlink" title="hybridclr Package手册"></a><a href="https://hybridclr.doc.code-philosophy.com/docs/basic/com.code-philosophy.hybridclr">hybridclr Package手册</a></h2><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><a href="https://hybridclr.doc.code-philosophy.com/docs/basic/bestpractice">最佳实践</a></h2><h2 id="不支持特性"><a href="#不支持特性" class="headerlink" title="不支持特性"></a><a href="https://hybridclr.doc.code-philosophy.com/docs/basic/notsupportedfeatures">不支持特性</a></h2><h2 id="AOT泛型"><a href="#AOT泛型" class="headerlink" title="AOT泛型"></a><a href="https://hybridclr.doc.code-philosophy.com/docs/basic/aotgeneric">AOT泛型</a></h2><h2 id="热更新程序集的-auto-reference"><a href="#热更新程序集的-auto-reference" class="headerlink" title="热更新程序集的 auto reference"></a>热更新程序集的 auto reference</h2><blockquote>
<p>如果你们项目把Assembly-CSharp作为AOT程序集，强烈建议关闭热更新程序集的auto reference选项。因为Assembly-CSharp是最顶层assembly，开启此选项后会自动引用剩余所有assembly，包括热更新程序集，很容易就出现失误引用热更新程序集导致打包失败的情况。</p>
</blockquote>
<p>这段话的核心是提醒开发者避免在 Unity 项目中意外地让 <code>Assembly-CSharp</code>（默认的主程序集）引用到热更新程序集，以防止打包或运行时出现问题。以下是详细解释：</p>
<hr>
<h3 id="1-什么是-auto-reference-选项？"><a href="#1-什么是-auto-reference-选项？" class="headerlink" title="1. 什么是 auto reference 选项？"></a>1. 什么是 <code>auto reference</code> 选项？</h3><ul>
<li>Unity 中的 <code>auto reference</code> 是一个程序集配置选项，控制是否让其他程序集（如 <code>Assembly-CSharp</code>）自动引用当前程序集。</li>
<li>默认情况下，这个选项是 <strong>开启</strong> 的，意味着该程序集会被自动引用，无需手动配置。</li>
</ul>
<hr>
<h3 id="2-Assembly-CSharp-是什么？"><a href="#2-Assembly-CSharp-是什么？" class="headerlink" title="2. Assembly-CSharp 是什么？"></a><strong>2. Assembly-CSharp 是什么？</strong></h3><ul>
<li><code>Assembly-CSharp</code> 是 Unity 项目的主程序集，包含了大部分代码逻辑，是一个 <strong>AOT（Ahead-of-Time）程序集</strong>。</li>
<li>因为 AOT 编译模式在构建时需要提前生成机器代码，所以不能直接加载和运行 JIT（Just-In-Time）模式的热更新程序集。</li>
</ul>
<hr>
<h3 id="3-热更新程序集是什么？"><a href="#3-热更新程序集是什么？" class="headerlink" title="3. 热更新程序集是什么？"></a><strong>3. 热更新程序集是什么？</strong></h3><ul>
<li><strong>热更新程序集</strong>（如 <code>Hotfix.dll</code>）通常是为实现动态更新功能而编写的代码，采用 JIT 模式运行，支持在运行时加载。</li>
<li>它们是 Unity 中独立于 <code>Assembly-CSharp</code> 的额外程序集。</li>
</ul>
<hr>
<h3 id="4-问题的本质"><a href="#4-问题的本质" class="headerlink" title="4. 问题的本质"></a><strong>4. 问题的本质</strong></h3><ul>
<li><code>Assembly-CSharp</code> 自动引用热更新程序集的问题：<ul>
<li><strong>错误引用</strong>：如果 <code>Assembly-CSharp</code> 中的代码错误地依赖了热更新程序集的内容，那么 Unity 打包工具会尝试将热更新程序集内容一起打包到构建结果中。</li>
<li><strong>冲突</strong>：由于热更新程序集需要在运行时加载，而不是在构建时被编译到应用中，错误的引用会导致 <strong>打包失败</strong> 或 <strong>运行时错误</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-为什么建议关闭热更新程序集的-auto-reference？"><a href="#5-为什么建议关闭热更新程序集的-auto-reference？" class="headerlink" title="5. 为什么建议关闭热更新程序集的 auto reference？"></a>5. 为什么建议关闭热更新程序集的 <code>auto reference</code>？</h3><ul>
<li><p><strong>关闭后效果</strong>：</p>
<ul>
<li>防止 Unity 自动将热更新程序集添加为 <code>Assembly-CSharp</code> 的依赖项。</li>
<li>强制开发者在代码中显式引用热更新程序集，避免误用。</li>
</ul>
</li>
<li><p><strong>示例问题</strong>：</p>
<ul>
<li>假如你在 <code>Assembly-CSharp</code> 中调用了热更新程序集中的方法（例如 <code>Hotfix.SomeMethod()</code>），Unity 会尝试将 <code>Hotfix.dll</code> 包含到主程序集的依赖中。</li>
<li>这种错误的引用可能导致：<ul>
<li>打包失败（热更新程序集不支持 AOT 编译）。</li>
<li>热更新失效（运行时无法正确加载动态程序集）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-如何关闭-auto-reference？"><a href="#6-如何关闭-auto-reference？" class="headerlink" title="6. 如何关闭 auto reference？"></a>6. 如何关闭 <code>auto reference</code>？</h3><p>在 Unity 项目的 <code>Assembly Definition File (.asmdef)</code> 中，关闭 <code>auto reference</code> 选项：</p>
<ol>
<li>找到热更新程序集的 <code>.asmdef</code> 文件。</li>
<li>打开并编辑该文件。</li>
<li>确保以下选项关闭：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;autoReferenced&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br></pre></td></tr></table></figure></li>
<li>保存更改，重新编译项目。</li>
</ol>
<hr>
<h3 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项"></a><strong>7. 注意事项</strong></h3><ul>
<li><p><strong>依赖管理</strong>：</p>
<ul>
<li>关闭 <code>auto reference</code> 后，如果 <code>Assembly-CSharp</code> 需要访问热更新程序集中的代码，你需要手动在 <code>Assembly Definition References</code> 中显式引用。</li>
<li>推荐将热更新逻辑和主逻辑隔离，避免 <code>Assembly-CSharp</code> 直接依赖热更新程序集。</li>
</ul>
</li>
<li><p><strong>模块化设计</strong>：</p>
<ul>
<li>将热更新逻辑放在独立的命名空间和文件夹下，确保开发过程中不会意外引用。</li>
</ul>
</li>
<li><p><strong>打包验证</strong>：</p>
<ul>
<li>在打包前，检查主程序集是否存在对热更新程序集的依赖，确保热更新功能可以正常运行。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>这段建议的目的是防止主程序集 <code>Assembly-CSharp</code> 中误引用热更新程序集，避免因为编译模式冲突（AOT 和 JIT）导致打包失败或运行时问题。关闭热更新程序集的 <code>auto reference</code> 可以帮助你更好地控制依赖关系，避免无意的错误引用。</p>
<h2 id="Assembly-CSharp-程序集"><a href="#Assembly-CSharp-程序集" class="headerlink" title="Assembly-CSharp 程序集"></a>Assembly-CSharp 程序集</h2><p><strong><code>Assembly-CSharp</code></strong> 是 Unity 项目的主程序集，通常是 Unity 的默认代码文件（例如 <code>Assets</code> 文件夹中的脚本）编译后生成的程序集。如果你的项目中仍然依赖它，**通常不能删除 <code>Assembly-CSharp</code>**，但可以通过以下方式避免直接使用它或完全移除它：</p>
<hr>
<h3 id="1-Assembly-CSharp-的作用"><a href="#1-Assembly-CSharp-的作用" class="headerlink" title="1. Assembly-CSharp 的作用"></a><strong>1. Assembly-CSharp 的作用</strong></h3><ul>
<li><strong>默认代码程序集</strong>：Unity 会将 <code>Assets</code> 文件夹中不属于任何自定义 Assembly Definition（<code>*.asmdef</code>）文件的代码编译到 <code>Assembly-CSharp</code> 中。</li>
<li><strong>主逻辑存储</strong>：如果你没有使用自定义 <code>asmdef</code> 文件，<code>Assembly-CSharp</code> 会包含你的大部分业务逻辑。</li>
</ul>
<hr>
<h3 id="2-什么时候可以删除-Assembly-CSharp？"><a href="#2-什么时候可以删除-Assembly-CSharp？" class="headerlink" title="2. 什么时候可以删除 Assembly-CSharp？"></a><strong>2. 什么时候可以删除 <code>Assembly-CSharp</code>？</strong></h3><p>你可以通过以下步骤实现移除 <code>Assembly-CSharp</code>：</p>
<p> <strong>方法 1：全部使用 Assembly Definition</strong></p>
<ol>
<li><p><strong>创建自定义程序集</strong>：</p>
<ul>
<li>在项目中为所有代码文件创建 <code>*.asmdef</code> 文件，分离每个模块或子系统。</li>
<li>每个 <code>*.asmdef</code> 文件会生成一个独立的程序集。</li>
</ul>
</li>
<li><p><strong>移动脚本到自定义程序集</strong>：</p>
<ul>
<li>将项目中的所有脚本文件移动到有 <code>*.asmdef</code> 文件的目录下。</li>
<li>确保所有代码都属于自定义程序集。</li>
</ul>
</li>
<li><p><strong>验证引用关系</strong>：</p>
<ul>
<li>检查 <code>*.asmdef</code> 文件的依赖关系，确保模块之间的依赖正确配置。</li>
</ul>
</li>
<li><p><strong>删除 Assembly-CSharp</strong>：</p>
<ul>
<li>如果 <code>Assets</code> 根目录下没有脚本文件，Unity 将不会生成 <code>Assembly-CSharp</code>，从而实现移除。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-为什么通常不建议删除？"><a href="#3-为什么通常不建议删除？" class="headerlink" title="3. 为什么通常不建议删除？"></a><strong>3. 为什么通常不建议删除？</strong></h3><p> <strong>性能影响</strong>：</p>
<ul>
<li><strong>额外开销</strong>：使用多个自定义程序集（<code>*.asmdef</code> 文件）可能增加编译时间，尤其是小型项目中，直接使用 <code>Assembly-CSharp</code> 会更简单且高效。</li>
</ul>
<p> <strong>兼容性问题</strong>：</p>
<ul>
<li><strong>第三方插件</strong>：许多第三方插件默认使用 <code>Assembly-CSharp</code>，完全移除可能需要对这些插件做大量修改。</li>
</ul>
<p> <strong>维护成本</strong>：</p>
<ul>
<li><strong>依赖管理复杂</strong>：多个 <code>*.asmdef</code> 文件增加了项目的复杂性，尤其是在多人协作时，可能会引入额外的依赖管理问题。</li>
</ul>
<hr>
<h3 id="4-推荐的实践"><a href="#4-推荐的实践" class="headerlink" title="4. 推荐的实践"></a><strong>4. 推荐的实践</strong></h3><p> <strong>小型项目</strong></p>
<ul>
<li>保留 <code>Assembly-CSharp</code>，只需确保代码组织清晰即可。</li>
<li>如果需要动态加载或热更新，将热更新逻辑移到单独的程序集。</li>
</ul>
<p> <strong>中大型项目</strong></p>
<ul>
<li><p>使用 <code>*.asmdef</code> 文件分离模块：</p>
<ul>
<li>核心模块（例如网络、UI、热更新）使用独立程序集。</li>
<li>非核心逻辑可以保留在 <code>Assembly-CSharp</code> 中，逐步迁移。</li>
</ul>
</li>
<li><p>最终目标：移除 <code>Assembly-CSharp</code> 或只保留最基本的功能代码。</p>
</li>
</ul>
<hr>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><ul>
<li><strong>可以删除</strong>：只要你通过 <code>*.asmdef</code> 文件将所有脚本移动到自定义程序集，就可以完全移除 <code>Assembly-CSharp</code>。</li>
<li><strong>不建议删除</strong>：对于简单或中等规模的项目，保留 <code>Assembly-CSharp</code> 可以减少管理复杂性。</li>
<li><strong>推荐方案</strong>：逐步将核心模块从 <code>Assembly-CSharp</code> 中剥离，通过自定义程序集实现模块化管理，但无需过度追求完全移除。</li>
</ul>
<h2 id="Scripting-Backend-IL2CPP"><a href="#Scripting-Backend-IL2CPP" class="headerlink" title="Scripting Backend -&gt; IL2CPP"></a>Scripting Backend -&gt; IL2CPP</h2><p>在使用 <strong>HybridCLR</strong> 进行热更新时，构建项目时将 <strong>Scripting Backend</strong> 切换为 <strong>IL2CPP</strong> 是出于以下原因：</p>
<hr>
<h3 id="1-IL2CPP-的作用"><a href="#1-IL2CPP-的作用" class="headerlink" title="1. IL2CPP 的作用"></a><strong>1. IL2CPP 的作用</strong></h3><ul>
<li><strong>IL2CPP（Intermediate Language To C++）</strong> 是 Unity 提供的一种脚本编译方式，用于将 C# 脚本的 IL 代码转换为 C++ 代码，再通过平台的原生编译器（如 Clang）生成机器代码。</li>
<li><strong>AOT（Ahead-Of-Time）编译</strong> 是 IL2CPP 的核心特点，它会提前将代码编译为目标平台的二进制代码，而不是像 Mono 那样依赖 JIT（Just-In-Time）编译。</li>
</ul>
<hr>
<h3 id="2-为什么要使用-IL2CPP"><a href="#2-为什么要使用-IL2CPP" class="headerlink" title="2. 为什么要使用 IL2CPP"></a><strong>2. 为什么要使用 IL2CPP</strong></h3><p> <strong>支持 AOT 和热更新并存</strong><br>HybridCLR 的核心是实现 AOT 和 JIT 的混合运行：</p>
<ul>
<li><strong>AOT 部分</strong>：IL2CPP 编译器会提前将 Assembly-CSharp 等固定程序集编译为二进制代码（.so、.dll 等），确保性能和稳定性。</li>
<li><strong>JIT 部分</strong>：HybridCLR 允许运行时加载和执行动态热更新程序集（如 <code>Hotfix.dll</code>），这些代码在运行时解析并执行 IL 指令。</li>
</ul>
<p> <strong>解决 Mono 的限制</strong></p>
<ul>
<li>Mono 支持 JIT，但在移动平台（如 Android 和 iOS）上只能运行 AOT 编译的代码，不支持动态加载新程序集。</li>
<li>IL2CPP 提供更高效、更安全的运行时环境，同时通过 HybridCLR 增加了对 JIT 的支持，突破了 IL2CPP 默认不支持动态程序集的限制。</li>
</ul>
<p> <strong>性能和安全性</strong></p>
<ul>
<li>IL2CPP 的运行效率比 Mono 更高，因为其生成的 C++ 代码经过了更优化的原生编译器处理。</li>
<li>更高的安全性：IL2CPP 将 C# 代码转换为本地机器码，反编译难度更高，适合发布对安全性要求高的项目（如手游）。</li>
</ul>
<hr>
<h3 id="3-IL2CPP-与-HybridCLR-的协作"><a href="#3-IL2CPP-与-HybridCLR-的协作" class="headerlink" title="3. IL2CPP 与 HybridCLR 的协作"></a><strong>3. IL2CPP 与 HybridCLR 的协作</strong></h3><p>HybridCLR 的热更新方案依赖 IL2CPP 的 AOT 特性，同时扩展了 IL2CPP 的功能：</p>
<ol>
<li><p><strong>AOT 编译的主程序集</strong>：</p>
<ul>
<li>Unity 的默认程序集（如 <code>Assembly-CSharp</code>）和一些基础库通过 IL2CPP 编译为机器代码，保证核心功能的高性能和稳定性。</li>
</ul>
</li>
<li><p><strong>JIT 执行的热更新程序集</strong>：</p>
<ul>
<li>HybridCLR 在运行时加载未编译的 IL 指令（如热更新 DLL），并在托管环境中解析和执行这些指令。</li>
<li>HybridCLR 会接管 IL2CPP 的一些功能（如 IL 解释器），实现动态程序集的加载和执行。</li>
</ul>
</li>
<li><p><strong>自动生成桥接代码</strong>：</p>
<ul>
<li>HybridCLR 通过生成元数据和补丁，解决 AOT 和 JIT 混合模式下的调用问题，确保热更新逻辑可以无缝调用 AOT 编译的代码。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h3><p>将 <strong>Scripting Backend</strong> 切换为 <strong>IL2CPP</strong> 是 HybridCLR 的一个核心需求，原因包括：</p>
<ol>
<li><strong>支持 AOT 模式</strong>，提供高性能和跨平台兼容性。</li>
<li><strong>增强安全性</strong>，通过机器代码降低反编译的可能性。</li>
<li><strong>兼容性要求</strong>，Mono 不支持动态热更新程序集的加载，而 IL2CPP 在 HybridCLR 的扩展下支持这一功能。</li>
</ol>
<p>因此，在 HybridCLR 构建过程中，切换到 <strong>IL2CPP</strong> 是实现热更新功能的必要步骤，同时也能保证项目的运行效率和安全性。</p>
<h2 id="Api-Compatibility-Level-NET-Framework"><a href="#Api-Compatibility-Level-NET-Framework" class="headerlink" title="Api Compatibility Level -&gt; .NET Framework"></a>Api Compatibility Level -&gt; .NET Framework</h2><p>在使用 <strong>HybridCLR</strong> 或实现热更新时，通常需要将 <strong>Api Compatibility Level</strong> 切换为 <strong>.NET 4.x</strong>（Unity 2019-2020）或 <strong>.NET Framework</strong>（Unity 2021+）。这是因为：</p>
<hr>
<h3 id="1-API-Compatibility-Level-的作用"><a href="#1-API-Compatibility-Level-的作用" class="headerlink" title="1. API Compatibility Level 的作用"></a><strong>1. API Compatibility Level 的作用</strong></h3><ul>
<li><strong>定义了 Unity 项目的运行时 API 集合版本</strong>，控制了 C# 语言功能、类库功能以及第三方依赖支持的范围。</li>
<li>Unity 提供两种主要的 API Compatibility Level：<ol>
<li><strong>.NET Standard 2.0</strong>：一种跨平台的精简子集，支持最基本的 .NET API。</li>
<li><strong>.NET 4.x（或 .NET Framework in Unity 2021+）</strong>：包含更全面的 .NET API，支持更多高级特性和库。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-为什么要选择-NET-4-x-或-NET-Framework"><a href="#2-为什么要选择-NET-4-x-或-NET-Framework" class="headerlink" title="2. 为什么要选择 .NET 4.x 或 .NET Framework"></a><strong>2. 为什么要选择 .NET 4.x 或 .NET Framework</strong></h3><p> <strong>更广泛的 API 支持</strong></p>
<ul>
<li><strong>.NET Standard 2.0 的限制</strong>：精简版 API 会导致许多常用的 .NET 类库无法使用（例如部分反射功能、泛型类型扩展等）。</li>
<li><strong>.NET 4.x 的优势</strong>：提供完整的 .NET Framework 功能，如高级的反射机制、动态加载程序集、<code>System.IO</code> 等功能模块。</li>
<li>HybridCLR 需要在运行时加载和执行热更新的 DLL，通常需要依赖 <strong>完整反射功能</strong> 和其他高级特性，因此需要更高版本的 API 支持。</li>
</ul>
<p> <strong>兼容性与功能性</strong></p>
<ul>
<li>热更新逻辑中，动态加载的 DLL 可能会依赖于完整的 .NET Framework API。</li>
<li>HybridCLR 和许多第三方插件（如 Json.NET、各种 ORM 框架）也往往依赖于 .NET 4.x 的特性。</li>
</ul>
<p> <strong>编译支持</strong></p>
<ul>
<li>.NET 4.x 可以更好地支持现代 C# 语言特性（如异步流、元组、多模式匹配等），使开发和维护更加便捷。</li>
<li>对于 Unity 项目中的热更新模块，切换到 .NET 4.x 可以减少潜在的兼容性问题。</li>
</ul>
<hr>
<h3 id="3-Unity-版本的变化"><a href="#3-Unity-版本的变化" class="headerlink" title="3. Unity 版本的变化"></a><strong>3. Unity 版本的变化</strong></h3><ul>
<li><strong>Unity 2019-2020</strong>：仍然将 .NET 4.x 和 .NET Standard 2.0 并列提供。</li>
<li>**Unity 2021+**：将 <strong>.NET Framework</strong>（等效于 .NET 4.x）替代了 .NET Standard 2.0，成为推荐选项。</li>
</ul>
<blockquote>
<p>Unity 2021 起，Unity 逐步向 <strong>.NET Core&#x2F;.NET 5</strong> 方向迁移，因此 API 层级有所变化。</p>
</blockquote>
<hr>
<h3 id="4-为什么不选择-NET-Standard-2-0？"><a href="#4-为什么不选择-NET-Standard-2-0？" class="headerlink" title="4. 为什么不选择 .NET Standard 2.0？"></a><strong>4. 为什么不选择 .NET Standard 2.0？</strong></h3><p> <strong>功能不足</strong></p>
<ul>
<li><strong>限制反射功能</strong>：<code>System.Reflection.Emit</code> 等特性在 .NET Standard 2.0 中受到限制。</li>
<li><strong>API 缺失</strong>：许多成熟的类库（如高级的 LINQ 查询、数据操作库）需要 .NET 4.x 的支持。</li>
</ul>
<p> <strong>第三方依赖问题</strong></p>
<ul>
<li>许多第三方库没有完全支持 .NET Standard 2.0，而是为 .NET Framework 或更高版本设计。</li>
</ul>
<p> <strong>不适合热更新</strong></p>
<ul>
<li>热更新需要动态加载和解释运行程序集（DLL），这对反射、动态类型支持、程序集加载有较高要求，.NET Standard 2.0 无法满足。</li>
</ul>
<hr>
<h3 id="5-如何切换-API-Compatibility-Level"><a href="#5-如何切换-API-Compatibility-Level" class="headerlink" title="5. 如何切换 API Compatibility Level"></a><strong>5. 如何切换 API Compatibility Level</strong></h3><p> <strong>Unity 2019-2020</strong></p>
<ol>
<li>打开 <strong>Edit &gt; Project Settings &gt; Player &gt; Other Settings</strong>。</li>
<li>找到 <strong>Api Compatibility Level</strong>。</li>
<li>选择 <strong>.NET 4.x</strong>。</li>
</ol>
<p> <strong>Unity 2021+</strong></p>
<ol>
<li>同样在 <strong>Player &gt; Other Settings</strong>。</li>
<li>将 <strong>Api Compatibility Level</strong> 切换为 <strong>.NET Framework</strong>。</li>
</ol>
<hr>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h3><p>将 <strong>Api Compatibility Level</strong> 切换为 <strong>.NET 4.x</strong>（或 Unity 2021+ 中的 <strong>.NET Framework</strong>）的原因：</p>
<ol>
<li><strong>支持更丰富的 .NET API</strong>，如高级反射、动态加载等功能，满足热更新需求。</li>
<li><strong>提高兼容性</strong>，使项目能够使用现代 C# 特性及第三方类库。</li>
<li><strong>解决热更新的技术需求</strong>，尤其是在 HybridCLR 或其他动态加载框架中。</li>
</ol>
<blockquote>
<p>如果你的项目使用热更新，或者依赖于复杂的第三方库，这是必要的一步。</p>
</blockquote>
<h2 id="C-Compiler-Configuration-Debug"><a href="#C-Compiler-Configuration-Debug" class="headerlink" title="C++ Compiler Configuration: Debug"></a>C++ Compiler Configuration: Debug</h2><p><strong>C++ Compiler Configuration: Debug</strong> 是一个配置选项，通常出现在项目的编译环境设置中（如 Unity、Visual Studio 或其他开发工具）。它的作用是指定 <strong>C++ 编译器的调试配置</strong>，用于生成方便调试的二进制文件。以下是关于这个配置的详细解释：</p>
<hr>
<h3 id="1-Debug-配置的主要用途"><a href="#1-Debug-配置的主要用途" class="headerlink" title="1. Debug 配置的主要用途"></a><strong>1. Debug 配置的主要用途</strong></h3><ul>
<li><strong>调试优化</strong>：生成的二进制文件包含调试符号，允许你在调试器（如 Visual Studio 或 Unity Profiler）中查看变量值、调用栈和程序执行流。</li>
<li><strong>更低的优化级别</strong>：为了方便调试，编译器会降低或禁用某些代码优化，这使得生成的代码结构更接近源代码。</li>
<li><strong>额外信息嵌入</strong>：会嵌入调试信息，例如源文件的路径、行号和符号表，以便与调试器协同工作。</li>
</ul>
<hr>
<h3 id="2-Debug-与-Release-的区别"><a href="#2-Debug-与-Release-的区别" class="headerlink" title="2. Debug 与 Release 的区别"></a><strong>2. Debug 与 Release 的区别</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>Debug 配置</th>
<th>Release 配置</th>
</tr>
</thead>
<tbody><tr>
<td><strong>优化级别</strong></td>
<td>较低或无优化，保留完整源代码结构</td>
<td>高度优化，删除无用代码</td>
</tr>
<tr>
<td><strong>调试符号</strong></td>
<td>包含完整调试符号</td>
<td>通常不包含调试符号</td>
</tr>
<tr>
<td><strong>运行时性能</strong></td>
<td>较低（因优化级别低）</td>
<td>高效（因高度优化）</td>
</tr>
<tr>
<td><strong>文件大小</strong></td>
<td>较大（包含调试信息和未优化代码）</td>
<td>较小</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>开发和调试阶段</td>
<td>产品发布阶段</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-在-Unity-中的应用"><a href="#3-在-Unity-中的应用" class="headerlink" title="3. 在 Unity 中的应用"></a><strong>3. 在 Unity 中的应用</strong></h3><p>在 Unity 项目中，使用 <strong>C++ Compiler Configuration: Debug</strong> 的场景通常与底层插件开发或 IL2CPP 编译有关。</p>
<p> <strong>IL2CPP 和 Debug 配置</strong></p>
<ul>
<li><strong>IL2CPP</strong>（Intermediate Language to C++）：Unity 会将 C# 脚本转译为中间语言（IL），然后通过 IL2CPP 转换为 C++ 代码，最后编译为目标平台的二进制文件。</li>
<li>当你选择 Debug 配置时，Unity 会为生成的 C++ 代码启用调试符号，从而更容易在开发工具中调试底层代码。</li>
</ul>
<hr>
<h3 id="4-配置-Debug-的好处"><a href="#4-配置-Debug-的好处" class="headerlink" title="4. 配置 Debug 的好处"></a><strong>4. 配置 Debug 的好处</strong></h3><ol>
<li><strong>调试能力增强</strong>：<ul>
<li>能够设置断点、逐步执行代码，排查运行时问题。</li>
<li>支持查看复杂数据结构、对象状态。</li>
</ul>
</li>
<li><strong>快速发现问题</strong>：<ul>
<li>错误信息更准确（例如指向具体的源代码行）。</li>
<li>更容易重现和分析程序中的崩溃或异常。</li>
</ul>
</li>
<li><strong>适合开发阶段</strong>：<ul>
<li>调试配置允许开发人员专注于功能的正确性，而不必担心性能问题。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-配置-Debug-的缺点"><a href="#5-配置-Debug-的缺点" class="headerlink" title="5. 配置 Debug 的缺点"></a><strong>5. 配置 Debug 的缺点</strong></h3><ol>
<li><strong>性能较低</strong>：由于禁用了某些优化，运行速度可能明显慢于 Release 配置。</li>
<li><strong>文件较大</strong>：包含调试符号和未优化的代码，生成的文件体积较大。</li>
<li><strong>发布不可用</strong>：Debug 配置的二进制文件通常不适合作为最终产品发布。</li>
</ol>
<hr>
<h3 id="6-如何切换到-Debug-配置"><a href="#6-如何切换到-Debug-配置" class="headerlink" title="6. 如何切换到 Debug 配置"></a><strong>6. 如何切换到 Debug 配置</strong></h3><p> <strong>在 Unity 中</strong></p>
<ol>
<li><strong>编辑器设置</strong>：<ul>
<li>打开 <strong>Edit &gt; Preferences &gt; External Tools</strong>。</li>
<li>在 <strong>C++ Compiler Configuration</strong> 中选择 <strong>Debug</strong>。</li>
</ul>
</li>
<li><strong>Build Settings</strong>：<ul>
<li>在 Unity 的 <strong>Build Settings</strong> 中选择 <strong>Development Build</strong>，会启用调试模式。</li>
</ul>
</li>
</ol>
<p> <strong>在 Visual Studio 或其他工具中</strong></p>
<ol>
<li>在解决方案配置中，选择 <strong>Debug</strong> 配置。</li>
<li>检查编译器选项，确保启用了调试符号（如 <code>/DEBUG</code> 标志）。</li>
</ol>
<hr>
<h3 id="7-适用场景"><a href="#7-适用场景" class="headerlink" title="7. 适用场景"></a><strong>7. 适用场景</strong></h3><ul>
<li><strong>开发和调试阶段</strong>：需要验证逻辑、排查 Bug 或分析运行时问题。</li>
<li><strong>测试复杂逻辑</strong>：如自定义 Native 插件、复杂算法或与平台相关的代码。</li>
<li><strong>集成第三方库</strong>：调试与第三方库的交互问题。</li>
</ul>
<hr>
<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a><strong>8. 总结</strong></h3><p><strong>C++ Compiler Configuration: Debug</strong> 是为开发和调试阶段准备的编译配置，提供了强大的调试能力，但牺牲了一定的性能和文件体积。它适合在项目开发阶段使用，而最终发布阶段应该切换到 <strong>Release 配置</strong> 以获得最佳的性能和较小的文件体积。</p>
<h2 id="Use-Incremental-GC-true"><a href="#Use-Incremental-GC-true" class="headerlink" title="Use Incremental GC: true"></a>Use Incremental GC: true</h2><p><strong>Use Incremental GC: true</strong> 是 Unity 中的一项配置，用于启用 <strong>增量垃圾回收（Incremental Garbage Collection）</strong>，以改善游戏运行时的性能表现，特别是在内存管理方面。</p>
<hr>
<h3 id="1-什么是垃圾回收（Garbage-Collection-GC）？"><a href="#1-什么是垃圾回收（Garbage-Collection-GC）？" class="headerlink" title="1. 什么是垃圾回收（Garbage Collection, GC）？"></a><strong>1. 什么是垃圾回收（Garbage Collection, GC）？</strong></h3><p>垃圾回收是 Unity（和许多其他运行时环境）用来自动管理内存的一种机制。它会回收那些不再被引用的对象所占用的内存，从而避免内存泄漏。然而，传统的垃圾回收机制可能会导致性能问题：</p>
<ul>
<li><strong>传统 GC</strong> 是全暂停式的（Stop-the-World）：当垃圾回收运行时，游戏的所有逻辑都会暂停，直到回收完成。</li>
<li>如果内存分配量较大或对象复杂，可能会导致显著的帧率下降（卡顿）。</li>
</ul>
<hr>
<h3 id="2-增量垃圾回收（Incremental-GC）"><a href="#2-增量垃圾回收（Incremental-GC）" class="headerlink" title="2. 增量垃圾回收（Incremental GC）"></a><strong>2. 增量垃圾回收（Incremental GC）</strong></h3><p>增量垃圾回收是传统垃圾回收的优化版本，它将回收工作分为多个小的步骤，而不是一次性完成。这些步骤分散在多帧中执行，从而避免了长时间的暂停。</p>
<p> <strong>工作原理</strong>：</p>
<ul>
<li>将垃圾回收的工作拆分成更小的任务块。</li>
<li>在每一帧中执行一部分任务，而不是整个回收过程。</li>
<li>减少垃圾回收对帧率的影响，提高游戏的流畅性。</li>
</ul>
<hr>
<h3 id="3-启用-Use-Incremental-GC-的好处"><a href="#3-启用-Use-Incremental-GC-的好处" class="headerlink" title="3. 启用 Use Incremental GC 的好处"></a><strong>3. 启用 Use Incremental GC 的好处</strong></h3><ol>
<li><strong>减少卡顿</strong>：<ul>
<li>垃圾回收不再集中发生，暂停时间减少，帧率更加稳定。</li>
</ul>
</li>
<li><strong>适合大型项目</strong>：<ul>
<li>对于使用大量动态对象或频繁分配内存的项目（如开放世界、模拟类游戏），增量垃圾回收更能提升用户体验。</li>
</ul>
</li>
<li><strong>平滑性能</strong>：<ul>
<li>提高低端设备上的性能表现，避免内存回收造成的长时间卡顿。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a><strong>4. 使用场景</strong></h3><ul>
<li><strong>大型游戏</strong>：如开放世界游戏、大型多人在线游戏。</li>
<li><strong>频繁内存分配的项目</strong>：如实时生成内容的游戏、动态创建 UI 元素的应用。</li>
<li><strong>目标平台是移动设备</strong>：尤其是低端设备，对性能敏感时，启用增量垃圾回收可以改善运行表现。</li>
</ul>
<hr>
<h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a><strong>5. 注意事项</strong></h3><ol>
<li><strong>增量垃圾回收不是万能的</strong>：<ul>
<li>虽然它减少了暂停时间，但回收总时间可能会比传统 GC 更长（因为回收被分摊到了多帧中）。</li>
</ul>
</li>
<li><strong>可能引入额外的性能开销</strong>：<ul>
<li>如果项目本身对 GC 依赖较少，可能无法显著受益。</li>
</ul>
</li>
<li><strong>需要配合优化内存分配</strong>：<ul>
<li>减少大对象分配和频繁分配内存的操作，仍是优化性能的关键。</li>
</ul>
</li>
<li><strong>与某些功能冲突</strong>：<ul>
<li>某些 Unity 功能或插件可能对增量 GC 的行为不兼容，需测试。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="6-如何启用-Incremental-GC"><a href="#6-如何启用-Incremental-GC" class="headerlink" title="6. 如何启用 Incremental GC"></a><strong>6. 如何启用 Incremental GC</strong></h3><p> 在 Unity 编辑器中：</p>
<ol>
<li>打开 <strong>Edit &gt; Project Settings &gt; Player</strong>。</li>
<li>找到 <strong>Other Settings</strong>。</li>
<li>勾选 <strong>Use Incremental GC</strong>。</li>
</ol>
<p> 代码中检测增量 GC：<br>你可以在代码中检查或设置是否启用了增量垃圾回收：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Debug.Log(<span class="string">$&quot;Incremental GC Enabled: <span class="subst">&#123;UnityEngine.Scripting.GarbageCollector.isIncremental&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h3><p>启用 <strong>Incremental GC</strong> 是一种平衡性能和垃圾回收开销的解决方案，特别适用于复杂和内存密集型的游戏场景。它减少了游戏中因垃圾回收导致的明显卡顿，提升了玩家体验。不过，要确保你的项目确实需要它，并在启用后测试性能表现，以避免引入不必要的额外开销。</p>
<h2 id="不支持的特性"><a href="#不支持的特性" class="headerlink" title="不支持的特性"></a><a href="https://hybridclr.doc.code-philosophy.com/docs/basic/notsupportedfeatures">不支持的特性</a></h2><h2 id="代码裁剪"><a href="#代码裁剪" class="headerlink" title="代码裁剪"></a>代码裁剪</h2><blockquote>
<p>问题：<br>由于上一次的代码中完全没有用到例如GameObject，导致GameObject类型的部分函数在打包时被裁剪。（这只是个假设，目前GameObject是不会被裁剪掉的，但是其他非核心代码会存在这个问题）</p>
</blockquote>
<blockquote>
<p>解决方案：<br>HybridCLR&#x2F;Generate&#x2F;All命令会重新扫描热更新程序集，生成link.xml以保留热更新代码中用到的类型。请运行完该命令后重新构建一次新包，否则运行下一步的热更新代码时会出现GameObject::.ctor函数找不到的错误。</p>
</blockquote>
<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>在 Unity 中，<strong>代码裁剪</strong> 是指通过 IL2CPP 或 Mono 的 <code>Managed Stripping Level</code> 设置，在构建过程中剔除未使用的代码和类型，以减小包体积。然而，这种优化可能会错误地移除在代码中未直接引用的类型或成员，但它们可能通过反射或其他动态调用方式在运行时需要使用。</p>
<p>你提到的问题是：</p>
<ol>
<li>未使用 <code>GameObject</code> 类的代码路径被裁剪：由于在热更新程序集（通常是指通过 HybridCLR 等热更新解决方案的管理代码）中没有显式引用 <code>GameObject</code> 类型及其构造函数，Unity 在打包过程中将其裁剪。</li>
<li><strong>热更新运行时报错</strong>：当热更新逻辑试图动态创建 <code>GameObject</code>（例如调用 <code>new GameObject()</code>）时，会抛出 <code>GameObject::.ctor</code> 找不到的错误。</li>
</ol>
<p>为了解决这个问题，HybridCLR 提供了一种方式来扫描热更新程序集并生成 <code>link.xml</code> 文件，该文件用于显式声明哪些类型或成员需要保留，防止被裁剪。</p>
<hr>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>以下是对 HybridCLR 解决方案以及相关步骤的详细讲解：</p>
<h4 id="1-HybridCLR-Generate-All-命令"><a href="#1-HybridCLR-Generate-All-命令" class="headerlink" title="1. HybridCLR&#x2F;Generate&#x2F;All 命令"></a>1. <strong>HybridCLR&#x2F;Generate&#x2F;All 命令</strong></h4><p>此命令的作用是扫描你的热更新程序集，分析代码中动态使用的类型和成员，生成一个 <code>link.xml</code> 文件。<br><code>link.xml</code> 是 Unity 提供的一个配置文件，用于手动指定哪些类型或成员需要在裁剪过程中保留。</p>
<ul>
<li><strong>HybridCLR 特性</strong>：它可以更智能地分析热更新程序集，自动添加需要的类型。</li>
<li><strong>生成后的内容</strong>：<code>link.xml</code> 会包含类似以下内容：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">linker</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">&quot;UnityEngine&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">&quot;UnityEngine.GameObject&quot;</span> <span class="attr">preserve</span>=<span class="string">&quot;all&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">linker</span>&gt;</span></span><br></pre></td></tr></table></figure>
这表明 <code>GameObject</code> 类型及其所有成员都不会被裁剪。</li>
</ul>
<h4 id="2-重新构建包"><a href="#2-重新构建包" class="headerlink" title="2. 重新构建包"></a>2. <strong>重新构建包</strong></h4><p>生成 <code>link.xml</code> 后，重新构建一次项目：</p>
<ul>
<li>构建的过程会读取 <code>link.xml</code> 文件，确保裁剪器不会移除你在热更新代码中需要的类型和方法。</li>
<li>如果不重新构建，旧包中依然会存在被裁剪的问题。</li>
</ul>
<h4 id="3-动态调用的类型声明"><a href="#3-动态调用的类型声明" class="headerlink" title="3. 动态调用的类型声明"></a>3. <strong>动态调用的类型声明</strong></h4><p>即使你的代码没有直接使用 <code>GameObject</code>，比如通过反射或字符串名称创建实例（<code>Activator.CreateInstance(&quot;GameObject&quot;)</code>），<code>link.xml</code> 也能确保这些动态调用所需的类型不会被移除。</p>
<hr>
<h3 id="运行步骤"><a href="#运行步骤" class="headerlink" title="运行步骤"></a>运行步骤</h3><ol>
<li>确保你的热更新代码中显式或隐式引用了需要保留的类型。例如：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> GameObject(); <span class="comment">// 确保 GameObject 被显式使用</span></span><br></pre></td></tr></table></figure></li>
<li>运行 <code>HybridCLR/Generate/All</code>：<ul>
<li>打开 Unity 菜单：<code>HybridCLR</code> &gt; <code>Generate</code> &gt; <code>All</code>。</li>
<li>等待生成完成。</li>
</ul>
</li>
<li>检查生成的 <code>link.xml</code> 文件：<ul>
<li>路径通常位于 <code>Assets/HybridCLR/Linker/link.xml</code>。</li>
<li>确认文件中包含类似以下内容：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">&quot;UnityEngine.GameObject&quot;</span> <span class="attr">preserve</span>=<span class="string">&quot;all&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>构建新包：<ul>
<li>通过 <code>File</code> &gt; <code>Build Settings</code> &gt; <code>Build</code> 或者运行构建脚本，生成新的包。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ol>
<li><p><strong>动态调用的预防措施</strong>：<br>如果你的热更新代码通过反射、字符串或其他方式调用 <code>GameObject</code>，需要确保这些类型明确添加到 <code>link.xml</code>，否则仍然可能被裁剪。</p>
</li>
<li><p><strong>测试热更新逻辑</strong>：<br>在构建包后，测试是否能正确运行热更新逻辑。建议在开发模式下运行热更新代码进行验证。</p>
</li>
<li><p><strong>裁剪级别设置</strong>：<br>如果你不希望裁剪器过于激进，可以降低 <code>Managed Stripping Level</code> 设置：</p>
<ul>
<li>路径：<code>Edit</code> &gt; <code>Project Settings</code> &gt; <code>Player</code> &gt; <code>Other Settings</code> &gt; <code>Managed Stripping Level</code>。</li>
<li>设置为 <code>Low</code>，确保更多类型保留。</li>
</ul>
</li>
</ol>
<p>通过这些步骤，你可以有效避免热更新中 <code>GameObject</code> 类型丢失的问题。</p>
<h3 id="代码裁剪相关问题"><a href="#代码裁剪相关问题" class="headerlink" title="代码裁剪相关问题"></a>代码裁剪相关问题</h3><p>Unity使用了代码裁剪技术来帮助减少il2cpp backend的包体大小。如果未做防裁剪处理，由于AOT主工程里的代码一般不多，大量的C#类型和函数被 裁剪，导致热更新中调用这些被裁剪类或函数出现如下异常：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型缺失错误</span></span><br><span class="line">Unity: TypeLoadException: Could <span class="keyword">not</span> load type <span class="string">&#x27;Xxx&#x27;</span> <span class="keyword">from</span> assembly <span class="string">&#x27;yyy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数缺失错误</span></span><br><span class="line">MissingMethodException: xxxx</span><br></pre></td></tr></table></figure>
<p>解决办法:</p>
<blockquote>
<p>根据日志错误日志确定哪个类型或函数被裁减，在link.xml里保留这个类型或函数，或者在主工程里显式地加上对这些类或函数的调用。 如果不熟悉如何在link.xml保留这个类型或函数，请参阅代码裁剪。</p>
</blockquote>
<p>但这种办法终究很麻烦，实际项目中有大量被裁剪的类型，你一遍遍地进行”打包-类型缺失-补充-打包”的操作， 浪费了太多时间。 com.code-philosophy.hybridclr 包提供了一个便捷的菜单命令HybridCLR&#x2F;Generate&#x2F;LinkXml， 能一键生成热更新工程里的所有AOT类型及函数引用。</p>
<p>警告:</p>
<blockquote>
<p>注意，如果你主工程中没有引用过某个程序集的任何代码，即使在link.xml中保留，该程序集也会被完全裁剪。因此对于每个要保留的AOT程序集， 请确保在主工程代码中显式引用过它的某个类或函数。</p>
</blockquote>
<h4 id="AOT类型及函数预留"><a href="#AOT类型及函数预留" class="headerlink" title="AOT类型及函数预留"></a>AOT类型及函数预留</h4><p>com.code-philosophy.hybridclr的HybridCLR&#x2F;Generate&#x2F;LinkXml命令虽然可以智能地扫描出你当前引用的AOT类型，却不能预知你未来将来使用的 类型。因此你仍然需要有规划地提前在 Assets&#x2F;link.xml(注意！不是自动生成的那个link.xml)预留你将来 可能用到的类型。切记不要疏漏，免得出现上线后某次更新使用的类型被裁剪的尴尬状况！</p>
<h2 id="增量构建"><a href="#增量构建" class="headerlink" title="增量构建"></a><a href="https://docs.unity3d.com/2022.3/Documentation/Manual/incremental-build-pipeline.html">增量构建</a></h2><p>支持版本</p>
<ul>
<li>2021.3</li>
<li>2022.3</li>
<li>Unity 6</li>
</ul>
<h2 id="将脚本挂载到热更新资源"><a href="#将脚本挂载到热更新资源" class="headerlink" title="将脚本挂载到热更新资源"></a>将脚本挂载到热更新资源</h2><p>由于Unity资源管理系统的限制，热更新脚本所挂载的资源（prefab、scene、ScriptableObject资源）必须打成assetbundle，从ab包中实例化资源，才能正确还原脚本。</p>
<blockquote>
<p>如果将热更新脚本挂载到Resources等随主包的资源上，会发生scripting missing的错误！但如果先打成assetbundle包，再放到Resources下，运行时加载该随包assetbundle则没有问题。</p>
</blockquote>
<blockquote>
<p>挂载热更新脚本的资源（场景或prefab）必须打包成ab，在实例化资源前先加载热更新dll即可（这个要求是显然的！）。</p>
</blockquote>
<h2 id="热更代码中使用AOT中定义的泛型类或函数【方案】（补充元数据）"><a href="#热更代码中使用AOT中定义的泛型类或函数【方案】（补充元数据）" class="headerlink" title="热更代码中使用AOT中定义的泛型类或函数【方案】（补充元数据）"></a>热更代码中使用AOT中定义的泛型类或函数【方案】<a href="https://hybridclr.doc.code-philosophy.com/docs/beginner/generic">（补充元数据）</a></h2><p>参考手册：<a href="https://hybridclr.doc.code-philosophy.com/docs/basic/aotgeneric#%E4%BC%98%E5%8C%96%E8%A1%A5%E5%85%85%E5%85%83%E6%95%B0%E6%8D%AEdll%E5%A4%A7%E5%B0%8F">AOT 泛型</a></p>
<blockquote>
<p>补充元数据技术的缺陷是增大了包体或者需要额外下载补充元数据dll，导致工作流复杂一些，另外还多占用了内存。</p>
</blockquote>
<h3 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h3><p><strong>背景：</strong> 如果AOT中没有实例化过某个AOT泛型类或者函数，泛型参数有可能是热更新类型，不可能在AOT中提前实例化。例如你在热更新代码中定义了 struct MyVector3 {int x, y, z;}，你不可能在AOT中提前实例化List<MyVector3>。</MyVector3></p>
<p>以下是一个示例，通过代码展示了在 <strong>AOT 模式下</strong>，如果未提前实例化泛型类或函数，当泛型参数为热更新代码定义的类型时会出现问题，以及如何通过 <strong>HybridCLR</strong> 解决这个问题。</p>
<p><strong>为什么泛型类在 AOT 中定义？</strong></p>
<blockquote>
<p>在 AOT 编译模式下，泛型类型的处理与普通类型不同。泛型类型（如 List<T> 或自定义的 MyVector3）是 参数化类型，它们的实际类型（例如 List<MyVector3>）需要在编译时确定。由于 AOT 编译 是提前进行的，因此在代码编译阶段，AOT 编译器需要知道所有泛型类型的完整定义。</MyVector3></T></p>
</blockquote>
<p><strong>具体原因：</strong></p>
<ul>
<li><p>泛型类型的元数据必须预先定义：AOT 编译的目标是生成机器代码，因此所有的类型和类型参数必须在编译时完全确定。由于泛型类型在运行时可能会有不同的类型参数（例如 List<MyVector3>），AOT 编译器必须提前知道每种类型的结构，以便生成正确的机器码。</MyVector3></p>
</li>
<li><p>热更新程序集中的泛型类型需要在 AOT 中补充元数据：假设你在热更新程序集中使用了 List<MyVector3> 和 MyVector3，虽然你在热更新程序集里声明了这些类型，但它们本身是 依赖于AOT编译时的泛型类型定义 的。为了保证在热更新过程中这些类型能够正确识别和操作，必须将它们的元数据（例如类型信息、泛型参数等）传递给 AOT 编译器，以便它能够为不同的类型生成代码和元数据。</MyVector3></p>
</li>
</ul>
<hr>
<h3 id="示例问题描述"><a href="#示例问题描述" class="headerlink" title="示例问题描述"></a><strong>示例问题描述</strong></h3><p>假设我们在 <strong>AOT 项目代码</strong> 中未显式实例化泛型类 <code>List&lt;T&gt;</code>，而在热更新代码中定义了一个新类型 <code>MyVector3</code>，并尝试使用 <code>List&lt;MyVector3&gt;</code>。因为 <strong>AOT 编译器</strong>无法预测 <code>MyVector3</code> 的存在，运行时会报错或崩溃。</p>
<hr>
<h3 id="AOT-项目代码（主工程代码）"><a href="#AOT-项目代码（主工程代码）" class="headerlink" title="AOT 项目代码（主工程代码）"></a><strong>AOT 项目代码（主工程代码）</strong></h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Main Program Running&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟加载热更新代码</span></span><br><span class="line">        LoadHotfixCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadHotfixCode</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 假设这是热更新代码的入口，动态加载并执行热更新逻辑</span></span><br><span class="line">        HotfixEntry.Execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="热更新代码（需要-HybridCLR-支持）"><a href="#热更新代码（需要-HybridCLR-支持）" class="headerlink" title="热更新代码（需要 HybridCLR 支持）"></a><strong>热更新代码（需要 HybridCLR 支持）</strong></h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyVector3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyVector3</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span> z</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span> =&gt; <span class="string">$&quot;(<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>, <span class="subst">&#123;z&#125;</span>)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HotfixEntry</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hotfix Code Running&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义热更新类型 MyVector3</span></span><br><span class="line">        List&lt;MyVector3&gt; myVectorList = <span class="keyword">new</span> List&lt;MyVector3&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试向 List&lt;MyVector3&gt; 中添加数据</span></span><br><span class="line">        myVectorList.Add(<span class="keyword">new</span> MyVector3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        myVectorList.Add(<span class="keyword">new</span> MyVector3(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> vec <span class="keyword">in</span> myVectorList)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Vector: <span class="subst">&#123;vec&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p><strong>报错：</strong></p>
<blockquote>
<p>MissingMethodException: AOT generic method not instantiated in aot. assembly:mscorlib.dll, method:System.Void System.Collections.Generic.List&#96;1[MyVector3]::Add(MyVector3)</p>
</blockquote>
<p><code>注意</code>:<br><strong>AOT 程序集通过反射加载过的类，AOT 会提前生成该类的泛型代码，故这种情况不受影响。</strong></p>
<h2 id="配置热更新程序集"><a href="#配置热更新程序集" class="headerlink" title="配置热更新程序集"></a>配置热更新程序集</h2><h3 id="HybridCLR-中的这三个程序集列表"><a href="#HybridCLR-中的这三个程序集列表" class="headerlink" title="HybridCLR 中的这三个程序集列表"></a><code>HybridCLR</code> 中的这三个程序集列表</h3><ol>
<li><p><strong>Hot Update Assembly Definitions</strong><br>这个列表通常是用于配置哪些 <strong>程序集定义（Assembly Definitions）</strong> 被标记为 <strong>热更新程序集</strong>。在 Unity 中，<strong>程序集定义</strong> 是用于组织和管理脚本程序集的资源。热更新程序集是指那些你希望通过 <code>HybridCLR</code> 框架进行动态加载和热更新的程序集。</p>
<ul>
<li><strong>作用</strong>：你可以在这里指定哪些程序集定义需要参与热更新。通常，你会在这些程序集定义中包含热更新代码（例如，游戏的业务逻辑代码）。</li>
</ul>
</li>
<li><p><strong>Hot Update Assemblies</strong><br>这个列表用于列出需要通过 <strong>热更新机制</strong> 加载的实际 <strong>程序集</strong>。这些程序集会包含你游戏的更新代码，并且通过 <code>HybridCLR</code> 可以在运行时加载。你可能会使用这些程序集来改变游戏的行为、修复 bug 或新增功能，而不需要重新构建整个游戏。</p>
<ul>
<li><strong>作用</strong>：列出你所有的热更新程序集。你会将包含热更新代码的 DLL 文件添加到这个列表，以便在游戏运行时进行动态加载和更新。</li>
</ul>
</li>
<li><p><strong>Preserve Hot Update Assemblies</strong><br>这个列表是用来列出那些 <strong>需要保留的热更新程序集</strong>。保留的热更新程序集通常是指那些需要在热更新过程中始终保留的程序集，可能包含关键的基础功能代码或在更新后不需要改变的部分。</p>
<ul>
<li><strong>作用</strong>：确保这些程序集在热更新过程中不被修改或删除。一般来说，这些程序集包含的是核心功能，确保它们不被意外删除或替换。</li>
</ul>
</li>
</ol>
<h3 id="配置程序集"><a href="#配置程序集" class="headerlink" title="配置程序集"></a>配置程序集</h3><p>一般来说，必须将热更新代码独立为assembly，才能方便地进行热更新。</p>
<h4 id="程序集分类"><a href="#程序集分类" class="headerlink" title="程序集分类"></a>程序集分类</h4><ol>
<li><p>Assembly Definition定义的程序集<br>这是Unity推荐的程序集方式。将一个大的Unity项目代码拆分为多个程序集模块，便于管理，缩短编译时间。</p>
</li>
<li><p>Assembly-CSharp 程序集</p>
</li>
</ol>
<p>这是Unity的默认全局程序集。它可以像普通dll一样当作热更新程序集。</p>
<ol>
<li>普通的dll程序集<br>一些代码被提前编译成dll文件，再移到项目中。</li>
</ol>
<h4 id="划分程序集"><a href="#划分程序集" class="headerlink" title="划分程序集"></a>划分程序集</h4><p>很显然，项目代码必须合理拆分为AOT（即编译到游戏主包内）程序集 和 热更新程序集，才能进行热更新。HybridCLR对于 怎么拆分程序集并无任何限制，甚至可以把第三方工程中的代码作为热更新程序集。一般来说，游戏刚启动时，至少需要一个AOT程序集来负责启动及热更新相关工作。</p>
<p>常见的拆分方式有几种：</p>
<ul>
<li>Assembly-CSharp作为AOT程序集。剩余代码自己拆分为N个AOT程序集和M个热更新程序集。</li>
<li>Assembly-CSharp作为热更新程序集。剩余代码自己拆分为N个AOT程序集和M个热更新程序集。</li>
</ul>
<p>无论哪种拆分方式，正确设置好程序集之间的引用关系即可。请不要在AOT程序集中引用热更新程序集，这会导致打包出错。如果 你们项目把Assembly-CSharp作为AOT程序集，强烈建议关闭热更新程序集的auto reference选项。因为Assembly-CSharp是最顶层assembly，它会自动引用剩余所有assembly，很容易就出现失误引用热更新程序集的情况。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>点击菜单 HybridCLR&#x2F;Settings 打开配置界面。</p>
<ul>
<li>如果是Assembly Definition(asmdef)方式定义的程序集，加入hotUpdateAssemblyDefinitions</li>
<li>如果是普通dll或者Assembly-CSharp.dll，则将程序集名字（不包含’.dll’后缀，如Main、Assembly-CSharp）加入hotUpdateAssemblies。</li>
</ul>
<p>hotUpdateAssemblyDefinitions和hotUpdateAssemblies列表是等价的，不要重复添加，否则会报错。</p>
<h2 id="关闭-Automatic-References-属性"><a href="#关闭-Automatic-References-属性" class="headerlink" title="关闭 Automatic References 属性"></a>关闭 <strong>Automatic References 属性</strong></h2><p>在 <strong>HybridCLR</strong> 的环境中，<strong>热更新程序集</strong>（Hotfix Assembly）关闭 <strong><code>Automatic References</code> 属性</strong> 主要是为了避免某些潜在的问题和确保热更新模块的正确性与独立性。这里的原因可以从多个角度来分析：</p>
<h3 id="1-避免不必要的程序集引用"><a href="#1-避免不必要的程序集引用" class="headerlink" title="1. 避免不必要的程序集引用"></a>1. <strong>避免不必要的程序集引用</strong></h3><ul>
<li><strong>热更新程序集</strong> 本身是为了动态更新程序中的部分逻辑而设计的。其目的是提供灵活的修改和补充功能，而不是依赖于编辑时的静态程序集（例如 <code>Assembly-CSharp.dll</code>）。</li>
<li>如果开启 <code>Automatic References</code>，热更新程序集可能会自动引入一些不必要的引用（例如 Unity 的核心引擎程序集或其他不需要的程序集），这会导致热更新代码与编辑时程序集产生依赖关系，从而影响热更新的独立性和模块化。</li>
</ul>
<h3 id="2-防止与AOT代码的冲突"><a href="#2-防止与AOT代码的冲突" class="headerlink" title="2. 防止与AOT代码的冲突"></a>2. <strong>防止与AOT代码的冲突</strong></h3><ul>
<li><strong>HybridCLR</strong> 中的热更新代码通常是通过 IL2CPP 和 AOT（Ahead Of Time Compilation）编译的。在这种环境下，AOT 编译时要求所有热更新程序集（例如脚本中的类和方法）在编译时能够被解析和实例化。</li>
<li>如果启用 <code>Automatic References</code>，热更新程序集可能会依赖于一些 AOT 编译的程序集（例如 <code>UnityEngine.dll</code>），这些程序集在编译时可能已经包含了大量的代码和类型信息，这会导致热更新程序集在运行时无法正确解析，甚至引发 <code>MissingMethodException</code> 或类型冲突。</li>
</ul>
<h3 id="3-控制热更新程序集的引用"><a href="#3-控制热更新程序集的引用" class="headerlink" title="3. 控制热更新程序集的引用"></a>3. <strong>控制热更新程序集的引用</strong></h3><ul>
<li>热更新程序集应该是一个相对独立的模块，只依赖于最基本的运行时环境和一些必要的外部程序集（例如 <code>mscorlib</code> 或者 Unity 的基本组件），而不是直接依赖于 Unity 编辑器中的程序集。</li>
<li>关闭 <code>Automatic References</code> 可以帮助开发者更好地控制热更新程序集所依赖的内容，确保它只依赖于真正需要的程序集，而不会误引入不必要的依赖，保持热更新代码的轻量性和灵活性。</li>
</ul>
<h3 id="4-解决程序集大小与热更新性能问题"><a href="#4-解决程序集大小与热更新性能问题" class="headerlink" title="4. 解决程序集大小与热更新性能问题"></a>4. <strong>解决程序集大小与热更新性能问题</strong></h3><ul>
<li>通过关闭 <code>Automatic References</code>，可以避免自动引用一些不必要的程序集，这有助于减小热更新程序集的大小，提高热更新代码的加载和执行效率。</li>
<li>如果 <code>Automatic References</code> 被启用，Unity 会尝试自动为热更新程序集添加大量的引用，可能会导致程序集膨胀，从而增加热更新时加载和反射的开销。</li>
</ul>
<h3 id="5-避免热更新与编辑时环境的耦合"><a href="#5-避免热更新与编辑时环境的耦合" class="headerlink" title="5. 避免热更新与编辑时环境的耦合"></a>5. <strong>避免热更新与编辑时环境的耦合</strong></h3><ul>
<li>热更新程序集应该是可以独立于编辑时环境进行更新和运行的。启用 <code>Automatic References</code> 会使热更新程序集与 Unity 编辑器及其工具链产生耦合，使得它们在运行时也依赖于编辑时的程序集，这会限制热更新的灵活性和可移植性。</li>
<li>关闭 <code>Automatic References</code> 可以保证热更新程序集的独立性，不会受到编辑时环境的影响，确保它在不同平台、不同构建环境下的兼容性。</li>
</ul>
<h3 id="6-避免潜在的热更新类型与-AOT-类型冲突"><a href="#6-避免潜在的热更新类型与-AOT-类型冲突" class="headerlink" title="6. 避免潜在的热更新类型与 AOT 类型冲突"></a>6. <strong>避免潜在的热更新类型与 AOT 类型冲突</strong></h3><ul>
<li>由于热更新程序集中的类型可能会被编译为 AOT 类型，若这些类型与 <code>Automatic References</code> 自动引入的程序集中的类型存在冲突或重名，可能会导致运行时错误。</li>
<li>通过关闭 <code>Automatic References</code>，开发者可以避免这类潜在冲突，确保热更新代码与 AOT 环境中的类型完全隔离。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在 <strong>HybridCLR</strong> 环境中，关闭热更新程序集的 <strong><code>Automatic References</code></strong> 属性有助于：</p>
<ol>
<li><strong>提高热更新代码的独立性</strong>，避免与编辑时环境的程序集产生依赖关系。</li>
<li><strong>避免不必要的程序集引用</strong>，减小热更新程序集的大小和加载开销。</li>
<li><strong>确保与 AOT 代码的兼容性</strong>，避免因引用冲突或类型实例化问题导致的运行时错误。</li>
<li><strong>提升热更新的性能</strong>，减少不必要的反射和程序集加载时间。</li>
</ol>
<p>因此，关闭 <code>Automatic References</code> 是一种确保热更新模块在 <strong>HybridCLR</strong> 环境中能够正确、独立运行的做法，能够保证热更新系统的稳定性和灵活性。</p>
<h2 id="加载更新assembly"><a href="#加载更新assembly" class="headerlink" title="加载更新assembly"></a><a href="https://hybridclr.doc.code-philosophy.com/docs/basic/runhotupdatecodes">加载更新assembly</a></h2><ul>
<li>通过反射直接运行热更新函数</li>
<li>通过反射创造出Delegate后运行</li>
<li>通过反射创建出对象后，再调用接口函数</li>
<li>通过动态AddComponent运行脚本代码</li>
<li><code>推荐</code> 通过初始化从打包成assetbundle的prefab或者scene还原挂载的热更新脚本(这种方法不需要借助任何反射，而且跟原生的启动流程相同，推荐使用这种方式<strong>初始化热更新入口代码</strong>！)</li>
</ul>
<h2 id="打包工作流"><a href="#打包工作流" class="headerlink" title="打包工作流"></a>打包工作流</h2><p>由于热更新本身的要求以及Unity资源管理的一些限制，对打包工作流需要一些特殊处理，主要分为几部分：</p>
<ul>
<li>设置UNITY_IL2CPP_PATH环境变量</li>
<li>打包时自动排除热更新assembly</li>
<li>打包时将热更新dll名添加到assembly列表</li>
<li>将打包过程中生成的裁剪后的aot dll拷贝出来，供补充元数据使用</li>
<li>编译热更新dll</li>
<li>生成一些打包需要的文件和代码</li>
<li>iOS平台的特殊处理</li>
</ul>
<h3 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h3><ul>
<li>运行菜单 HybridCLR&#x2F;Generate&#x2F;All 一键执行必要的生成操作</li>
<li>将HybridCLRData&#x2F;HotUpdateDlls下的热更新dll添加到项目的热更新资源管理系统</li>
<li>将HybridCLRData&#x2F;AssembliesPostIl2CppStrip下的补充元数据 dll添加到项目的热更新资源管理系统</li>
<li>根据你项目原来的打包流程打包</li>
</ul>
<h2 id="安卓打包流程优化（耗时）"><a href="#安卓打包流程优化（耗时）" class="headerlink" title="安卓打包流程优化（耗时）"></a>安卓打包流程优化（耗时）</h2><ul>
<li>运行 HybridCLR&#x2F;Generate&#x2F;LinkXml</li>
<li>导出工程</li>
<li>运行 HybridCLR&#x2F;Generate&#x2F;Il2cppDef</li>
<li>运行 HybridCLR&#x2F;Generate&#x2F;MethodBridge生成桥接函数</li>
<li>运行 HybridCLR&#x2F;Generate&#x2F;PReverseInvokeWrapper。 不需要与lua之类交互的项目可跳过此步。</li>
<li>将 {proj}\HybridCLRData\LocalIl2CppData-{platform}\il2cpp\libil2cpp\hybridclr\generated目录 替换导出工程中的此目录。</li>
<li>在导出工程上执行build</li>
</ul>
<p><a href="https://hybridclr.doc.code-philosophy.com/docs/basic/buildpipeline#ios%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86">ios处理参考该链接</a></p>
<p><a href="https://hybridclr.doc.code-philosophy.com/docs/basic/buildwebgl">build webgl</a></p>
<h3 id="脚本后端"><a href="#脚本后端" class="headerlink" title="脚本后端"></a><a href="https://docs.unity3d.com/Manual/scripting-backends.html">脚本后端</a></h3><p> “后端” 并不是指服务器端，而是指 Unity 引擎中的编译和执行环境。在 Unity 中，尤其是在涉及到 IL2CPP 和 HybridCLR 的开发时，”后端” 是指你应用程序代码的 <strong>编译方式</strong> 和 <strong>执行方式</strong>。“后端” 指的其实是你选择的 C# 代码运行的环境。具体来说：</p>
<ul>
<li>IL2CPP（Intermediate Language to C++） 是 Unity 的一个脚本后端，它将 C# 脚本代码转换成 C++ 代码，再通过 C++ 编译器生成原生机器码。</li>
<li>Mono 是另一种脚本后端，它直接通过 Mono 虚拟机运行 C# 代码。</li>
</ul>
<h3 id="1-什么是“导出工程”？"><a href="#1-什么是“导出工程”？" class="headerlink" title="1. 什么是“导出工程”？"></a>1. <strong>什么是“导出工程”？</strong></h3><p>“导出工程”在这里指的是从 Unity 编辑器生成的项目文件（或者构建出的本地工程）的一部分。在 Unity 中使用 <strong>HybridCLR</strong> 时，尤其是在 IL2CPP 后端模式下，通常需要与 Unity 的原生代码交互，生成相应的工程文件，以便进行后续的构建和修改。</p>
<p>具体来说，<strong>导出工程</strong> 就是使用 <strong>IL2CPP</strong> 脚本后端编译时，Unity 会生成一份包含 C++ 代码和相关文件的工程，这个工程是你用来编译和生成最终的原生平台（如 iOS 或 Android）程序的基础。</p>
<h3 id="2-具体流程解释"><a href="#2-具体流程解释" class="headerlink" title="2. 具体流程解释"></a>2. <strong>具体流程解释</strong></h3><h4 id="2-1-运行-HybridCLR-Generate-LinkXml"><a href="#2-1-运行-HybridCLR-Generate-LinkXml" class="headerlink" title="2.1 运行 HybridCLR/Generate/LinkXml"></a>2.1 <strong>运行 <code>HybridCLR/Generate/LinkXml</code></strong></h4><p><code>LinkXml</code> 生成的作用是 <strong>生成 IL2CPP 的链接配置</strong>，它用于指示 IL2CPP 编译器哪些类、方法和属性需要保留下来。在 IL2CPP 构建过程中，IL2CPP 会进行代码裁剪（linking），只保留实际使用到的代码。<code>LinkXml</code> 允许你保留特定的代码段（例如热更新相关的代码）。</p>
<ul>
<li><strong>目的</strong>：确保热更新的代码（如热更新 DLL 中的类和方法）不会在 IL2CPP 编译时被裁剪掉。</li>
<li><strong>输出</strong>：生成一个 <code>link.xml</code> 文件，里面定义了需要保留的类和方法。</li>
</ul>
<h4 id="2-2-导出工程"><a href="#2-2-导出工程" class="headerlink" title="2.2 导出工程"></a>2.2 <strong>导出工程</strong></h4><p>“导出工程”通常指的是从 Unity 项目中 <strong>构建出一个原生的工程文件</strong>，通常是 <strong>C++ 工程</strong>，用于 iOS 或 Android 等平台，依赖于 IL2CPP 编译后生成的代码。这个步骤通过 Unity 编辑器构建项目，生成适合平台的本地工程文件。</p>
<ul>
<li><strong>Unity 编辑器操作</strong>：选择适合的平台（如 iOS、Android），然后执行 <strong>Build</strong> 或 <strong>Export</strong> 操作，生成一个本地平台的工程文件（如 iOS 的 Xcode 工程或 Android 的 CMake 工程）。</li>
</ul>
<h4 id="2-3-运行-HybridCLR-Generate-Il2cppDef"><a href="#2-3-运行-HybridCLR-Generate-Il2cppDef" class="headerlink" title="2.3 运行 HybridCLR/Generate/Il2cppDef"></a>2.3 <strong>运行 <code>HybridCLR/Generate/Il2cppDef</code></strong></h4><p><code>Il2cppDef</code> 主要的作用是生成与 IL2CPP 后端相关的代码定义文件。这些定义文件将帮助 HybridCLR 在 IL2CPP 编译的过程中与原生代码进行桥接。</p>
<ul>
<li><strong>目的</strong>：生成一些 C++ 定义，确保 HybridCLR 可以通过 IL2CPP 后端正确地与 C# 热更新代码进行交互。</li>
<li><strong>输出</strong>：生成 C++ 文件和定义，可能会被包含在后续的构建工程中。</li>
</ul>
<h4 id="2-4-运行-HybridCLR-Generate-MethodBridge"><a href="#2-4-运行-HybridCLR-Generate-MethodBridge" class="headerlink" title="2.4 运行 HybridCLR/Generate/MethodBridge"></a>2.4 <strong>运行 <code>HybridCLR/Generate/MethodBridge</code></strong></h4><p><code>MethodBridge</code> 会生成所谓的 <strong>桥接函数</strong>，这些桥接函数用于连接 IL2CPP 后端的 C++ 代码与 Unity 的 C# 代码。</p>
<ul>
<li><strong>目的</strong>：生成桥接函数代码，确保 C# 代码与原生 C++ 代码之间可以通过 IL2CPP 后端进行正确的调用。特别是 HybridCLR 使用这些桥接函数来调用热更新程序集中的方法。</li>
<li><strong>输出</strong>：生成 C++ 桥接函数文件，通常包括函数声明和实现。</li>
</ul>
<h4 id="2-5-运行-HybridCLR-Generate-PReverseInvokeWrapper（如果需要）"><a href="#2-5-运行-HybridCLR-Generate-PReverseInvokeWrapper（如果需要）" class="headerlink" title="2.5 运行 HybridCLR/Generate/PReverseInvokeWrapper（如果需要）"></a>2.5 <strong>运行 <code>HybridCLR/Generate/PReverseInvokeWrapper</code>（如果需要）</strong></h4><p><code>PReverseInvokeWrapper</code> 是用于生成 <strong>反向调用的包装函数</strong>。如果你的项目需要与如 Lua 等脚本语言交互（例如 Lua 调用 C# 代码），你需要这一步生成的代码。如果项目中不需要与 Lua 等脚本引擎交互，可以跳过这一步。</p>
<ul>
<li><strong>目的</strong>：生成允许脚本语言（如 Lua）调用 C# 热更新代码的包装函数。</li>
<li><strong>输出</strong>：生成 C++ 包装函数文件，这些文件通常会作为脚本语言与 C# 代码交互的中间桥梁。</li>
</ul>
<h4 id="2-6-替换生成的目录"><a href="#2-6-替换生成的目录" class="headerlink" title="2.6 替换生成的目录"></a>2.6 <strong>替换生成的目录</strong></h4><p>你需要将生成的文件替换到 <strong>导出工程</strong> 中的相应目录，这些文件是由 HybridCLR 的生成工具（如 <code>MethodBridge</code> 和 <code>PReverseInvokeWrapper</code>）生成的。具体步骤如下：</p>
<ul>
<li>找到 <code>HybridCLRData/LocalIl2CppData-&#123;platform&#125;/il2cpp/libil2cpp/hybridclr/generated</code> 目录。</li>
<li>将该目录中的文件复制到导出工程中的相应目录中。</li>
</ul>
<p>这一步的目的是确保 HybridCLR 生成的代码（如桥接函数、反向调用包装函数等）已经被包含在导出工程中，以便后续的编译和构建。</p>
<h4 id="2-7-在导出工程上执行-build"><a href="#2-7-在导出工程上执行-build" class="headerlink" title="2.7 在导出工程上执行 build"></a>2.7 <strong>在导出工程上执行 build</strong></h4><p>最后一步是 <strong>在导出工程中进行构建</strong>。你需要通过构建工具（如 Xcode 或 Android Studio）编译并生成最终的应用程序。这一步将会使用 HybridCLR 生成的代码与热更新 DLL 进行链接，构建出最终的原生应用。</p>
<ul>
<li><strong>构建操作</strong>：使用 Xcode（对于 iOS）或 Android Studio（对于 Android）对导出的工程进行编译和构建，生成最终的 APK 或 IPA 文件。</li>
<li><strong>输出</strong>：最终的应用程序包（如 APK 文件或 IPA 文件），该文件包含了 IL2CPP 后端生成的本地代码和 HybridCLR 的热更新功能。</li>
</ul>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. <strong>总结</strong></h3><p>整个流程大致上是为了支持在 IL2CPP 构建环境下的热更新功能，特别是在 Unity 使用 HybridCLR 进行热更新时，涉及到以下几个关键步骤：</p>
<ol>
<li><strong>生成 IL2CPP 配置和定义文件</strong>，确保热更新代码不被裁剪。</li>
<li><strong>导出本地工程</strong>，生成适合目标平台的 C++ 工程。</li>
<li><strong>生成桥接函数和反向调用包装函数</strong>，让 C# 热更新代码与原生代码正确交互。</li>
<li><strong>替换和整合生成的文件</strong>，确保生成的代码被正确集成到导出的工程中。</li>
<li><strong>编译和构建</strong>，生成最终的应用程序包，支持热更新功能。</li>
</ol>
<p>“导出工程”是指生成适用于目标平台的 C++ 工程文件，这个文件在后续的构建和部署过程中起到至关重要的作用。</p>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a><a href="https://hybridclr.doc.code-philosophy.com/docs/help/commonerrors">常见错误</a></h2><h2 id="在GameObject上Add热更新脚本或者在资源上直接挂载-热更新脚本"><a href="#在GameObject上Add热更新脚本或者在资源上直接挂载-热更新脚本" class="headerlink" title="在GameObject上Add热更新脚本或者在资源上直接挂载 热更新脚本"></a>在GameObject上Add热更新脚本或者在资源上直接挂载 热更新脚本</h2><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>AddComponent<T>()或者AddComponent(Type type)任何时候都是完美支持的。只需要提前通过Assembly.Load将热更新dll加载到运行时 内即可。</T></p>
<h3 id="在资源上挂载热更新脚本"><a href="#在资源上挂载热更新脚本" class="headerlink" title="在资源上挂载热更新脚本"></a>在资源上挂载热更新脚本</h3><p>Unity资源管理系统在反序列化资源中的热更新脚本时，需要满足以下条件：</p>
<ul>
<li>脚本所在的dll已经加载到运行时中</li>
<li>必须是使用AssetBundle打包的资源（addressable之类间接使用了ab的框架也可以）</li>
<li>你需要把项目中的热更新assembly添加到HybridCLRSettings配置的HotUpdateAssemblyDefinitions或HotUpdateAssemblies 字段中。</li>
</ul>
<p>只限制了热更新资源以ab包形式打包，热更新dll打包方式没有限制。你可以按照项目需求自由选择热更新方式，可以将dll打包到ab中，或者裸数据 文件，或者加密压缩等等。只要能保证在加载热更新资源前使用Assembly.Load将其加载即可。</p>
<p><strong>危险</strong></p>
<blockquote>
<p>如果将热更新脚本挂载到Resources等随主包的资源上，会发生scripting missing的错误！但如果先打成assetbundle包，再放到Resources下，运行时加载该随包assetbundle则没有问题。</p>
</blockquote>
<h3 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h3><h4 id="主线程AddComponent及其他资源加载线程加载包含热更新脚本的资源同时进行时偶发的崩溃问题"><a href="#主线程AddComponent及其他资源加载线程加载包含热更新脚本的资源同时进行时偶发的崩溃问题" class="headerlink" title="主线程AddComponent及其他资源加载线程加载包含热更新脚本的资源同时进行时偶发的崩溃问题"></a>主线程AddComponent及其他资源加载线程加载包含热更新脚本的资源同时进行时偶发的崩溃问题</h4><p>此问题来自issue报告。</p>
<p>在第一次使用某热更新类型时（主线程AddComponent或者资源线程加载含脚本的资源）会触发引擎创建MonoScript数据，然而此操作并非线程安全。由于未接入hybridclr时，所有脚本都在启动时已经初始化，因此不会有线程安全问题。当接入hybridclr后，在偶然情况下（尤其是加载包含大量脚本的资源）会触发这个问题。</p>
<blockquote>
<p><strong>解决办法如下：</strong></p>
</blockquote>
<p><strong>执行时机：</strong></p>
<p>该解决方案应该在 热更新程序集加载之后 执行，确保所有热更新类型已经被加载到内存中，但还没有被主线程或资源线程使用。具体来说，它应该在以下几个时机执行：</p>
<ul>
<li>热更新程序集加载完成之后，即热更新相关的脚本已经被加载到内存，但并没有立即被用于 AddComponent 或者其他操作。</li>
<li>加载包含热更新脚本的资源之前，以确保在加载资源时，所有的 MonoBehaviour 类型已经在主线程上完成初始化，避免在其他线程上并发调用这些脚本时发生崩溃。<br>加载完热更新程序集后，通过临时创建的GameObject,把所有热更新脚本都添加一遍，类似这样：<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> go = <span class="keyword">new</span> GameObject();</span><br><span class="line"><span class="comment">// 我们不希望挂载到这个GameObject上的脚本执行</span></span><br><span class="line">go.Active = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> type <span class="keyword">in</span> hotUpdateAss.GetTypes())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span>(MonoBehaviour).IsAssignFrom(type))</span><br><span class="line">    &#123;</span><br><span class="line">        go.AddComponent(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">GameObject.Destroy(go);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="建议打AB时不要禁用TypeTree"><a href="#建议打AB时不要禁用TypeTree" class="headerlink" title="建议打AB时不要禁用TypeTree"></a>建议打AB时不要禁用TypeTree</h4><p>需要被挂到资源上的脚本所在dll名称上线后勿修改，因为assembly列表文件打包后无法修改。</p>
<p>建议打AB时不要禁用TypeTree，否则普通的AB加载方式会失败。（原因是对于禁用TypeTree的脚本，Unity为了防止二进制不匹配导致反序列化MonoBehaviour过程中进程Crash，会对脚本的签名进行校验，签名的内容是脚本FullName及TypeTree数据生成的Hash, 但由于我们的热更脚本信息不存在于打包后的安装包中，因此校验必定会失败）</p>
<p>如果必须要禁用TypeTree，一个变通的方法是禁止脚本的Hash校验, 此种情况下用户必须保证打包时代码与资源版本一致，否则可能会导致Crash，示例代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">AssetBundleCreateRequest req = AssetBundle.LoadFromFileAsync(path);</span><br><span class="line">req.SetEnableCompatibilityChecks(<span class="literal">false</span>); <span class="comment">// 非public，需要通过反射调用</span></span><br></pre></td></tr></table></figure>


<p>禁用 <code>TypeTree</code> 的行为是一个比较敏感的操作，特别是在 Asset Bundle（AB）打包和热更新的场景中。<code>TypeTree</code> 是 Unity 用于确保反序列化过程中的类型匹配性和安全性的工具，而禁用它可能会导致一些潜在的反序列化错误或崩溃，尤其是在更新脚本时。因此，禁用 <code>TypeTree</code> 需要特别小心。</p>
<h3 id="如何禁用-TypeTree"><a href="#如何禁用-TypeTree" class="headerlink" title="如何禁用 TypeTree"></a>如何禁用 TypeTree</h3><p>根据您的需求，禁用 <code>TypeTree</code> 的一个常见方法是通过 <strong>AssetBundleCreateRequest</strong> 的 <code>SetEnableCompatibilityChecks</code> 方法。这实际上是禁用 Unity 对于脚本的签名校验，从而跳过了 <code>TypeTree</code> 的检查。</p>
<h4 id="示例代码：通过反射禁用-TypeTree-校验"><a href="#示例代码：通过反射禁用-TypeTree-校验" class="headerlink" title="示例代码：通过反射禁用 TypeTree 校验"></a>示例代码：通过反射禁用 TypeTree 校验</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DisableTypeTreeExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> path = <span class="string">&quot;path/to/your/assetbundle&quot;</span>; <span class="comment">// 你的AB包路径</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载AB包</span></span><br><span class="line">        AssetBundleCreateRequest req = AssetBundle.LoadFromFileAsync(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用反射禁用脚本的Hash校验</span></span><br><span class="line">        MethodInfo setEnableCompatibilityChecks = <span class="keyword">typeof</span>(AssetBundleCreateRequest).GetMethod(<span class="string">&quot;SetEnableCompatibilityChecks&quot;</span>, BindingFlags.NonPublic | BindingFlags.Instance);</span><br><span class="line">        <span class="keyword">if</span> (setEnableCompatibilityChecks != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            setEnableCompatibilityChecks.Invoke(req, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="literal">false</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们通过反射调用了 <code>AssetBundleCreateRequest.SetEnableCompatibilityChecks(false)</code> 来禁用 <code>TypeTree</code> 校验。这意味着您可以绕过类型校验和 <code>TypeTree</code> 校验，但这样做的风险在于如果后续资源和代码的版本不一致，可能会导致 <strong>崩溃</strong> 或 <strong>错误加载</strong>。</p>
<h3 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h3><ol>
<li><p><strong>热更新中的问题</strong>：<br>如果您使用热更新机制（比如 IL2CPP 编译的程序集），禁用 <code>TypeTree</code> 校验可能导致 Unity 在加载和反序列化脚本时无法匹配类型。这是因为禁用 <code>TypeTree</code> 后，Unity 无法验证加载的脚本的类型信息，从而可能会导致加载错误或进程崩溃。</p>
</li>
<li><p><strong>资源和脚本版本一致性</strong>：<br>禁用 <code>TypeTree</code> 校验后，必须确保您打包的资源与实际运行的脚本版本一致。否则，当脚本和资源版本不匹配时，Unity 会在加载时崩溃。特别是对于热更新项目，您需要手动确保脚本的版本与 AB 包中包含的资源一致。</p>
</li>
<li><p><strong>适用场景</strong>：<br>禁用 <code>TypeTree</code> 通常是在一些特殊情况下使用，比如当您无法确保资源和脚本版本一致时，但如果您的热更新脚本没有包含在 AB 包中，这会导致校验失败。除非有很强的需求，否则一般不推荐在生产环境中禁用 <code>TypeTree</code>。</p>
</li>
</ol>
<h3 id="如何查看-TypeTree-是否被禁用"><a href="#如何查看-TypeTree-是否被禁用" class="headerlink" title="如何查看 TypeTree 是否被禁用"></a>如何查看 <code>TypeTree</code> 是否被禁用</h3><p>Unity 并没有提供直接查看 <code>TypeTree</code> 是否被禁用的界面，您只能通过以下方式间接判断：</p>
<ol>
<li><p><strong>日志检查</strong>：<br>如果禁用了 <code>TypeTree</code> 校验，并且存在版本不匹配的情况，Unity 会在加载 AB 包时抛出错误或者崩溃。因此，可以通过查看 Unity 的日志文件（<code>Editor.log</code> 或 <code>Player.log</code>）来确定是否发生了类型不匹配的错误。</p>
</li>
<li><p><strong>Asset Bundle 加载失败</strong>：<br>如果 <code>TypeTree</code> 校验被禁用，且脚本与资源版本不匹配，加载 AB 包时可能会导致反序列化错误。您可以通过在加载时检查 <code>AssetBundle</code> 是否加载成功来推测是否存在 <code>TypeTree</code> 校验问题。</p>
</li>
</ol>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**禁用 <code>TypeTree</code>**：通过调用 <code>AssetBundleCreateRequest.SetEnableCompatibilityChecks(false)</code> 来禁用校验，但这会导致脚本与资源版本不一致时可能崩溃，且通常不推荐在生产环境中使用。</li>
<li><strong>风险</strong>：禁用 <code>TypeTree</code> 校验会导致加载脚本时无法检查类型匹配，可能会引发反序列化错误。</li>
<li><strong>使用场景</strong>：一般仅在确保代码和资源版本完全一致的情况下使用，或在特定的热更新流程中使用。</li>
</ul>
<p>如果您决定使用这种方式禁用 <code>TypeTree</code> 校验，请务必保证脚本和资源的版本严格同步，以避免加载失败或崩溃。</p>
<h2 id="Unity打包AB时禁用TypeTree的优缺点"><a href="#Unity打包AB时禁用TypeTree的优缺点" class="headerlink" title="Unity打包AB时禁用TypeTree的优缺点"></a>Unity打包AB时禁用TypeTree的优缺点</h2><p><strong>禁用TypeTree</strong> 是 Unity 打包 AssetBundle 时一个常用的优化选项，它可以有效减小包体大小，提升加载速度。但同时也会带来一些限制和潜在问题。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li><strong>减小包体大小：</strong> TypeTree 存储了资源的类型信息，禁用它可以显著减小 AssetBundle 的体积，从而加快下载和加载速度。</li>
<li><strong>提升加载速度：</strong> 由于 TypeTree 信息的缺失，Unity 在加载 AssetBundle 时不需要解析 TypeTree，从而减少了 CPU 消耗，提高了加载速度。</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><strong>兼容性问题：</strong><ul>
<li><strong>不同 Unity 版本：</strong> 在不同版本的 Unity 中，TypeTree 的结构可能会有变化。如果禁用 TypeTree，高版本 Unity 可能无法正确加载低版本打包的 AssetBundle。</li>
<li><strong>自定义类型：</strong> 如果项目中使用了自定义类型，禁用 TypeTree 后，这些自定义类型的序列化和反序列化可能会出现问题。</li>
</ul>
</li>
<li><strong>调试困难：</strong> 在没有 TypeTree 的情况下，调试 AssetBundle 加载问题会变得更加困难。</li>
<li><strong>无法热更新脚本：</strong> 禁用 TypeTree 后，Unity 在加载 AssetBundle 时会对脚本进行签名校验，如果脚本内容发生变化，就无法热更新。</li>
<li><strong>Editor 下使用受限：</strong> 在 Editor 环境下，如果 AssetBundle 禁用了 TypeTree，有些功能可能无法正常工作，比如使用 AssetDatabase 加载 AssetBundle。</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li><strong>移动端游戏：</strong> 对于移动端游戏来说，包体大小和加载速度是至关重要的。如果项目对包体大小要求较高，并且不涉及频繁的热更新，可以考虑禁用 TypeTree。</li>
<li><strong>静态资源：</strong> 对于一些不会经常更新的静态资源，禁用 TypeTree 可以有效减小包体大小。</li>
</ul>
<h3 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h3><ul>
<li><strong>频繁热更新的项目：</strong> 如果项目需要频繁地热更新脚本或资源，禁用 TypeTree 会带来很大的限制。</li>
<li><strong>自定义类型较多的项目：</strong> 如果项目中使用了大量的自定义类型，禁用 TypeTree 后可能会导致序列化和反序列化问题。</li>
<li><strong>对调试要求较高的项目：</strong> 如果项目需要频繁地调试 AssetBundle 加载问题，禁用 TypeTree 会增加调试难度。</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>禁用 TypeTree 可以有效减小包体大小和提升加载速度，但同时也带来了一些限制和潜在问题。在决定是否禁用 TypeTree 时，需要综合考虑项目的具体情况，权衡优缺点。</p>
<p><strong>建议：</strong></p>
<ul>
<li><strong>谨慎使用：</strong> 在正式发布之前，一定要对禁用 TypeTree 的 AssetBundle 进行充分的测试，确保其在目标平台上能够正常运行。</li>
<li><strong>分包处理：</strong> 可以将经常更新的资源和静态资源分开放到不同的 AssetBundle 中，对于经常更新的资源可以保留 TypeTree，而对于静态资源可以禁用 TypeTree。</li>
<li><strong>考虑其他优化方式：</strong> 除了禁用 TypeTree，还可以通过压缩纹理、优化模型、减少冗余资源等方式来减小包体大小。</li>
</ul>
<p><strong>总结来说，禁用 TypeTree 是一项需要谨慎使用的优化手段，并不是适用于所有项目。</strong></p>
<h2 id="桥接函数"><a href="#桥接函数" class="headerlink" title="桥接函数"></a>桥接函数</h2><p><code>HybridCLR</code> 是一个为 Unity 提供的跨平台热更新框架，它允许在 Unity 中动态加载和执行 C# 代码。其核心目标是支持游戏在运行时进行热更新，而无需重新编译或重新启动游戏应用。在此框架中，桥接函数（Bridge Functions）扮演着非常关键的角色。</p>
<h3 id="桥接函数的作用"><a href="#桥接函数的作用" class="headerlink" title="桥接函数的作用"></a>桥接函数的作用</h3><p>在 HybridCLR 的上下文中，桥接函数主要用于以下目的：</p>
<ol>
<li><p><strong>跨平台调用管理</strong>：在 Unity 的不同平台（如 Android、iOS、Windows 等）之间进行桥接，确保可以在不同平台上调用并执行相同的代码。由于每个平台对底层操作系统的访问方式不同，桥接函数提供了一种通用接口，将平台特定的操作抽象化，从而使代码更具可移植性。</p>
</li>
<li><p><strong>C# 与原生代码的交互</strong>：游戏中的部分原生功能（如底层的性能优化、平台特定的 API）需要调用 C++ 或其他原生代码，而桥接函数则充当了 C# 和原生代码之间的桥梁。这种桥接使得 C# 代码可以通过 <code>P/Invoke</code> 或其他类似的机制与 C++ 代码进行交互，避免了传统开发中可能出现的复杂性。</p>
</li>
<li><p><strong>热更新时的接口绑定</strong>：当进行热更新时，Unity 项目中的 C# 代码会被动态加载和执行。为了使热更新后的代码能够正确与 Unity 引擎或其他底层系统交互，桥接函数负责在运行时动态绑定和调用接口，使得热更新代码能够在新的环境中顺利运行。</p>
</li>
<li><p><strong>优化性能</strong>：桥接函数有助于将一些高频调用或资源密集型的操作迁移到更底层的原生代码中处理，而不是全部依赖于 C# 代码，从而提高性能。</p>
</li>
</ol>
<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>通过桥接函数，HybridCLR 解决了以下几个问题：</p>
<ol>
<li><p><strong>平台兼容性</strong>：通过提供一个统一的桥接层，解决了不同平台之间因调用底层 API 的差异所带来的问题，使得热更新代码能够跨平台运行。</p>
</li>
<li><p><strong>C# 与底层代码的交互</strong>：原生代码和 C# 代码之间的交互是 Unity 开发中的一个挑战。桥接函数简化了这部分操作，允许开发者在热更新中无缝调用底层系统。</p>
</li>
<li><p><strong>避免重新编译</strong>：通过热更新机制，可以动态加载修改后的 C# 代码，而无需重新编译整个项目。桥接函数确保修改后的代码与底层系统仍然能够正常交互。</p>
</li>
</ol>
<p>总之，桥接函数是 HybridCLR 提供的一个重要机制，它使得 Unity 开发者能够在热更新过程中保持对底层系统的访问，并且解决了平台差异和性能优化等问题。</p>
<p><code>HybridCLR</code> 的桥接函数是实现 Unity 热更新的一个关键技术，能够使得 C# 代码和原生代码（如 C++）之间进行高效的交互。它的工作原理和流程涉及到一些复杂的技术，尤其是在动态加载、平台兼容性和性能优化方面。下面我会详细解释它是如何参与这些工作、背后的原理，以及整个工作流程。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li><p><strong>C# 和原生代码之间的桥接</strong><br>在 Unity 中，游戏项目通常使用 C# 编写业务逻辑，但有时需要与底层的原生代码（例如 C++ 或平台特定的原生库）进行交互。传统上，这种交互通过平台调用（P&#x2F;Invoke）或 <code>DllImport</code> 来完成，但这在动态加载和热更新的场景中会变得非常复杂。<code>HybridCLR</code> 桥接函数通过以下方式来解决这一问题：</p>
<ul>
<li><strong>原生函数封装</strong>：HybridCLR 会将原生函数封装为统一的桥接接口。这样，无论是热更新时调用的 C# 代码，还是 Unity 本身的 C++ 引擎代码，都能通过这个桥接函数进行通信。</li>
<li><strong>动态链接</strong>：当热更新代码被加载时，桥接函数会动态地加载和链接原生代码库，以确保 C# 代码能与原生代码进行正确的调用。</li>
</ul>
</li>
<li><p><strong>运行时绑定与反射</strong></p>
<ul>
<li><strong>动态绑定</strong>：桥接函数通常通过反射机制在运行时绑定方法。比如，当某个热更新的 C# 代码尝试调用一个底层的原生函数时，<code>HybridCLR</code> 会查找相应的桥接函数并在运行时将它与原生代码的实现连接起来。这样就避免了在编译时必须静态绑定的问题。</li>
<li><strong>元数据生成</strong>：在热更新过程中，HybridCLR 会生成一些元数据，用来描述 C# 代码和原生代码之间的映射关系。这个元数据在桥接过程中非常重要，它帮助系统动态地将 C# 方法与底层的原生方法进行映射。</li>
</ul>
</li>
<li><p><strong>跨平台支持</strong></p>
<ul>
<li><strong>统一接口</strong>：HybridCLR 为不同的平台提供了统一的桥接接口。即使在不同平台上，底层代码可能会有所不同，但通过桥接函数，C# 代码始终可以通过相同的接口进行调用，<code>HybridCLR</code> 会根据目标平台的不同加载不同的底层实现。</li>
<li><strong>平台适配</strong>：当热更新代码运行在不同的平台时，桥接函数能够根据平台的不同适配不同的原生接口或函数，确保跨平台兼容性。</li>
</ul>
</li>
<li><p><strong>性能优化</strong></p>
<ul>
<li><strong>原生调用</strong>：有些性能要求高的操作可能需要通过原生代码来实现，这时桥接函数允许 C# 代码通过调用原生代码来实现性能优化。</li>
<li><strong>减少开销</strong>：桥接函数在调用原生代码时会尽量减少开销。例如，减少不必要的参数传递，避免频繁的反射调用，或者将一些调用迁移到异步线程来避免阻塞主线程。</li>
</ul>
</li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li><p><strong>热更新代码加载</strong><br>在热更新过程中，<code>HybridCLR</code> 会加载修改后的 C# 程序集，并将其加载到 Unity 引擎中。这些程序集可以是动态编译的，通常使用 <code>DLL</code> 文件的形式。当这些代码加载后，系统会扫描并生成相应的元数据和映射表。</p>
</li>
<li><p><strong>桥接函数注册</strong><br>在加载过程中，<code>HybridCLR</code> 会注册所有需要桥接的函数。例如，C# 代码中的某个方法需要调用底层 C++ 函数，那么这个方法就会通过桥接函数与相应的原生方法进行关联。此时，<code>HybridCLR</code> 会为这些桥接函数建立一对一的映射。</p>
</li>
<li><p><strong>热更新中的方法调用</strong><br>一旦热更新代码加载并注册了桥接函数，当 C# 代码执行时，如果需要调用原生方法，<code>HybridCLR</code> 会通过运行时反射和动态链接来调用相应的桥接函数。这些桥接函数会根据需要将请求转发给底层的原生实现，确保原生代码正确执行并返回结果。</p>
</li>
<li><p><strong>跨平台切换</strong><br>如果你的游戏在多个平台上运行（如 Android、iOS、Windows 等），<code>HybridCLR</code> 会根据当前运行的平台选择适当的桥接实现。例如，Android 可能通过 JNI 调用 C++ 代码，而 iOS 可能通过 Objective-C 桥接与 C++ 交互。<code>HybridCLR</code> 会根据平台自动加载和切换这些不同的实现，确保跨平台兼容。</p>
</li>
<li><p><strong>性能监控与优化</strong><br><code>HybridCLR</code> 的桥接函数还可以参与性能监控。当系统检测到某些原生代码的调用耗时过长，或者需要进行性能优化时，桥接函数会在运行时进行优化，减少性能开销，确保热更新和底层代码交互时的高效性。</p>
</li>
</ol>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>HybridCLR</code> 桥接函数的核心原理是通过动态链接、反射和跨平台适配技术，使得 C# 代码能够与底层原生代码高效、安全地交互。它提供了一个统一的接口来管理不同平台间的差异，使得热更新后的 C# 代码可以在各种设备上平稳运行，而无需进行复杂的编译和部署。桥接函数的动态绑定、元数据生成和性能优化策略使得 <code>HybridCLR</code> 成为一个强大的热更新工具。</p>
<h2 id="资源更新判断"><a href="#资源更新判断" class="headerlink" title="资源更新判断"></a>资源更新判断</h2><p>在游戏热更新过程中，判断客户端是否拥有最新代码和资源是关键的一步。通常会通过以下步骤实现版本检查和更新机制：</p>
<hr>
<h3 id="1-使用版本号或版本文件进行比较"><a href="#1-使用版本号或版本文件进行比较" class="headerlink" title="1. 使用版本号或版本文件进行比较"></a><strong>1. 使用版本号或版本文件进行比较</strong></h3><h4 id="资源版本管理"><a href="#资源版本管理" class="headerlink" title="资源版本管理"></a><strong>资源版本管理</strong></h4><ul>
<li><p>每次更新代码或资源时，生成一个 <strong>版本号</strong>（如 <code>v1.0</code>、<code>v1.1</code>）或 <strong>版本文件</strong>。</p>
</li>
<li><p>版本文件通常是一个 JSON 或 TXT 文件，记录当前资源的版本号或资源的文件校验信息，例如：</p>
<p><strong>版本文件示例（<code>version.json</code>）：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;assetBundles&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;character_assets.ab&quot;</span><span class="punctuation">:</span> <span class="string">&quot;f2a29d0c08f2c4a3d1d7ec5b6e8b8a34&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;environment_assets.ab&quot;</span><span class="punctuation">:</span> <span class="string">&quot;e1d4f7600c1f7b4a9e5f9e2b123f9a8d&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>流程：</strong></p>
<ol>
<li>客户端在启动时，向服务器请求最新的 <code>version.json</code>。</li>
<li>比较本地的版本号和服务器的版本号：<ul>
<li>如果版本号相同，则无需更新。</li>
<li>如果版本号不同，则需要下载新的资源。</li>
</ul>
</li>
<li>对于每个资源文件，可以通过文件名或校验值（如 MD5&#x2F;SHA256）来确认文件是否需要更新。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-文件校验（哈希值校验）"><a href="#2-文件校验（哈希值校验）" class="headerlink" title="2. 文件校验（哈希值校验）"></a><strong>2. 文件校验（哈希值校验）</strong></h3><p>通过计算文件的校验值（如 MD5、SHA256），判断本地资源是否和服务器上的一致：</p>
<h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a><strong>服务器端</strong></h4><ul>
<li>每次打包后，计算每个资源文件的 MD5 哈希值，并将这些值记录到版本文件中：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;character_assets.ab&quot;</span><span class="punctuation">:</span> <span class="string">&quot;f2a29d0c08f2c4a3d1d7ec5b6e8b8a34&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;environment_assets.ab&quot;</span><span class="punctuation">:</span> <span class="string">&quot;e1d4f7600c1f7b4a9e5f9e2b123f9a8d&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><strong>客户端</strong></h4><ul>
<li>客户端计算本地资源文件的 MD5 值，与服务器的值进行对比：<ul>
<li>如果一致，则无需更新。</li>
<li>如果不一致，则需要下载对应资源。</li>
</ul>
</li>
</ul>
<p><strong>C# 示例：计算文件的 MD5</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Security.Cryptography;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetMD5Hash</span>(<span class="params"><span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> md5 = MD5.Create())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> stream = File.OpenRead(filePath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> hash = md5.ComputeHash(stream);</span><br><span class="line">            <span class="keyword">return</span> BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLowerInvariant();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-热更新流程"><a href="#3-热更新流程" class="headerlink" title="3. 热更新流程"></a><strong>3. 热更新流程</strong></h3><p>以下是一个完整的热更新流程设计：</p>
<h4 id="1-检查版本文件"><a href="#1-检查版本文件" class="headerlink" title="1. 检查版本文件"></a><strong>1. 检查版本文件</strong></h4><ul>
<li>客户端在启动时请求服务器的版本文件（如 <code>version.json</code>）。</li>
</ul>
<h4 id="2-比较版本号"><a href="#2-比较版本号" class="headerlink" title="2. 比较版本号"></a><strong>2. 比较版本号</strong></h4><ul>
<li>如果客户端的版本号小于服务器的版本号：<ul>
<li>下载新的资源列表文件或版本文件。</li>
</ul>
</li>
</ul>
<h4 id="3-校验资源"><a href="#3-校验资源" class="headerlink" title="3. 校验资源"></a><strong>3. 校验资源</strong></h4><ul>
<li>对每个需要更新的资源文件进行哈希值比较。</li>
<li>如果资源文件不一致，下载对应文件并替换本地版本。</li>
</ul>
<h4 id="4-下载资源"><a href="#4-下载资源" class="headerlink" title="4. 下载资源"></a><strong>4. 下载资源</strong></h4><ul>
<li>客户端从服务器下载需要更新的资源（如 <code>.ab</code> 文件）。</li>
</ul>
<h4 id="5-替换资源"><a href="#5-替换资源" class="headerlink" title="5. 替换资源"></a><strong>5. 替换资源</strong></h4><ul>
<li>将下载的资源存储到指定路径，覆盖旧版本文件。</li>
<li>更新本地的版本文件。</li>
</ul>
<hr>
<h3 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a><strong>4. 示例代码</strong></h3><p>以下是一个热更新版本检查的示例代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Networking;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HotUpdateManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> serverVersionUrl = <span class="string">&quot;https://example.com/version.json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> localVersionPath = Application.persistentDataPath + <span class="string">&quot;/version.json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> serverAssetBaseUrl = <span class="string">&quot;https://example.com/assets/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Step 1: 获取服务器版本文件</span></span><br><span class="line">        UnityWebRequest request = UnityWebRequest.Get(serverVersionUrl);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> request.SendWebRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.result != UnityWebRequest.Result.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;Failed to fetch version.json: &quot;</span> + request.error);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> serverVersionContent = request.downloadHandler.text;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Server Version: &quot;</span> + serverVersionContent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 2: 检查本地版本文件</span></span><br><span class="line">        <span class="keyword">if</span> (!File.Exists(localVersionPath))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Local version.json not found, downloading all assets...&quot;</span>);</span><br><span class="line">            StartCoroutine(DownloadAllAssets(serverVersionContent));</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> localVersionContent = File.ReadAllText(localVersionPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 3: 比较版本号或文件哈希值</span></span><br><span class="line">        <span class="keyword">if</span> (serverVersionContent != localVersionContent)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Version mismatch, updating assets...&quot;</span>);</span><br><span class="line">            StartCoroutine(DownloadAllAssets(serverVersionContent));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Assets are up-to-date.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">DownloadAllAssets</span>(<span class="params"><span class="built_in">string</span> serverVersionContent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 假设服务器版本文件包含资源列表</span></span><br><span class="line">        <span class="keyword">var</span> versionData = JsonUtility.FromJson&lt;VersionData&gt;(serverVersionContent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> asset <span class="keyword">in</span> versionData.assetBundles)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> assetUrl = serverAssetBaseUrl + asset.Key;</span><br><span class="line">            <span class="built_in">string</span> localPath = Path.Combine(Application.persistentDataPath, asset.Key);</span><br><span class="line"></span><br><span class="line">            UnityWebRequest assetRequest = UnityWebRequest.Get(assetUrl);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> assetRequest.SendWebRequest();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (assetRequest.result == UnityWebRequest.Result.Success)</span><br><span class="line">            &#123;</span><br><span class="line">                File.WriteAllBytes(localPath, assetRequest.downloadHandler.data);</span><br><span class="line">                Debug.Log(<span class="string">$&quot;Downloaded: <span class="subst">&#123;asset.Key&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(<span class="string">$&quot;Failed to download: <span class="subst">&#123;asset.Key&#125;</span>, Error: <span class="subst">&#123;assetRequest.error&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存最新版本文件到本地</span></span><br><span class="line">        File.WriteAllText(localVersionPath, serverVersionContent);</span><br><span class="line">        Debug.Log(<span class="string">&quot;Assets updated successfully.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VersionData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> version;</span><br><span class="line">    <span class="keyword">public</span> System.Collections.Generic.Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; assetBundles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-注意事项-1"><a href="#5-注意事项-1" class="headerlink" title="5. 注意事项"></a><strong>5. 注意事项</strong></h3><ol>
<li><p><strong>CDN 缓存问题</strong>：</p>
<ul>
<li>如果资源托管在 CDN 上，确保启用强缓存控制（如 ETag 或版本号后缀）。</li>
</ul>
</li>
<li><p><strong>断点续传</strong>：</p>
<ul>
<li>对于大文件下载，可以实现断点续传功能，以防网络中断。</li>
</ul>
</li>
<li><p><strong>资源替换时机</strong>：</p>
<ul>
<li>确保在游戏加载完成或空闲时替换资源，避免资源被占用导致更新失败。</li>
</ul>
</li>
<li><p><strong>安全性</strong>：</p>
<ul>
<li>对下载的资源文件进行校验，防止中间人攻击或恶意篡改文件。</li>
</ul>
</li>
</ol>
<hr>
<p>通过这种方式，可以高效地判断客户端是否需要热更新，并确保资源和代码是最新版本。</p>
<h1 id="HybridCLR-是如何删除弃用的业务逻辑"><a href="#HybridCLR-是如何删除弃用的业务逻辑" class="headerlink" title="HybridCLR 是如何删除弃用的业务逻辑"></a>HybridCLR 是如何删除弃用的业务逻辑</h1><p>在 <strong>HybridCLR</strong> 的热更新机制下，C# 代码的更新是通过<strong>替换 DLL</strong> 来实现的，而不是像 Lua 那样直接修改脚本文件。因此，在<strong>删除废弃的业务逻辑</strong>时，需要从<strong>逻辑层面</strong>和<strong>文件层面</strong>两部分处理。</p>
<hr>
<h1 id="1-逻辑层面：卸载废弃的代码"><a href="#1-逻辑层面：卸载废弃的代码" class="headerlink" title="1. 逻辑层面：卸载废弃的代码"></a><strong>1. 逻辑层面：卸载废弃的代码</strong></h1><p>即使热更新加载了新版本的 DLL，旧版本的类、方法仍可能<strong>被引用或驻留在内存中</strong>，需要确保：</p>
<ol>
<li><strong>不再调用旧代码</strong></li>
<li><strong>清理旧 DLL 占用的资源</strong></li>
<li><strong>避免旧代码仍在运行</strong>（例如事件监听、线程、静态变量等）</li>
</ol>
<h3 id="（1）移除已加载的废弃类"><a href="#（1）移除已加载的废弃类" class="headerlink" title="（1）移除已加载的废弃类"></a><strong>（1）移除已加载的废弃类</strong></h3><p>HybridCLR 通过 <strong>Assembly.Load()</strong> 加载新的 DLL，默认情况下，<strong>已加载的类不会自动卸载</strong>。所以要确保：</p>
<ul>
<li><strong>不再引用废弃代码</strong></li>
<li><strong>手动移除相关的对象</strong></li>
</ul>
<p><strong>示例：清理废弃类</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 让 C# 运行时不再持有旧逻辑的引用</span></span><br><span class="line">OldLogic.Instance = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="（2）清理静态变量-事件监听"><a href="#（2）清理静态变量-事件监听" class="headerlink" title="（2）清理静态变量 &amp; 事件监听"></a><strong>（2）清理静态变量 &amp; 事件监听</strong></h3><p>如果有<strong>静态变量</strong>持有废弃类的实例，必须手动清理：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">OldLogic.StaticInstance = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>如果有<strong>事件监听</strong>，需要取消：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">EventManager.OnEvent -= OldLogic.HandleEvent;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="（3）释放旧-DLL"><a href="#（3）释放旧-DLL" class="headerlink" title="（3）释放旧 DLL"></a><strong>（3）释放旧 DLL</strong></h3><p>.NET Core&#x2F;Mono <strong>不支持卸载单个 DLL</strong>，但可以<strong>更换 AppDomain</strong> 来隔离和卸载：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 彻底卸载 HybridCLR 加载的所有热更 DLL</span></span><br><span class="line">HybridCLR.RuntimeApi.UnloadHotUpdateAssemblies();</span><br></pre></td></tr></table></figure>
<p>但 HybridCLR 目前 <strong>不支持完全卸载 DLL</strong>，如果有大版本更新，建议直接<strong>重启进程</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Application.Quit();</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="2-文件层面：删除废弃的-DLL"><a href="#2-文件层面：删除废弃的-DLL" class="headerlink" title="2. 文件层面：删除废弃的 DLL"></a><strong>2. 文件层面：删除废弃的 DLL</strong></h1><p>HybridCLR 的热更 DLL 一般存放在 <strong>PersistentDataPath</strong> 目录，需要手动删除：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> oldDllPath = Path.Combine(Application.persistentDataPath, <span class="string">&quot;HotUpdate.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (File.Exists(oldDllPath))</span><br><span class="line">&#123;</span><br><span class="line">    File.Delete(oldDllPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 DLL 是从 <strong>远程服务器下载的</strong>，可以在更新时<strong>只下载新版本的 DLL</strong>，同时清理旧 DLL。</p>
<p><strong>示例：删除所有旧 DLL</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> hotfixPath = Path.Combine(Application.persistentDataPath, <span class="string">&quot;hotfix&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (Directory.Exists(hotfixPath))</span><br><span class="line">&#123;</span><br><span class="line">    Directory.Delete(hotfixPath, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="3-如何彻底卸载旧业务逻辑"><a href="#3-如何彻底卸载旧业务逻辑" class="headerlink" title="3. 如何彻底卸载旧业务逻辑"></a><strong>3. 如何彻底卸载旧业务逻辑</strong></h1><p><strong>如果 HybridCLR 不能卸载 DLL，怎样才能彻底移除旧代码？</strong></p>
<h3 id="方案-1：重启进程"><a href="#方案-1：重启进程" class="headerlink" title="方案 1：重启进程"></a><strong>方案 1：重启进程</strong></h3><p>由于 .NET 运行时不能单独卸载某个 DLL，<strong>最干净的做法</strong>是<strong>更新完成后，直接重启游戏</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Application.Quit();  <span class="comment">// 退出游戏</span></span><br></pre></td></tr></table></figure>
<p>然后下次启动时，加载最新的 DLL，而不会保留旧逻辑。</p>
<hr>
<h3 id="方案-2：使用不同-Assembly-加载-DLL"><a href="#方案-2：使用不同-Assembly-加载-DLL" class="headerlink" title="方案 2：使用不同 Assembly 加载 DLL"></a><strong>方案 2：使用不同 Assembly 加载 DLL</strong></h3><p>HybridCLR <strong>支持加载多个版本的 DLL</strong>，可以：</p>
<ol>
<li><strong>每次热更加载不同的 DLL（如 <code>HotUpdate_v2.dll</code>）</strong></li>
<li><strong>旧 DLL 永远不会被新代码访问</strong></li>
<li><strong>新 DLL 替换旧逻辑后，旧 DLL 文件可删除</strong></li>
</ol>
<p>示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> assembly = Assembly.Load(File.ReadAllBytes(<span class="string">&quot;HotUpdate_v2.dll&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>然后把旧 DLL 从 <code>PersistentDataPath</code> 中删除。</p>
<hr>
<h1 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a><strong>总结</strong></h1><table>
<thead>
<tr>
<th>操作</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>停止旧逻辑运行</strong></td>
<td>解除引用 (<code>OldLogic.Instance = null</code>)，取消事件监听</td>
</tr>
<tr>
<td><strong>清理静态变量</strong></td>
<td><code>OldLogic.StaticInstance = null;</code></td>
</tr>
<tr>
<td><strong>卸载热更 DLL</strong></td>
<td><code>HybridCLR.RuntimeApi.UnloadHotUpdateAssemblies();</code></td>
</tr>
<tr>
<td><strong>删除旧 DLL 文件</strong></td>
<td><code>File.Delete(path)</code></td>
</tr>
<tr>
<td><strong>彻底清除</strong></td>
<td><strong>重启游戏 (<code>Application.Quit()</code>)</strong></td>
</tr>
</tbody></table>
<p><strong>推荐方案</strong></p>
<ul>
<li><strong>小版本热更</strong>：用 <code>UnloadHotUpdateAssemblies()</code> 释放旧 DLL，并删除旧文件。</li>
<li><strong>大版本更新</strong>：直接 <code>Application.Quit()</code> 重启游戏，确保所有旧代码彻底清除。</li>
</ul>
<hr>
<p>你目前是想<strong>小规模热修</strong>（尽量不停游戏），还是<strong>大版本更新</strong>（可以重启）？</p>
<h1 id="划分程序集-1"><a href="#划分程序集-1" class="headerlink" title="划分程序集"></a>划分程序集</h1><p>在你的 <strong>游戏厅（Game Hub）</strong> 项目中，每个小游戏都可能是<strong>独立的业务模块</strong>，为了<strong>支持随时下架、更新或新增游戏</strong>，你需要合理划分 <strong>Assembly</strong> 并采用 <strong>插件式架构</strong>，使得每个游戏都可以<strong>独立加载、卸载</strong>，从而实现灵活管理。  </p>
<hr>
<h1 id="1-Assembly-划分方案"><a href="#1-Assembly-划分方案" class="headerlink" title="1. Assembly 划分方案"></a><strong>1. Assembly 划分方案</strong></h1><p>建议将项目拆分成多个 <strong>Assembly</strong>（DLL），核心划分如下：  </p>
<h3 id="（1）主程序-Assembly（GameHub-dll）"><a href="#（1）主程序-Assembly（GameHub-dll）" class="headerlink" title="（1）主程序 Assembly（GameHub.dll）"></a><strong>（1）主程序 Assembly（GameHub.dll）</strong></h3><ul>
<li>负责 <strong>游戏大厅的管理</strong>（UI、网络、用户数据、支付等）</li>
<li><strong>不会变动</strong>，不随小游戏更新而修改</li>
<li>只负责 <strong>加载&#x2F;卸载 子游戏 DLL</strong></li>
</ul>
<h3 id="（2）小游戏-Assembly（GameA-dll、GameB-dll…）"><a href="#（2）小游戏-Assembly（GameA-dll、GameB-dll…）" class="headerlink" title="（2）小游戏 Assembly（GameA.dll、GameB.dll…）"></a><strong>（2）小游戏 Assembly（GameA.dll、GameB.dll…）</strong></h3><ul>
<li><strong>每个游戏单独一个 DLL</strong>，如 <code>GameA.dll</code>、<code>GameB.dll</code></li>
<li>游戏代码、资源、逻辑<strong>完全封装</strong>在该 DLL 中</li>
<li>可以<strong>单独卸载、更新或删除</strong></li>
</ul>
<h3 id="（3）公共-Assembly（Common-dll）"><a href="#（3）公共-Assembly（Common-dll）" class="headerlink" title="（3）公共 Assembly（Common.dll）"></a><strong>（3）公共 Assembly（Common.dll）</strong></h3><ul>
<li>存放 <strong>共享逻辑、工具方法</strong></li>
<li>避免每个小游戏重复代码</li>
<li>例如：<ul>
<li><strong>网络通信模块</strong></li>
<li><strong>UI 基础组件</strong></li>
<li><strong>工具类（日志、数学计算等）</strong></li>
</ul>
</li>
</ul>
<p><strong>📌 关键点</strong>：</p>
<ul>
<li><strong>每个小游戏必须独立</strong>（即 <strong>不引用其他游戏</strong>，避免删除时影响其他游戏）。</li>
<li><strong>小游戏之间通过接口通信</strong>，而不是直接调用代码。</li>
</ul>
<hr>
<h1 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2. 具体实现"></a><strong>2. 具体实现</strong></h1><h3 id="（1）小游戏代码结构"><a href="#（1）小游戏代码结构" class="headerlink" title="（1）小游戏代码结构"></a><strong>（1）小游戏代码结构</strong></h3><p>示例：<code>GameA.dll</code>  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameA</span> : <span class="title">IGameModule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartGame</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Game A 启动&quot;</span>);</span><br><span class="line">        <span class="comment">// 游戏逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopGame</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Game A 结束&quot;</span>);</span><br><span class="line">        <span class="comment">// 清理资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）定义通用接口（GameHub-统一管理）"><a href="#（2）定义通用接口（GameHub-统一管理）" class="headerlink" title="（2）定义通用接口（GameHub 统一管理）"></a><strong>（2）定义通用接口（GameHub 统一管理）</strong></h3><h2 id="主程序-GameHub-dll-只认识-接口，不依赖具体游戏："><a href="#主程序-GameHub-dll-只认识-接口，不依赖具体游戏：" class="headerlink" title="主程序 GameHub.dll 只认识 接口，不依赖具体游戏："></a>主程序 <code>GameHub.dll</code> 只认识 <strong>接口</strong>，不依赖具体游戏：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IGameModule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StartGame</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StopGame</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h3 id="（3）动态加载游戏（按需加载-DLL）"><a href="#（3）动态加载游戏（按需加载-DLL）" class="headerlink" title="（3）动态加载游戏（按需加载 DLL）"></a><strong>（3）动态加载游戏（按需加载 DLL）</strong></h3><p><strong>📌 核心逻辑：</strong>  </p>
<ul>
<li><strong>GameHub.dll 负责加载&#x2F;卸载游戏</strong></li>
<li><strong>从 <code>PersistentDataPath</code> 读取新的游戏 DLL</strong></li>
<li><strong>实例化 <code>IGameModule</code>，运行游戏</strong></li>
</ul>
<h4 id="✅-加载游戏"><a href="#✅-加载游戏" class="headerlink" title="✅ 加载游戏"></a><strong>✅ 加载游戏</strong></h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IGameModule <span class="title">LoadGame</span>(<span class="params"><span class="built_in">string</span> gameName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> path = Path.Combine(Application.persistentDataPath, <span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!File.Exists(path))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="string">$&quot;找不到 <span class="subst">&#123;path&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">byte</span>[] dllBytes = File.ReadAllBytes(path);</span><br><span class="line">    Assembly assembly = Assembly.Load(dllBytes);</span><br><span class="line"></span><br><span class="line">    Type gameType = assembly.GetType(<span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>.GameMain&quot;</span>); <span class="comment">// 确保游戏类符合命名规则</span></span><br><span class="line">    <span class="keyword">if</span> (gameType == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span> 里没有 GameMain 类&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Activator.CreateInstance(gameType) <span class="keyword">as</span> IGameModule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅-运行游戏"><a href="#✅-运行游戏" class="headerlink" title="✅ 运行游戏"></a><strong>✅ 运行游戏</strong></h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">IGameModule currentGame = LoadGame(<span class="string">&quot;GameA&quot;</span>);</span><br><span class="line">currentGame?.StartGame();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="（4）删除-下架游戏"><a href="#（4）删除-下架游戏" class="headerlink" title="（4）删除&#x2F;下架游戏"></a><strong>（4）删除&#x2F;下架游戏</strong></h3><p>当 <strong>游戏下架</strong> 时，需要：</p>
<ol>
<li><strong>停止该游戏</strong></li>
<li><strong>卸载 DLL</strong></li>
<li><strong>删除文件</strong></li>
</ol>
<p><strong>✅ 停止游戏并清理</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentGame != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    currentGame.StopGame();</span><br><span class="line">    currentGame = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>✅ 删除 DLL 文件</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> gamePath = Path.Combine(Application.persistentDataPath, <span class="string">&quot;GameA.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (File.Exists(gamePath))</span><br><span class="line">&#123;</span><br><span class="line">    File.Delete(gamePath);</span><br><span class="line">    Debug.Log(<span class="string">&quot;GameA 已删除&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="⚠️-注意-由于-C-不支持卸载单个-DLL，建议：-加载时使用不同-Assembly，避免占用-删除后，建议重启游戏进程"><a href="#⚠️-注意-由于-C-不支持卸载单个-DLL，建议：-加载时使用不同-Assembly，避免占用-删除后，建议重启游戏进程" class="headerlink" title="⚠️ 注意- 由于 C# 不支持卸载单个 DLL，建议：  - 加载时使用不同 Assembly，避免占用  - 删除后，建议重启游戏进程
  "></a><strong>⚠️ 注意</strong><br>- 由于 C# <strong>不支持卸载单个 DLL</strong>，建议：<br>  - <strong>加载时使用不同 Assembly</strong>，避免占用<br>  - <strong>删除后，建议重启游戏进程</strong>
  </h2><h3 id="（5）游戏更新"><a href="#（5）游戏更新" class="headerlink" title="（5）游戏更新"></a><strong>（5）游戏更新</strong></h3><p><strong>1. 服务器推送新版本 <code>GameA_v2.dll</code></strong><br><strong>2. 替换 <code>GameA.dll</code> 并加载新 DLL</strong><br><strong>3. 调用 <code>StopGame()</code> 关闭旧版本</strong><br><strong>4. 重新加载新版本 <code>GameA</code> 并运行</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> oldPath = Path.Combine(Application.persistentDataPath, <span class="string">&quot;GameA.dll&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> newPath = Path.Combine(Application.persistentDataPath, <span class="string">&quot;GameA_v2.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (File.Exists(oldPath)) File.Delete(oldPath);</span><br><span class="line">File.Move(newPath, oldPath);</span><br><span class="line"></span><br><span class="line">IGameModule currentGame = LoadGame(<span class="string">&quot;GameA&quot;</span>);</span><br><span class="line">currentGame?.StartGame();</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="3-HybridCLR-支持点"><a href="#3-HybridCLR-支持点" class="headerlink" title="3. HybridCLR 支持点"></a><strong>3. HybridCLR 支持点</strong></h1><p><strong>HybridCLR 主要用于支持</strong>：</p>
<ol>
<li><strong>运行 IL2CPP 下的热更 C# 代码</strong></li>
<li><strong>动态加载 C# DLL</strong></li>
<li><strong>支持在 iOS&#x2F;Android&#x2F;WebGL 运行 C# 热更代码</strong></li>
</ol>
<p>你可以使用 HybridCLR <strong>动态加载和替换游戏 DLL</strong>，但要注意：</p>
<ul>
<li><strong>不支持完全卸载 DLL</strong>，所以游戏下架后<strong>最好重启进程</strong>清理内存。</li>
<li><strong>要确保新 DLL 兼容老的 <code>IGameModule</code> 接口</strong>，否则会崩溃。</li>
</ul>
<hr>
<h1 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h1><table>
<thead>
<tr>
<th>方案</th>
<th>方案描述</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>每个小游戏一个 DLL</strong></td>
<td>每个游戏 <code>GameA.dll</code>、<code>GameB.dll</code> 独立，主程序动态加载&#x2F;卸载</td>
<td>适合有多个小游戏、可随时更新</td>
</tr>
<tr>
<td><strong>统一管理接口 <code>IGameModule</code></strong></td>
<td>只在 <code>GameHub.dll</code> 里使用 <code>IGameModule</code>，防止硬编码依赖</td>
<td>让 <code>GameHub</code> 代码更稳定，减少改动</td>
</tr>
<tr>
<td><strong>热更新游戏</strong></td>
<td>服务器推送 <code>GameA_v2.dll</code>，删除 <code>GameA.dll</code>，然后重新加载</td>
<td>适合定期更新游戏内容</td>
</tr>
<tr>
<td><strong>下架游戏</strong></td>
<td><code>StopGame()</code> 清理资源，删除 <code>GameA.dll</code>，并建议重启游戏</td>
<td>适合游戏随时下架</td>
</tr>
</tbody></table>
<hr>
<h1 id="5-你接下来的问题"><a href="#5-你接下来的问题" class="headerlink" title="5. 你接下来的问题"></a><strong>5. 你接下来的问题</strong></h1><p>你是更关注 <strong>如何加载&#x2F;卸载 DLL</strong>，还是想了解 <strong>HybridCLR 在不同平台（iOS&#x2F;Android&#x2F;WebGL）的兼容性</strong>？</p>
<h1 id="公共程序集为啥不能与主程序集合并"><a href="#公共程序集为啥不能与主程序集合并" class="headerlink" title="公共程序集为啥不能与主程序集合并"></a>公共程序集为啥不能与主程序集合并</h1><h3 id="1-公共-Assembly-是否可以合并到主程序-Assembly？"><a href="#1-公共-Assembly-是否可以合并到主程序-Assembly？" class="headerlink" title="1. 公共 Assembly 是否可以合并到主程序 Assembly？"></a><strong>1. 公共 Assembly 是否可以合并到主程序 Assembly？</strong></h3><p><strong>✅ 可以合并</strong>，但不推荐，具体情况如下：  </p>
<table>
<thead>
<tr>
<th>方案</th>
<th>适用场景</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>合并到主程序 (GameHub.dll)</strong></td>
<td><strong>小型项目，功能较少</strong></td>
<td>结构简单，减少 DLL 数量</td>
<td>不能动态更新公共逻辑，每次修改都要重打主包</td>
</tr>
<tr>
<td><strong>独立公共 Assembly (Common.dll)</strong></td>
<td><strong>大型项目，多个游戏共享逻辑</strong></td>
<td>允许热更新公共代码，减少主程序改动</td>
<td>需要管理额外的 DLL</td>
</tr>
</tbody></table>
<p><strong>📌 建议</strong></p>
<ul>
<li><strong>如果项目较小（比如只有几个小游戏）</strong>，可以把 <strong>公共代码</strong> 合并到 <code>GameHub.dll</code>，减少 DLL 数量。</li>
<li><strong>如果项目较大（支持几十款游戏）</strong>，推荐<strong>拆分 <code>Common.dll</code><strong>，让公共逻辑独立，这样</strong>既能复用，也能热更新</strong>。</li>
</ul>
<hr>
<h3 id="2-Assembly-与-AssetBundle（AB-包）如何关联？"><a href="#2-Assembly-与-AssetBundle（AB-包）如何关联？" class="headerlink" title="2. Assembly 与 AssetBundle（AB 包）如何关联？"></a><strong>2. Assembly 与 AssetBundle（AB 包）如何关联？</strong></h3><p>在 <strong>Unity 资源管理</strong> 中，<code>Assembly</code>（DLL）和 <code>AssetBundle</code>（AB包）是 <strong>两个独立的概念</strong>，但可以<strong>配合使用</strong>。</p>
<h4 id="（1）如何关联？"><a href="#（1）如何关联？" class="headerlink" title="（1）如何关联？"></a><strong>（1）如何关联？</strong></h4><table>
<thead>
<tr>
<th>目标</th>
<th>方案</th>
</tr>
</thead>
<tbody><tr>
<td><strong>热更新代码</strong></td>
<td><strong>放入 <code>DLL</code>，用 HybridCLR 动态加载</strong></td>
</tr>
<tr>
<td><strong>热更新资源（Prefab、材质等）</strong></td>
<td><strong>打成 <code>AB包</code>，运行时下载 &amp; 加载</strong></td>
</tr>
</tbody></table>
<h4 id="（2）示例：游戏-GameA-结构"><a href="#（2）示例：游戏-GameA-结构" class="headerlink" title="（2）示例：游戏 GameA 结构"></a><strong>（2）示例：游戏 <code>GameA</code> 结构</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">📁 GameA 资源包</span><br><span class="line">├── GameA.dll            // 游戏代码</span><br><span class="line">├── GameA_Assets.ab      // 该游戏的资源（Prefab、材质）</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-具体如何管理-DLL-和-AB-包？"><a href="#3-具体如何管理-DLL-和-AB-包？" class="headerlink" title="3. 具体如何管理 DLL 和 AB 包？"></a><strong>3. 具体如何管理 DLL 和 AB 包？</strong></h3><p><strong>✅ 推荐管理方式：</strong></p>
<ol>
<li><strong>每个游戏一个 DLL + 一个 AB 包</strong></li>
<li><strong>服务器维护 <code>version.json</code> 文件，管理最新版本</strong></li>
<li><strong>客户端比对 <code>version.json</code>，决定是否下载更新</strong></li>
<li><strong>动态加载新 DLL 和 AB 包</strong></li>
</ol>
<hr>
<h3 id="4-AB-包与-DLL-的加载代码"><a href="#4-AB-包与-DLL-的加载代码" class="headerlink" title="4. AB 包与 DLL 的加载代码"></a><strong>4. AB 包与 DLL 的加载代码</strong></h3><p>📌 <strong>示例：同时加载 <code>GameA.dll</code> 和 <code>GameA_Assets.ab</code></strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">LoadGame</span>(<span class="params"><span class="built_in">string</span> gameName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> dllPath = Path.Combine(Application.persistentDataPath, <span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>.dll&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> abPath = Path.Combine(Application.persistentDataPath, <span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>_Assets.ab&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 先加载 DLL</span></span><br><span class="line">    <span class="built_in">byte</span>[] dllBytes = File.ReadAllBytes(dllPath);</span><br><span class="line">    Assembly assembly = Assembly.Load(dllBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 再加载 AB 包</span></span><br><span class="line">    AssetBundle ab = AssetBundle.LoadFromFile(abPath);</span><br><span class="line">    <span class="keyword">if</span> (ab == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="string">&quot;AB 包加载失败：&quot;</span> + abPath);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 实例化游戏主逻辑</span></span><br><span class="line">    Type gameType = assembly.GetType(<span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>.GameMain&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (gameType != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        IGameModule gameInstance = Activator.CreateInstance(gameType) <span class="keyword">as</span> IGameModule;</span><br><span class="line">        gameInstance?.StartGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-热更新时，如何删除废弃的-DLL-和-AB？"><a href="#5-热更新时，如何删除废弃的-DLL-和-AB？" class="headerlink" title="5. 热更新时，如何删除废弃的 DLL 和 AB？"></a><strong>5. 热更新时，如何删除废弃的 DLL 和 AB？</strong></h3><p>当游戏 <strong>下架</strong> 或 <strong>更新版本时</strong>，需要删除旧的 DLL 和 AB 文件：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeleteOldGame</span>(<span class="params"><span class="built_in">string</span> gameName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> dllPath = Path.Combine(Application.persistentDataPath, <span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>.dll&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> abPath = Path.Combine(Application.persistentDataPath, <span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>_Assets.ab&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(dllPath))</span><br><span class="line">    &#123;</span><br><span class="line">        File.Delete(dllPath);</span><br><span class="line">        Debug.Log(<span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>.dll 已删除&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(abPath))</span><br><span class="line">    &#123;</span><br><span class="line">        File.Delete(abPath);</span><br><span class="line">        Debug.Log(<span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>_Assets.ab 已删除&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h3><table>
<thead>
<tr>
<th>方案</th>
<th>是否推荐</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>公共 Assembly 合并到主程序</strong></td>
<td>❌ <strong>不推荐</strong></td>
<td>不能热更新公共逻辑，改动大</td>
</tr>
<tr>
<td><strong>公共 Assembly 独立 (<code>Common.dll</code>)</strong></td>
<td>✅ <strong>推荐</strong></td>
<td>允许热更新公共代码，减少主程序改动</td>
</tr>
<tr>
<td><strong>DLL 与 AB 包管理</strong></td>
<td>✅ <strong>推荐</strong></td>
<td><strong>游戏代码</strong>放 <code>DLL</code>，<strong>资源</strong>放 <code>AB</code>，分别热更新</td>
</tr>
<tr>
<td><strong>游戏下架时删除 <code>DLL + AB</code></strong></td>
<td>✅ <strong>推荐</strong></td>
<td>确保游戏<strong>彻底卸载</strong>，避免浪费存储</td>
</tr>
</tbody></table>
<p><strong>🔥 你可以根据项目大小选择合适的管理方式，整体来说独立 DLL 和 AB 包管理是最佳方案！</strong> 🚀</p>
<h1 id="热更新的最佳时机和界面选择"><a href="#热更新的最佳时机和界面选择" class="headerlink" title="热更新的最佳时机和界面选择"></a><strong>热更新的最佳时机和界面选择</strong></h1><p>在 Unity 使用 <strong>HybridCLR</strong> 进行热更新时，选择合适的更新时机和界面非常重要，否则可能导致<strong>游戏崩溃</strong>、<strong>逻辑异常</strong>或<strong>资源丢失</strong>。以下是最佳实践：</p>
<hr>
<h2 id="1-热更新的最佳时机"><a href="#1-热更新的最佳时机" class="headerlink" title="1. 热更新的最佳时机"></a><strong>1. 热更新的最佳时机</strong></h2><p>📌 <strong>建议在“非交互”状态下进行更新</strong>，避免玩家正在操作时导致异常：<br>✅ <strong>推荐的时机：</strong></p>
<ul>
<li><strong>游戏启动时</strong>（Splash&#x2F;Loading 界面）</li>
<li><strong>进入主界面前</strong>（下载完资源后进入大厅）</li>
<li><strong>玩家进入游戏前</strong>（在“游戏选择”界面检查更新）</li>
<li><strong>切换大场景时</strong>（如从大厅进入副本&#x2F;新地图）</li>
<li><strong>后台运行时</strong>（玩家暂时离开游戏）</li>
</ul>
<p>❌ <strong>避免在以下情况下更新：</strong></p>
<ul>
<li><strong>游戏进行中</strong>（玩家正在战斗、跑图时更新会导致闪退）</li>
<li><strong>正在加载资源时</strong>（影响加载稳定性）</li>
<li><strong>与服务器交互中</strong>（如果协议更新了但旧逻辑仍在运行，可能导致同步失败）</li>
</ul>
<hr>
<h2 id="2-热更新时的界面选择"><a href="#2-热更新时的界面选择" class="headerlink" title="2. 热更新时的界面选择"></a><strong>2. 热更新时的界面选择</strong></h2><p>📌 <strong>推荐使用“过渡界面”或“更新提示界面”</strong></p>
<table>
<thead>
<tr>
<th><strong>界面类型</strong></th>
<th><strong>是否推荐</strong></th>
<th><strong>理由</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>独立更新界面</strong>（如“正在更新”）</td>
<td>✅ <strong>推荐</strong></td>
<td>提示用户更新进度，防止误操作</td>
</tr>
<tr>
<td><strong>游戏启动界面</strong>（Logo、Loading）</td>
<td>✅ <strong>推荐</strong></td>
<td>最安全，不影响正常游戏流程</td>
</tr>
<tr>
<td><strong>游戏大厅（非交互状态）</strong></td>
<td>✅ <strong>推荐</strong></td>
<td>适用于“在线更新”</td>
</tr>
<tr>
<td><strong>游戏进行中（战斗、副本）</strong></td>
<td>❌ <strong>不推荐</strong></td>
<td>影响玩家体验，容易崩溃</td>
</tr>
<tr>
<td><strong>UI弹窗提醒更新</strong></td>
<td>⚠ <strong>谨慎</strong></td>
<td>适用于小补丁，不适用于大版本更新</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-具体热更新流程"><a href="#3-具体热更新流程" class="headerlink" title="3. 具体热更新流程"></a><strong>3. 具体热更新流程</strong></h2><p>📌 <strong>示例：在“游戏大厅”进行更新</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">CheckForUpdates</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 显示更新界面</span></span><br><span class="line">    UIManager.Instance.ShowUpdatePanel(<span class="string">&quot;正在检查更新...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 下载最新的版本信息</span></span><br><span class="line">    <span class="built_in">string</span> versionUrl = <span class="string">&quot;https://server.com/version.json&quot;</span>;</span><br><span class="line">    UnityWebRequest request = UnityWebRequest.Get(versionUrl);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> request.SendWebRequest();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.result == UnityWebRequest.Result.Success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> versionData = request.downloadHandler.text;</span><br><span class="line">        VersionInfo newVersion = JsonUtility.FromJson&lt;VersionInfo&gt;(versionData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 比对当前版本</span></span><br><span class="line">        <span class="keyword">if</span> (newVersion.version != currentVersion)</span><br><span class="line">        &#123;</span><br><span class="line">            UIManager.Instance.ShowUpdatePanel(<span class="string">&quot;发现新版本，开始更新...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 下载新 DLL 和 AB 包</span></span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">DownloadAndReplace</span>(<span class="params">newVersion</span>)</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5. 更新完成后提示玩家重启</span></span><br><span class="line">            UIManager.Instance.ShowUpdatePanel(<span class="string">&quot;更新完成，请重启游戏！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-避免问题的关键"><a href="#4-避免问题的关键" class="headerlink" title="4. 避免问题的关键"></a><strong>4. 避免问题的关键</strong></h2><h3 id="✅-关键点-1：更新时切断交互"><a href="#✅-关键点-1：更新时切断交互" class="headerlink" title="✅ 关键点 1：更新时切断交互"></a><strong>✅ 关键点 1：更新时切断交互</strong></h3><ul>
<li><strong>更新期间</strong>禁用按钮、滑动等操作，防止玩家误触</li>
<li><strong>建议锁定 UI 操作</strong>，直到更新完成</li>
</ul>
<h3 id="✅-关键点-2：分批更新"><a href="#✅-关键点-2：分批更新" class="headerlink" title="✅ 关键点 2：分批更新"></a><strong>✅ 关键点 2：分批更新</strong></h3><ul>
<li>如果 <strong>游戏大厅 + 多个小游戏</strong>：<ul>
<li><strong>主程序 DLL</strong> 在启动时更新</li>
<li><strong>小游戏 DLL &amp; 资源</strong> 在游戏选择时更新</li>
</ul>
</li>
</ul>
<h3 id="✅-关键点-3：更新后强制重启"><a href="#✅-关键点-3：更新后强制重启" class="headerlink" title="✅ 关键点 3：更新后强制重启"></a><strong>✅ 关键点 3：更新后强制重启</strong></h3><ul>
<li>HybridCLR <strong>不能直接替换运行中的 DLL</strong></li>
<li>更新完成后，需要 <strong>重新启动游戏</strong>，加载新 DLL<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RestartGame</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 退出游戏并重新启动</span></span><br><span class="line">    Application.Quit();</span><br><span class="line">    System.Diagnostics.Process.Start(Application.dataPath.Replace(<span class="string">&quot;_Data&quot;</span>, <span class="string">&quot;.exe&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a><strong>5. 结论</strong></h2><table>
<thead>
<tr>
<th><strong>问题</strong></th>
<th><strong>解决方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>什么时候更新？</strong></td>
<td><strong>游戏启动 &#x2F; 进入大厅 &#x2F; 切换大场景</strong></td>
</tr>
<tr>
<td><strong>在哪里更新？</strong></td>
<td><strong>加载界面 &#x2F; 独立更新界面 &#x2F; 游戏大厅</strong></td>
</tr>
<tr>
<td><strong>如何避免错误？</strong></td>
<td><strong>禁用交互、分批更新、更新后强制重启</strong></td>
</tr>
</tbody></table>
<p>这样可以 <strong>最大化避免游戏崩溃</strong>，让玩家平稳地进行热更新。🚀</p>
]]></content>
  </entry>
  <entry>
    <title>Jenkins 游戏后端自动化部署流程</title>
    <url>/2025/05/09/Jenkins%20%E6%B8%B8%E6%88%8F%E5%90%8E%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="Jenkins-游戏后端自动化部署流程（以微服务-分布式架构为例）"><a href="#Jenkins-游戏后端自动化部署流程（以微服务-分布式架构为例）" class="headerlink" title="Jenkins 游戏后端自动化部署流程（以微服务&#x2F;分布式架构为例）"></a><strong>Jenkins 游戏后端自动化部署流程（以微服务&#x2F;分布式架构为例）</strong></h3><p>游戏后端通常采用 <strong>多模块、微服务架构</strong>（如登录服、战斗服、匹配服），Jenkins 可以实现 <strong>代码构建 → 打包 → 测试 → 部署到服务器&#x2F;K8s</strong> 的全流程自动化。  </p>
<hr>
<h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a><strong>1. 环境准备</strong></h2><table>
<thead>
<tr>
<th>工具&#x2F;环境</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Jenkins</strong></td>
<td>CI&#x2F;CD 核心调度平台</td>
</tr>
<tr>
<td><strong>Git</strong></td>
<td>代码版本管理（GitHub&#x2F;GitLab）</td>
</tr>
<tr>
<td><strong>Docker</strong></td>
<td>容器化部署（可选）</td>
</tr>
<tr>
<td><strong>Kubernetes (K8s)</strong></td>
<td>容器编排（适用于分布式后端）</td>
</tr>
<tr>
<td><strong>构建工具</strong></td>
<td>Maven&#x2F;Gradle（Java）、Go Build、Python 虚拟环境等</td>
</tr>
<tr>
<td><strong>部署目标</strong></td>
<td>物理服务器&#x2F;云主机&#x2F;K8s 集群</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-Jenkins-配置"><a href="#2-Jenkins-配置" class="headerlink" title="2. Jenkins 配置"></a><strong>2. Jenkins 配置</strong></h2><h3 id="1-安装必要插件"><a href="#1-安装必要插件" class="headerlink" title="(1) 安装必要插件"></a><strong>(1) 安装必要插件</strong></h3><table>
<thead>
<tr>
<th>插件</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Docker Plugin</strong></td>
<td>构建 Docker 镜像</td>
</tr>
<tr>
<td><strong>Kubernetes Plugin</strong></td>
<td>部署到 K8s</td>
</tr>
<tr>
<td><strong>Pipeline</strong></td>
<td>定义 CI&#x2F;CD 流程</td>
</tr>
<tr>
<td><strong>Publish Over SSH</strong></td>
<td>远程服务器部署</td>
</tr>
<tr>
<td><strong>SonarQube Scanner</strong></td>
<td>代码质量检测（可选）</td>
</tr>
</tbody></table>
<h3 id="2-配置凭据"><a href="#2-配置凭据" class="headerlink" title="(2) 配置凭据"></a><strong>(2) 配置凭据</strong></h3><ul>
<li><strong>Git 仓库访问</strong>（SSH Key 或账号密码）</li>
<li><strong>Docker Hub&#x2F;私有仓库</strong>（推送镜像权限）</li>
<li><strong>服务器 SSH 密钥</strong>（远程部署）</li>
</ul>
<hr>
<h2 id="3-典型-Pipeline-流程（Java-微服务示例）"><a href="#3-典型-Pipeline-流程（Java-微服务示例）" class="headerlink" title="3. 典型 Pipeline 流程（Java 微服务示例）"></a><strong>3. 典型 Pipeline 流程（Java 微服务示例）</strong></h2><p>在项目根目录创建 **<code>Jenkinsfile</code>**，定义多阶段构建：  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    environment &#123;</span><br><span class="line">        <span class="comment">// 微服务模块列表（按需修改）</span></span><br><span class="line">        SERVICES = <span class="string">&quot;auth-service match-service battle-service&quot;</span></span><br><span class="line">        DOCKER_REGISTRY = <span class="string">&quot;registry.yourcompany.com/game-backend&quot;</span></span><br><span class="line">        K8S_NAMESPACE = <span class="string">&quot;game-prod&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        <span class="comment">// 阶段 1：拉取代码</span></span><br><span class="line">        stage(<span class="string">&#x27;Checkout&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                git <span class="attr">branch:</span> <span class="string">&#x27;main&#x27;</span>, <span class="attr">url:</span> <span class="string">&#x27;git@github.com:your-game-backend.git&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段 2：代码检查和单元测试</span></span><br><span class="line">        stage(<span class="string">&#x27;Test&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="comment">// Java 项目示例：运行 Maven 测试</span></span><br><span class="line">                    sh <span class="string">&quot;mvn clean test&quot;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Go 项目示例：</span></span><br><span class="line">                    <span class="comment">// sh &quot;go test ./...&quot;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Python 项目示例：</span></span><br><span class="line">                    <span class="comment">// sh &quot;pytest tests/&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段 3：构建并推送 Docker 镜像</span></span><br><span class="line">        stage(<span class="string">&#x27;Build &amp; Push Docker Image&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="comment">// 遍历所有微服务模块</span></span><br><span class="line">                    SERVICES.split().each &#123; service -&gt;</span><br><span class="line">                        sh <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                            docker build -t $&#123;DOCKER_REGISTRY&#125;/$&#123;service&#125;:$&#123;BUILD_NUMBER&#125; \</span></span><br><span class="line"><span class="string">                                -f $&#123;service&#125;/Dockerfile .</span></span><br><span class="line"><span class="string">                            docker push $&#123;DOCKER_REGISTRY&#125;/$&#123;service&#125;:$&#123;BUILD_NUMBER&#125;</span></span><br><span class="line"><span class="string">                        &quot;&quot;&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段 4：部署到 Kubernetes</span></span><br><span class="line">        stage(<span class="string">&#x27;Deploy to K8s&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="comment">// 使用 kubectl 更新镜像版本</span></span><br><span class="line">                    SERVICES.split().each &#123; service -&gt;</span><br><span class="line">                        sh <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                            kubectl set image deployment/$&#123;service&#125; \</span></span><br><span class="line"><span class="string">                                $&#123;service&#125;=$&#123;DOCKER_REGISTRY&#125;/$&#123;service&#125;:$&#123;BUILD_NUMBER&#125; \</span></span><br><span class="line"><span class="string">                                -n $&#123;K8S_NAMESPACE&#125;</span></span><br><span class="line"><span class="string">                        &quot;&quot;&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段 5：集成测试（可选）</span></span><br><span class="line">        stage(<span class="string">&#x27;Integration Test&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// 运行 Postman/API 测试</span></span><br><span class="line">                sh <span class="string">&quot;newman run tests/api-tests.json&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    post &#123;</span><br><span class="line">        success &#123;</span><br><span class="line">            slackSend <span class="attr">channel:</span> <span class="string">&#x27;#game-dev&#x27;</span>, <span class="attr">message:</span> <span class="string">&quot;后端部署成功: $&#123;BUILD_URL&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        failure &#123;</span><br><span class="line">            emailext <span class="attr">body:</span> <span class="string">&quot;构建失败，请检查日志: $&#123;BUILD_URL&#125;&quot;</span>, <span class="attr">subject:</span> <span class="string">&#x27;Jenkins 构建失败&#x27;</span>, <span class="attr">to:</span> <span class="string">&#x27;devops@yourcompany.com&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-关键步骤详解"><a href="#4-关键步骤详解" class="headerlink" title="4. 关键步骤详解"></a><strong>4. 关键步骤详解</strong></h2><h3 id="1-代码构建（不同语言示例）"><a href="#1-代码构建（不同语言示例）" class="headerlink" title="(1) 代码构建（不同语言示例）"></a><strong>(1) 代码构建（不同语言示例）</strong></h3><table>
<thead>
<tr>
<th>语言</th>
<th>构建命令</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Java (Maven)</strong></td>
<td><code>mvn clean package -DskipTests</code></td>
</tr>
<tr>
<td><strong>Go</strong></td>
<td><code>go build -o bin/server ./cmd/server</code></td>
</tr>
<tr>
<td><strong>Python</strong></td>
<td><code>pip install -r requirements.txt</code></td>
</tr>
</tbody></table>
<h3 id="2-Docker-镜像构建"><a href="#2-Docker-镜像构建" class="headerlink" title="(2) Docker 镜像构建"></a><strong>(2) Docker 镜像构建</strong></h3><p>每个微服务需有自己的 <code>Dockerfile</code>，例如：  </p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Java 微服务示例</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">17</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/auth-service.jar /app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="3-部署方式选择"><a href="#3-部署方式选择" class="headerlink" title="(3) 部署方式选择"></a><strong>(3) 部署方式选择</strong></h3><table>
<thead>
<tr>
<th>部署方式</th>
<th>适用场景</th>
<th>Jenkins 配置</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SSH 直接部署</strong></td>
<td>传统服务器</td>
<td>使用 <code>Publish Over SSH</code> 插件</td>
</tr>
<tr>
<td><strong>Docker Swarm</strong></td>
<td>小型集群</td>
<td><code>docker stack deploy</code></td>
</tr>
<tr>
<td><strong>Kubernetes</strong></td>
<td>生产级集群</td>
<td><code>kubectl set image</code> 或 Helm</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-高级优化方案"><a href="#5-高级优化方案" class="headerlink" title="5. 高级优化方案"></a><strong>5. 高级优化方案</strong></h2><h3 id="1-蓝绿部署（Zero-Downtime）"><a href="#1-蓝绿部署（Zero-Downtime）" class="headerlink" title="(1) 蓝绿部署（Zero Downtime）"></a><strong>(1) 蓝绿部署（Zero Downtime）</strong></h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">stage(<span class="string">&#x27;Blue-Green Deployment&#x27;</span>) &#123;</span><br><span class="line">    steps &#123;</span><br><span class="line">        script &#123;</span><br><span class="line">            <span class="comment">// 1. 部署新版本（Green）</span></span><br><span class="line">            sh <span class="string">&quot;kubectl apply -f k8s/green-deployment.yaml&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 切换流量</span></span><br><span class="line">            sh <span class="string">&quot;kubectl apply -f k8s/switch-traffic.yaml&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 清理旧版本（Blue）</span></span><br><span class="line">            sh <span class="string">&quot;kubectl delete -f k8s/blue-deployment.yaml&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-动态伸缩"><a href="#2-动态伸缩" class="headerlink" title="(2) 动态伸缩"></a><strong>(2) 动态伸缩</strong></h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">stage(<span class="string">&#x27;Auto Scaling&#x27;</span>) &#123;</span><br><span class="line">    steps &#123;</span><br><span class="line">        script &#123;</span><br><span class="line">            <span class="comment">// 根据 CPU 负载自动扩容</span></span><br><span class="line">            sh <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                kubectl autoscale deployment battle-service \</span></span><br><span class="line"><span class="string">                    --cpu-percent=70 \</span></span><br><span class="line"><span class="string">                    --min=2 \</span></span><br><span class="line"><span class="string">                    --max=5 \</span></span><br><span class="line"><span class="string">                    -n $&#123;K8S_NAMESPACE&#125;</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-数据库迁移（Flyway-Liquibase）"><a href="#3-数据库迁移（Flyway-Liquibase）" class="headerlink" title="(3) 数据库迁移（Flyway&#x2F;Liquibase）"></a><strong>(3) 数据库迁移（Flyway&#x2F;Liquibase）</strong></h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">stage(<span class="string">&#x27;DB Migration&#x27;</span>) &#123;</span><br><span class="line">    steps &#123;</span><br><span class="line">        sh <span class="string">&quot;mvn flyway:migrate -pl auth-service&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-监控与回滚"><a href="#6-监控与回滚" class="headerlink" title="6. 监控与回滚"></a><strong>6. 监控与回滚</strong></h2><table>
<thead>
<tr>
<th>工具</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Prometheus + Grafana</strong></td>
<td>监控服务性能</td>
</tr>
<tr>
<td><strong>Kibana</strong></td>
<td>日志分析</td>
</tr>
<tr>
<td><strong>Jenkins 回滚脚本</strong></td>
<td>快速回退到旧版本</td>
</tr>
</tbody></table>
<p><strong>回滚示例</strong>：  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">stage(<span class="string">&#x27;Rollback&#x27;</span>) &#123;</span><br><span class="line">    steps &#123;</span><br><span class="line">        script &#123;</span><br><span class="line">            <span class="comment">// 回滚到上一个 Docker 镜像版本</span></span><br><span class="line">            SERVICES.split().each &#123; service -&gt;</span><br><span class="line">                sh <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    kubectl rollout undo deployment/$&#123;service&#125; -n $&#123;K8S_NAMESPACE&#125;</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-完整流程图示"><a href="#7-完整流程图示" class="headerlink" title="7. 完整流程图示"></a><strong>7. 完整流程图示</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码提交 → Jenkins 触发 → 单元测试 → 构建镜像 → 推送镜像仓库 → 部署到 K8s → 集成测试 → 监控</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-常见问题解决"><a href="#8-常见问题解决" class="headerlink" title="8. 常见问题解决"></a><strong>8. 常见问题解决</strong></h2><table>
<thead>
<tr>
<th>问题</th>
<th>排查方法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Docker 构建失败</strong></td>
<td>检查 <code>Dockerfile</code> 和构建日志</td>
</tr>
<tr>
<td><strong>K8s 部署超时</strong></td>
<td><code>kubectl get pods -n game-prod</code> 查看 Pod 状态</td>
</tr>
<tr>
<td><strong>微服务通信异常</strong></td>
<td>检查服务发现（Consul&#x2F;Nacos）和网络策略</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>适用场景</strong>：MMO 游戏后端、实时对战服务、分布式微服务架构。  </li>
<li><strong>核心优势</strong>：全自动化构建部署 + 快速回滚 + 弹性伸缩。  </li>
<li><strong>扩展方向</strong>：结合 <strong>ArgoCD</strong> 实现 GitOps，或使用 <strong>Terraform</strong> 管理云资源。</li>
</ul>
<p>如果有具体技术栈（如 Go 微服务、Python 异步框架），可以进一步优化流程！ 🚀</p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 简介</title>
    <url>/2025/05/08/Jenkins/</url>
    <content><![CDATA[<h3 id="Jenkins-简介"><a href="#Jenkins-简介" class="headerlink" title="Jenkins 简介"></a><strong>Jenkins 简介</strong></h3><p>Jenkins 是一个开源的 <strong>持续集成和持续交付 (CI&#x2F;CD)</strong> 工具，用于自动化构建、测试和部署软件项目。它支持多种编程语言、版本控制系统（如 Git、SVN）和构建工具（如 Maven、Gradle）。</p>
<hr>
<h2 id="1-Jenkins-安装"><a href="#1-Jenkins-安装" class="headerlink" title="1. Jenkins 安装"></a><strong>1. Jenkins 安装</strong></h2><h3 id="1-Windows-安装"><a href="#1-Windows-安装" class="headerlink" title="(1) Windows 安装"></a><strong>(1) Windows 安装</strong></h3><ol>
<li><p><strong>下载 Jenkins</strong>：</p>
<ul>
<li>官网下载地址：<a href="https://www.jenkins.io/download/">https://www.jenkins.io/download/</a></li>
<li>选择 <strong>Windows 版本（.msi 安装包）</strong>。</li>
</ul>
</li>
<li><p><strong>运行安装程序</strong>：</p>
<ul>
<li>双击 <code>.msi</code> 文件，按向导安装。</li>
<li>默认端口：<code>8080</code>（可修改）。</li>
</ul>
</li>
<li><p><strong>启动 Jenkins</strong>：</p>
<ul>
<li>安装完成后，访问 <code>http://localhost:8080</code>。</li>
<li>首次启动需要输入 <strong>初始管理员密码</strong>（在日志或 <code>C:\Program Files\Jenkins\secrets\initialAdminPassword</code> 中查找）。</li>
</ul>
</li>
<li><p><strong>安装推荐插件</strong>：</p>
<ul>
<li>选择 **”Install suggested plugins”**（推荐）。</li>
<li>等待插件安装完成。</li>
</ul>
</li>
<li><p><strong>创建管理员账户</strong>：</p>
<ul>
<li>设置用户名、密码和邮箱。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-Linux-macOS-安装"><a href="#2-Linux-macOS-安装" class="headerlink" title="(2) Linux&#x2F;macOS 安装"></a><strong>(2) Linux&#x2F;macOS 安装</strong></h3><h4 id="方法-1：使用-Docker（推荐）"><a href="#方法-1：使用-Docker（推荐）" class="headerlink" title="方法 1：使用 Docker（推荐）"></a><strong>方法 1：使用 Docker（推荐）</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 -p 50000:50000 -v jenkins_home:/var/jenkins_home jenkins/jenkins:lts</span><br></pre></td></tr></table></figure>
<p>访问 <code>http://localhost:8080</code> 进行初始化。</p>
<h4 id="方法-2：直接安装（Ubuntu-Debian）"><a href="#方法-2：直接安装（Ubuntu-Debian）" class="headerlink" title="方法 2：直接安装（Ubuntu&#x2F;Debian）"></a><strong>方法 2：直接安装（Ubuntu&#x2F;Debian）</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | <span class="built_in">sudo</span> apt-key add -</span><br><span class="line"><span class="built_in">sudo</span> sh -c <span class="string">&#x27;echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install jenkins</span><br><span class="line"><span class="built_in">sudo</span> systemctl start jenkins</span><br></pre></td></tr></table></figure>
<p>访问 <code>http://localhost:8080</code>。</p>
<hr>
<h2 id="2-Jenkins-基本配置"><a href="#2-Jenkins-基本配置" class="headerlink" title="2. Jenkins 基本配置"></a><strong>2. Jenkins 基本配置</strong></h2><h3 id="1-管理插件"><a href="#1-管理插件" class="headerlink" title="(1) 管理插件"></a><strong>(1) 管理插件</strong></h3><ol>
<li><strong>进入插件管理</strong>：<ul>
<li><strong>Dashboard → Manage Jenkins → Manage Plugins</strong>。</li>
</ul>
</li>
<li><strong>安装常用插件</strong>：<ul>
<li><strong>Git</strong>（用于代码拉取）</li>
<li><strong>Pipeline</strong>（定义 CI&#x2F;CD 流程）</li>
<li><strong>Docker</strong>（用于容器化构建）</li>
<li><strong>Blue Ocean</strong>（可视化流水线）</li>
</ul>
</li>
</ol>
<h3 id="2-配置全局工具"><a href="#2-配置全局工具" class="headerlink" title="(2) 配置全局工具"></a><strong>(2) 配置全局工具</strong></h3><ol>
<li><strong>进入全局工具配置</strong>：<ul>
<li><strong>Dashboard → Manage Jenkins → Global Tool Configuration</strong>。</li>
</ul>
</li>
<li><strong>配置 JDK、Maven、Git</strong>：<ul>
<li>指定路径或自动安装。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-Jenkins-创建第一个-Job"><a href="#3-Jenkins-创建第一个-Job" class="headerlink" title="3. Jenkins 创建第一个 Job"></a><strong>3. Jenkins 创建第一个 Job</strong></h2><h3 id="1-自由风格项目（Freestyle-Project）"><a href="#1-自由风格项目（Freestyle-Project）" class="headerlink" title="(1) 自由风格项目（Freestyle Project）"></a><strong>(1) 自由风格项目（Freestyle Project）</strong></h3><ol>
<li><strong>新建 Job</strong>：<ul>
<li><strong>Dashboard → New Item → Freestyle project</strong>。</li>
</ul>
</li>
<li><strong>配置 Git 仓库</strong>：<ul>
<li><strong>Source Code Management → Git</strong>，输入仓库 URL。</li>
</ul>
</li>
<li><strong>设置构建触发器</strong>：<ul>
<li><strong>Poll SCM</strong>（定时检查代码更新）。</li>
<li><strong>GitHub Webhook</strong>（代码提交后自动触发）。</li>
</ul>
</li>
<li><strong>添加构建步骤</strong>：<ul>
<li><strong>Execute shell</strong>（Linux）或 <strong>Execute Windows batch command</strong>（Windows）：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Building...&quot;</span></span><br><span class="line">mvn clean package</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>保存并运行</strong>：<ul>
<li>点击 <strong>Build Now</strong> 手动触发构建。</li>
</ul>
</li>
</ol>
<h3 id="2-使用-Pipeline（推荐）"><a href="#2-使用-Pipeline（推荐）" class="headerlink" title="(2) 使用 Pipeline（推荐）"></a><strong>(2) 使用 Pipeline（推荐）</strong></h3><ol>
<li><strong>新建 Pipeline Job</strong>：<ul>
<li><strong>New Item → Pipeline</strong>。</li>
</ul>
</li>
<li><strong>编写 Jenkinsfile</strong>（示例）：<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;mvn clean package&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Test&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;mvn test&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Deploy&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;scp target/*.jar user@server:/path/&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>保存并运行</strong>：<ul>
<li>代码提交后自动触发 Pipeline。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="4-Jenkins-集成-GitHub-GitLab"><a href="#4-Jenkins-集成-GitHub-GitLab" class="headerlink" title="4. Jenkins 集成 GitHub&#x2F;GitLab"></a><strong>4. Jenkins 集成 GitHub&#x2F;GitLab</strong></h2><h3 id="1-GitHub-Webhook-自动触发"><a href="#1-GitHub-Webhook-自动触发" class="headerlink" title="(1) GitHub Webhook 自动触发"></a><strong>(1) GitHub Webhook 自动触发</strong></h3><ol>
<li><strong>在 GitHub 仓库设置 Webhook</strong>：<ul>
<li><strong>Settings → Webhooks → Add webhook</strong>。</li>
<li>Payload URL: <code>http://&lt;你的Jenkins服务器&gt;/github-webhook/</code>。</li>
</ul>
</li>
<li><strong>在 Jenkins 配置 GitHub 插件</strong>：<ul>
<li><strong>Manage Jenkins → Configure System → GitHub Server</strong>。</li>
<li>添加 GitHub 凭据（Personal Access Token）。</li>
</ul>
</li>
</ol>
<h3 id="2-GitLab-CI-CD-集成"><a href="#2-GitLab-CI-CD-集成" class="headerlink" title="(2) GitLab CI&#x2F;CD 集成"></a><strong>(2) GitLab CI&#x2F;CD 集成</strong></h3><ol>
<li><strong>安装 GitLab 插件</strong>：<ul>
<li>**Manage Plugins → 搜索 “GitLab”**。</li>
</ul>
</li>
<li><strong>配置 GitLab 连接</strong>：<ul>
<li><strong>Manage Jenkins → Configure System → GitLab</strong>。</li>
<li>输入 GitLab URL 和 API Token。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-Jenkins-常见问题"><a href="#5-Jenkins-常见问题" class="headerlink" title="5. Jenkins 常见问题"></a><strong>5. Jenkins 常见问题</strong></h2><h3 id="1-Jenkins-启动失败"><a href="#1-Jenkins-启动失败" class="headerlink" title="(1) Jenkins 启动失败"></a><strong>(1) Jenkins 启动失败</strong></h3><ul>
<li><strong>检查端口冲突</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr 8080  <span class="comment"># Windows</span></span><br><span class="line"><span class="built_in">sudo</span> lsof -i :8080           <span class="comment"># Linux/macOS</span></span><br></pre></td></tr></table></figure></li>
<li><strong>修改端口</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/default/jenkins  <span class="comment"># 修改 HTTP_PORT</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart jenkins</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-插件安装失败"><a href="#2-插件安装失败" class="headerlink" title="(2) 插件安装失败"></a><strong>(2) 插件安装失败</strong></h3><ul>
<li><strong>更换镜像源</strong>：<ul>
<li><strong>Manage Jenkins → Manage Plugins → Advanced</strong>。</li>
<li>修改 Update Site 为：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-构建失败排查"><a href="#3-构建失败排查" class="headerlink" title="(3) 构建失败排查"></a><strong>(3) 构建失败排查</strong></h3><ul>
<li><strong>查看控制台日志</strong>：<ul>
<li>进入构建详情 → <strong>Console Output</strong>。</li>
</ul>
</li>
<li><strong>检查环境变量</strong>：<ul>
<li><code>echo $PATH</code>（Linux）或 <code>echo %PATH%</code>（Windows）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="6-Jenkins-进阶功能"><a href="#6-Jenkins-进阶功能" class="headerlink" title="6. Jenkins 进阶功能"></a><strong>6. Jenkins 进阶功能</strong></h2><table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>分布式构建</strong></td>
<td>使用 Agent 节点分担主节点压力</td>
</tr>
<tr>
<td><strong>Blue Ocean</strong></td>
<td>可视化 Pipeline 编辑</td>
</tr>
<tr>
<td><strong>Docker 集成</strong></td>
<td>在容器中运行构建</td>
</tr>
<tr>
<td><strong>Kubernetes 插件</strong></td>
<td>动态创建 Pod 运行 Job</td>
</tr>
</tbody></table>
<hr>
<h2 id="7-学习资源"><a href="#7-学习资源" class="headerlink" title="7. 学习资源"></a><strong>7. 学习资源</strong></h2><ul>
<li><strong>官方文档</strong>：<a href="https://www.jenkins.io/doc/">https://www.jenkins.io/doc/</a></li>
<li><strong>中文社区</strong>：<a href="https://jenkins-zh.cn/">https://jenkins-zh.cn/</a></li>
<li><strong>实战课程</strong>：<ul>
<li>Udemy: <a href="https://www.udemy.com/course/jenkins-from-zero-to-hero/">Jenkins CI&#x2F;CD Pipeline</a></li>
<li>B站：搜索 “Jenkins 教程”</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li>Jenkins 是强大的 CI&#x2F;CD 工具，支持自动化构建、测试和部署。</li>
<li>推荐使用 <strong>Pipeline + Docker</strong> 实现现代化 DevOps 流程。</li>
<li>遇到问题可查看 <strong>日志</strong> 或 <strong>社区</strong> 寻求帮助。</li>
</ul>
<p>如果有具体问题（如 Jenkinsfile 编写、插件配置），可以进一步讨论！ 🚀</p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 游戏打包部署流程</title>
    <url>/2025/05/08/Jenkins%20%E6%B8%B8%E6%88%8F%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="Jenkins-游戏打包部署流程（以-Unity-游戏为例）"><a href="#Jenkins-游戏打包部署流程（以-Unity-游戏为例）" class="headerlink" title="Jenkins 游戏打包部署流程（以 Unity 游戏为例）"></a><strong>Jenkins 游戏打包部署流程（以 Unity 游戏为例）</strong></h3><p>以下是使用 Jenkins 自动化构建和部署 Unity 游戏的完整流程，涵盖 <strong>代码拉取、Unity 打包、测试、部署到服务器</strong> 等关键步骤。</p>
<hr>
<h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a><strong>1. 环境准备</strong></h2><table>
<thead>
<tr>
<th>工具&#x2F;环境</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Jenkins</strong></td>
<td>主 CI&#x2F;CD 服务器</td>
</tr>
<tr>
<td><strong>Unity</strong></td>
<td>安装 Unity Hub 和指定版本 Unity Editor</td>
</tr>
<tr>
<td><strong>Git</strong></td>
<td>版本控制（GitHub&#x2F;GitLab）</td>
</tr>
<tr>
<td><strong>构建节点</strong></td>
<td>Windows&#x2F;Linux 代理机（用于 Unity 打包）</td>
</tr>
<tr>
<td><strong>部署目标</strong></td>
<td>FTP&#x2F;SSH&#x2F;云存储（如阿里云 OSS）</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-Jenkins-配置"><a href="#2-Jenkins-配置" class="headerlink" title="2. Jenkins 配置"></a><strong>2. Jenkins 配置</strong></h2><h3 id="1-安装必要插件"><a href="#1-安装必要插件" class="headerlink" title="(1) 安装必要插件"></a><strong>(1) 安装必要插件</strong></h3><ul>
<li><strong>Git Plugin</strong>（拉取代码）</li>
<li><strong>Unity3d Plugin</strong>（Unity 构建支持）</li>
<li><strong>Pipeline</strong>（定义 CI&#x2F;CD 流程）</li>
<li><strong>Publish Over SSH</strong>（远程部署）</li>
<li><strong>Email Extension</strong>（构建通知）</li>
</ul>
<h3 id="2-配置-Unity-环境"><a href="#2-配置-Unity-环境" class="headerlink" title="(2) 配置 Unity 环境"></a><strong>(2) 配置 Unity 环境</strong></h3><ol>
<li><p><strong>在 Jenkins 全局工具中配置 Unity</strong>：</p>
<ul>
<li><strong>Manage Jenkins → Global Tool Configuration</strong>  </li>
<li>指定 Unity 安装路径（如 <code>C:\Program Files\Unity\Hub\Editor\2021.3.0f1\Editor\Unity.exe</code>）</li>
</ul>
</li>
<li><p><strong>添加 Unity License</strong>：</p>
<ul>
<li>在构建节点上提前激活 Unity 许可证（命令行或手动激活）。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-创建-Jenkins-Pipeline"><a href="#3-创建-Jenkins-Pipeline" class="headerlink" title="3. 创建 Jenkins Pipeline"></a><strong>3. 创建 Jenkins Pipeline</strong></h2><p>在项目根目录创建 **<code>Jenkinsfile</code>**，定义构建流程：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    environment &#123;</span><br><span class="line">        UNITY_PATH = <span class="string">&quot;C:/Program Files/Unity/Hub/Editor/2021.3.0f1/Editor/Unity.exe&quot;</span> <span class="comment">// Windows</span></span><br><span class="line">        <span class="comment">// UNITY_PATH = &quot;/Applications/Unity/Hub/Editor/2021.3.0f1/Unity.app/Contents/MacOS/Unity&quot; // macOS</span></span><br><span class="line">        BUILD_TARGET = <span class="string">&quot;Win64&quot;</span> <span class="comment">// 可选：Win64、Android、iOS、WebGL</span></span><br><span class="line">        OUTPUT_DIR = <span class="string">&quot;build/$&#123;BUILD_TARGET&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        <span class="comment">// 阶段 1：拉取代码</span></span><br><span class="line">        stage(<span class="string">&#x27;Checkout&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                git <span class="attr">branch:</span> <span class="string">&#x27;main&#x27;</span>, <span class="attr">url:</span> <span class="string">&#x27;https://github.com/your-game-repo.git&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段 2：Unity 打包</span></span><br><span class="line">        stage(<span class="string">&#x27;Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="comment">// 清理旧构建</span></span><br><span class="line">                    bat <span class="string">&quot;rmdir /s /q $&#123;OUTPUT_DIR&#125;&quot;</span>  <span class="comment">// Windows</span></span><br><span class="line">                    <span class="comment">// sh &quot;rm -rf $&#123;OUTPUT_DIR&#125;&quot;    // Linux/macOS</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 执行 Unity 打包命令</span></span><br><span class="line">                    bat <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                        &quot;$&#123;UNITY_PATH&#125;&quot; \</span></span><br><span class="line"><span class="string">                        -batchmode \</span></span><br><span class="line"><span class="string">                        -nographics \</span></span><br><span class="line"><span class="string">                        -silent-crashes \</span></span><br><span class="line"><span class="string">                        -logFile &quot;unity-build.log&quot; \</span></span><br><span class="line"><span class="string">                        -projectPath &quot;.&quot; \</span></span><br><span class="line"><span class="string">                        -buildTarget $&#123;BUILD_TARGET&#125; \</span></span><br><span class="line"><span class="string">                        -executeMethod BuildScript.PerformBuild \</span></span><br><span class="line"><span class="string">                        -quit</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            post &#123;</span><br><span class="line">                success &#123;</span><br><span class="line">                    archiveArtifacts <span class="attr">artifacts:</span> <span class="string">&quot;$&#123;OUTPUT_DIR&#125;/**/*&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                failure &#123;</span><br><span class="line">                    emailext <span class="attr">body:</span> <span class="string">&#x27;Unity 构建失败，请检查日志！&#x27;</span>, <span class="attr">subject:</span> <span class="string">&#x27;Jenkins 构建失败&#x27;</span>, <span class="attr">to:</span> <span class="string">&#x27;team@example.com&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段 3：测试（可选）</span></span><br><span class="line">        stage(<span class="string">&#x27;Test&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// 运行单元测试或自动化测试</span></span><br><span class="line">                bat <span class="string">&quot;nunit-console Tests/bin/Debug/Tests.dll&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段 4：部署到服务器</span></span><br><span class="line">        stage(<span class="string">&#x27;Deploy&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="comment">// 方式 1：通过 SSH 上传到游戏服务器</span></span><br><span class="line">                    sshPublisher(</span><br><span class="line">                        <span class="symbol">publishers:</span> [</span><br><span class="line">                            sshPublisherDesc(</span><br><span class="line">                                <span class="symbol">configName:</span> <span class="string">&#x27;game-server&#x27;</span>,</span><br><span class="line">                                <span class="symbol">transfers:</span> [</span><br><span class="line">                                    sshTransfer(</span><br><span class="line">                                        <span class="symbol">sourceFiles:</span> <span class="string">&quot;$&#123;OUTPUT_DIR&#125;/**&quot;</span>,</span><br><span class="line">                                        <span class="symbol">remoteDirectory:</span> <span class="string">&quot;/var/www/game&quot;</span>,</span><br><span class="line">                                        <span class="symbol">execCommand:</span> <span class="string">&quot;chmod -R 755 /var/www/game&quot;</span></span><br><span class="line">                                    )</span><br><span class="line">                                ]</span><br><span class="line">                            )</span><br><span class="line">                        ]</span><br><span class="line">                    )</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 方式 2：上传到云存储（如阿里云 OSS）</span></span><br><span class="line">                    withCredentials([usernamePassword(<span class="attr">credentialsId:</span> <span class="string">&#x27;oss-credentials&#x27;</span>, <span class="attr">usernameVariable:</span> <span class="string">&#x27;OSS_KEY&#x27;</span>, <span class="attr">passwordVariable:</span> <span class="string">&#x27;OSS_SECRET&#x27;</span>)]) &#123;</span><br><span class="line">                        sh <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                            aliyun oss cp $&#123;OUTPUT_DIR&#125; oss://your-bucket/game/ --recursive \</span></span><br><span class="line"><span class="string">                            --access-key-id $&#123;OSS_KEY&#125; \</span></span><br><span class="line"><span class="string">                            --access-key-secret $&#123;OSS_SECRET&#125;</span></span><br><span class="line"><span class="string">                        &quot;&quot;&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-Unity-构建脚本"><a href="#4-Unity-构建脚本" class="headerlink" title="4. Unity 构建脚本"></a><strong>4. Unity 构建脚本</strong></h2><p>在 Unity 项目中创建 **<code>BuildScript.cs</code>**（放在 <code>Assets/Editor/</code> 目录下）：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">BuildScript</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PerformBuild</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> outputDir = Path.Combine(Directory.GetCurrentDirectory(), <span class="string">&quot;build/&quot;</span> + EditorUserBuildSettings.activeBuildTarget);</span><br><span class="line">        <span class="keyword">if</span> (!Directory.Exists(outputDir))</span><br><span class="line">            Directory.CreateDirectory(outputDir);</span><br><span class="line"></span><br><span class="line">        BuildPipeline.BuildPlayer(</span><br><span class="line">            scenes: EditorBuildSettings.scenes.Where(s =&gt; s.enabled).Select(s =&gt; s.path).ToArray(),</span><br><span class="line">            locationPathName: Path.Combine(outputDir, <span class="string">&quot;Game.exe&quot;</span>),  <span class="comment">// Windows</span></span><br><span class="line">            target: EditorUserBuildSettings.activeBuildTarget,</span><br><span class="line">            options: BuildOptions.None</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-触发构建"><a href="#5-触发构建" class="headerlink" title="5. 触发构建"></a><strong>5. 触发构建</strong></h2><h3 id="1-手动触发"><a href="#1-手动触发" class="headerlink" title="(1) 手动触发"></a><strong>(1) 手动触发</strong></h3><ul>
<li>在 Jenkins 界面点击 <strong>Build Now</strong>。</li>
</ul>
<h3 id="2-自动触发（Git-Webhook）"><a href="#2-自动触发（Git-Webhook）" class="headerlink" title="(2) 自动触发（Git Webhook）"></a><strong>(2) 自动触发（Git Webhook）</strong></h3><ol>
<li><strong>在 GitHub&#x2F;GitLab 设置 Webhook</strong>：<ul>
<li>Payload URL: <code>http://&lt;JENKINS_IP&gt;/github-webhook/</code></li>
</ul>
</li>
<li><strong>在 Jenkins 配置触发器</strong>：<ul>
<li><strong>Build Triggers → GitHub hook trigger for GITScm polling</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-常见问题"><a href="#6-常见问题" class="headerlink" title="6. 常见问题"></a><strong>6. 常见问题</strong></h2><table>
<thead>
<tr>
<th>问题</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Unity 打包失败</strong></td>
<td>检查 <code>unity-build.log</code>，确保 License 已激活</td>
</tr>
<tr>
<td><strong>构建节点无 Unity</strong></td>
<td>在 Agent 节点安装 Unity Editor</td>
</tr>
<tr>
<td><strong>SSH 部署失败</strong></td>
<td>检查 Jenkins 的 Publish Over SSH 插件配置</td>
</tr>
<tr>
<td><strong>Android&#x2F;iOS 打包问题</strong></td>
<td>配置 JDK&#x2F;NDK&#x2F;Xcode 环境</td>
</tr>
</tbody></table>
<hr>
<h2 id="7-优化建议"><a href="#7-优化建议" class="headerlink" title="7. 优化建议"></a><strong>7. 优化建议</strong></h2><ol>
<li><strong>使用 Docker 镜像</strong>：<ul>
<li>预装 Unity 的 Docker 镜像（如 <code>unityci/editor</code>）可避免环境问题。<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">agent &#123;</span><br><span class="line">    docker &#123;</span><br><span class="line">        image <span class="string">&#x27;unityci/editor:2021.3.0f1-android-1.0.0&#x27;</span></span><br><span class="line">        args <span class="string">&#x27;-v /tmp:/tmp&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>并行构建多平台</strong>：<ul>
<li>使用 <code>parallel</code> 阶段同时构建 Win&#x2F;Android&#x2F;iOS。</li>
</ul>
</li>
<li><strong>存档 APK&#x2F;IPA</strong>：<ul>
<li>使用 <code>archiveArtifacts</code> 保存构建产物。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="8-最终效果"><a href="#8-最终效果" class="headerlink" title="8. 最终效果"></a><strong>8. 最终效果</strong></h2><ul>
<li><strong>代码提交 → 自动触发 Jenkins → Unity 打包 → 测试 → 部署到服务器</strong>  </li>
<li><strong>团队收到构建成功&#x2F;失败邮件通知</strong></li>
</ul>
<p>如果有具体需求（如 Android 签名、iOS 证书配置），可以进一步调整流程！ 🎮</p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Lean Cloud</title>
    <url>/2025/01/08/Lean-Cloud/</url>
    <content><![CDATA[<p><strong>LeanCloud</strong> 是一个 <strong>后端即服务（BaaS，Backend as a Service）</strong> 平台，主要为开发者提供一站式的后端服务，帮助开发者快速构建应用程序，无需自己搭建复杂的后端服务器。通过 LeanCloud，开发者可以专注于前端开发和业务逻辑，而后端服务（如数据存储、用户认证、实时消息等）由 LeanCloud 提供并维护。</p>
<hr>
<h3 id="LeanCloud-的核心功能"><a href="#LeanCloud-的核心功能" class="headerlink" title="LeanCloud 的核心功能"></a><strong>LeanCloud 的核心功能</strong></h3><p>LeanCloud 提供了许多常见后端功能，以下是主要的功能模块：</p>
<h4 id="1-数据存储"><a href="#1-数据存储" class="headerlink" title="1. 数据存储"></a><strong>1. 数据存储</strong></h4><ul>
<li>提供类似数据库的云端存储服务，支持结构化和非结构化数据。</li>
<li>数据存储是基于 <strong>NoSQL</strong> 的，开发者无需处理复杂的数据库部署和运维。</li>
<li>支持复杂查询、关系模型以及文件存储（图片、文档等）。</li>
</ul>
<h4 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2. 用户管理"></a><strong>2. 用户管理</strong></h4><ul>
<li>提供用户注册、登录和管理功能。</li>
<li>支持第三方登录（如微信、QQ、微博等）。</li>
<li>提供基于角色和权限的访问控制。</li>
</ul>
<h4 id="3-即时通讯"><a href="#3-即时通讯" class="headerlink" title="3. 即时通讯"></a><strong>3. 即时通讯</strong></h4><ul>
<li>支持实时消息传输，包括单聊、群聊和聊天室功能。</li>
<li>提供消息历史记录和离线消息支持。</li>
<li>适合需要社交聊天或消息通知功能的应用。</li>
</ul>
<h4 id="4-云引擎"><a href="#4-云引擎" class="headerlink" title="4. 云引擎"></a><strong>4. 云引擎</strong></h4><ul>
<li>提供自定义后端逻辑的功能，开发者可以使用 LeanCloud 的云引擎编写自己的业务逻辑代码。</li>
<li>支持定时任务、事件处理等。</li>
</ul>
<h4 id="5-推送通知"><a href="#5-推送通知" class="headerlink" title="5. 推送通知"></a><strong>5. 推送通知</strong></h4><ul>
<li>提供消息推送功能，支持 iOS、Android 和 Web 平台。</li>
<li>支持定向推送、广播推送以及根据用户属性筛选推送。</li>
</ul>
<h4 id="6-文件存储"><a href="#6-文件存储" class="headerlink" title="6. 文件存储"></a><strong>6. 文件存储</strong></h4><ul>
<li>用于存储图片、视频、音频等文件。</li>
<li>提供 CDN 加速功能，确保文件访问速度快且稳定。</li>
</ul>
<h4 id="7-数据分析"><a href="#7-数据分析" class="headerlink" title="7. 数据分析"></a><strong>7. 数据分析</strong></h4><ul>
<li>提供实时的应用数据分析，帮助开发者了解用户行为和产品表现。</li>
<li>支持自定义事件的埋点统计。</li>
</ul>
<hr>
<h3 id="LeanCloud-的特点"><a href="#LeanCloud-的特点" class="headerlink" title="LeanCloud 的特点"></a><strong>LeanCloud 的特点</strong></h3><ol>
<li><p><strong>一站式后端服务</strong></p>
<ul>
<li>开发者可以使用 LeanCloud 提供的所有后端功能，无需自己搭建服务器和数据库。</li>
</ul>
</li>
<li><p><strong>跨平台支持</strong></p>
<ul>
<li>提供丰富的 SDK，支持 Android、iOS、Unity、Web、小程序等多种平台。</li>
</ul>
</li>
<li><p><strong>高可用和可扩展性</strong></p>
<ul>
<li>LeanCloud 背后的基础设施支持高并发访问，能够应对大规模用户请求。</li>
<li>开发者无需担心服务器维护和扩容问题。</li>
</ul>
</li>
<li><p><strong>高效开发</strong></p>
<ul>
<li>减少后端开发时间，让开发者专注于前端开发和产品逻辑。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ol>
<li><strong>社交应用</strong><ul>
<li>即时通讯、群聊、好友系统、动态发布。</li>
</ul>
</li>
<li><strong>电商平台</strong><ul>
<li>用户管理、商品存储、订单管理、推送通知。</li>
</ul>
</li>
<li><strong>游戏开发</strong><ul>
<li>游戏玩家存档、排行榜、实时消息（如对战消息）。</li>
</ul>
</li>
<li><strong>内容平台</strong><ul>
<li>文件存储（图片、音频、视频）、用户行为分析。</li>
</ul>
</li>
<li><strong>小程序开发</strong><ul>
<li>数据存储、用户登录、消息推送。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="与其他-BaaS-的比较"><a href="#与其他-BaaS-的比较" class="headerlink" title="与其他 BaaS 的比较"></a><strong>与其他 BaaS 的比较</strong></h3><p>与 Firebase、AWS Amplify 等 BaaS 服务相比，LeanCloud 更适合 <strong>国内市场</strong> 的开发者，尤其是以下场景：</p>
<ul>
<li><strong>国内访问速度快：</strong> 提供中国大陆的服务器节点。</li>
<li><strong>符合国内法规：</strong> 支持合规化数据存储。</li>
<li><strong>丰富的 SDK：</strong> 针对微信小程序、国内第三方登录等场景提供支持。</li>
</ul>
<hr>
<h3 id="如何使用-LeanCloud？"><a href="#如何使用-LeanCloud？" class="headerlink" title="如何使用 LeanCloud？"></a><strong>如何使用 LeanCloud？</strong></h3><ol>
<li><p><strong>注册 LeanCloud 账号并创建应用</strong></p>
<ul>
<li>前往 <a href="https://www.leancloud.cn/">LeanCloud 官网</a> 注册账号并创建一个新项目。</li>
</ul>
</li>
<li><p><strong>集成 LeanCloud SDK</strong></p>
<ul>
<li>在项目中下载并引入 LeanCloud 提供的 SDK（支持 Unity、C#、JavaScript、Python 等多种语言）。</li>
</ul>
</li>
<li><p><strong>调用 LeanCloud 的 API</strong></p>
<ul>
<li>通过 SDK 或 REST API，调用 LeanCloud 提供的各种服务，如存储数据、发送消息等。</li>
</ul>
</li>
<li><p><strong>部署云引擎</strong></p>
<ul>
<li>如果需要自定义后端逻辑，可以在 LeanCloud 的云引擎上部署自己的代码。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h3><p>以下是一个使用 LeanCloud 存储数据的简单示例（C#）：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> LeanCloud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">SaveData</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化 LeanCloud</span></span><br><span class="line">        AVClient.Initialize(<span class="string">&quot;your-app-id&quot;</span>, <span class="string">&quot;your-app-key&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个对象</span></span><br><span class="line">        AVObject obj = <span class="keyword">new</span> AVObject(<span class="string">&quot;TestObject&quot;</span>);</span><br><span class="line">        obj[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Unity开发者&quot;</span>;</span><br><span class="line">        obj[<span class="string">&quot;score&quot;</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存到 LeanCloud</span></span><br><span class="line">        <span class="keyword">await</span> obj.SaveAsync();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;数据保存成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>LeanCloud 是一个功能强大且易用的后端即服务平台，适合中小型团队甚至个人开发者快速构建后端服务。尤其是对于国内开发者来说，LeanCloud 的本地化支持和便捷性使其成为 Firebase 等海外 BaaS 平台的有力替代品。</p>
]]></content>
      <categories>
        <category>Lean Cloud</category>
      </categories>
      <tags>
        <tag>Lean Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/07/09/Lua%E8%AF%AD%E6%B3%95%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="Lua语法检测工具文档"><a href="#Lua语法检测工具文档" class="headerlink" title="Lua语法检测工具文档"></a>Lua语法检测工具文档</h1><h2 id="工具概述"><a href="#工具概述" class="headerlink" title="工具概述"></a>工具概述</h2><p>Lua语法检测工具是一个Unity编辑器扩展工具，用于批量检查指定目录下所有Lua脚本的语法正确性。该工具通过创建Lua虚拟机环境，尝试加载每个Lua文件来验证其语法是否合法，帮助开发者在早期发现潜在的语法错误。</p>
<h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><ul>
<li>批量扫描指定目录下的所有Lua文件</li>
<li>使用原生Lua虚拟机进行语法验证</li>
<li>显示详细的错误信息，包括文件路径和具体错误描述</li>
<li>支持递归扫描子目录</li>
<li>提供简洁直观的GUI界面</li>
</ul>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h3><ol>
<li>将脚本放置在Unity项目的Editor文件夹下</li>
<li>在Unity编辑器中，通过菜单栏选择 <code>Tools/lua语法检测</code> 打开工具窗口</li>
</ol>
<h3 id="界面说明"><a href="#界面说明" class="headerlink" title="界面说明"></a>界面说明</h3><p>工具窗口包含以下主要部分：</p>
<ul>
<li><strong>路径选择</strong>：显示和修改Lua文件所在目录（默认为<code>Assets/_GameCenter/ClientLua/Model/Language</code>）</li>
<li><strong>检测按钮</strong>：点击后开始扫描指定目录并检测所有Lua文件语法</li>
</ul>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol>
<li>确认或修改Lua文件目录路径</li>
<li>点击”开始检测”按钮</li>
<li>查看Unity控制台输出：<ul>
<li>检测开始和结束的标记信息</li>
<li>每个文件的检测结果</li>
<li>语法错误的详细描述</li>
</ul>
</li>
</ol>
<h3 id="输出结果解读"><a href="#输出结果解读" class="headerlink" title="输出结果解读"></a>输出结果解读</h3><ul>
<li><strong>正常文件</strong>：不会产生额外输出</li>
<li><strong>语法错误文件</strong>：输出格式为：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ERROR] 文件相对路径</span><br><span class="line">错误描述</span><br></pre></td></tr></table></figure></li>
<li><strong>文件读取错误</strong>：输出格式为：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[FILE ERROR] 读取文件失败: 文件相对路径</span><br><span class="line">错误原因</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><ol>
<li><strong>文件扫描</strong>：递归查找指定目录下的所有.lua文件</li>
<li><strong>Lua环境初始化</strong>：创建Lua虚拟机状态</li>
<li><strong>语法检测</strong>：对每个文件内容执行luaL_loadstring操作</li>
<li><strong>错误处理</strong>：捕获并记录加载过程中产生的错误</li>
<li><strong>资源清理</strong>：关闭Lua虚拟机状态</li>
</ol>
<h3 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h3><ul>
<li><code>StartCheckLua</code>：主检测流程控制</li>
<li><code>CheckLuaSyntax</code>：执行实际的语法检测</li>
<li><code>OnGUI</code>：提供用户界面交互</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>工具仅检测语法正确性，不执行实际代码</li>
<li>需要确保Lua文件路径正确且可访问</li>
<li>检测结果输出到Unity控制台</li>
<li>工具不会修改任何Lua文件内容</li>
<li>必须选择Assets目录下的路径</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> LuaInterface;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CheckLuaSyntaxWindow</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 功能：批量检测指定文件夹下所有 Lua 脚本是否存在语法错误。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用说明：</span></span><br><span class="line"><span class="comment"> * 1. 将本脚本放入 Unity 工程的 Editor 目录中。</span></span><br><span class="line"><span class="comment"> * 2. 在 Unity 菜单栏中点击：Tools &gt; lua语法检测 打开工具窗口。</span></span><br><span class="line"><span class="comment"> * 3. 在弹出的窗口中，点击 “...” 按钮选择待检测的 Lua 文件夹（必须位于 Assets 下）。</span></span><br><span class="line"><span class="comment"> * 4. 点击“开始检测”按钮，工具将自动递归扫描所有 .lua 文件并检测语法问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 特性：</span></span><br><span class="line"><span class="comment"> * - 支持全项目范围递归查找 `.lua` 文件。</span></span><br><span class="line"><span class="comment"> * - 采用底层 Lua VM（通过 LuaDLL）进行语法编译检查，检测准确。</span></span><br><span class="line"><span class="comment"> * - 检测结果以 Unity 控制台日志输出，包含：</span></span><br><span class="line"><span class="comment"> *   * [ERROR] 表示语法错误（含错误信息）</span></span><br><span class="line"><span class="comment"> *   * [FILE ERROR] 表示读取文件失败</span></span><br><span class="line"><span class="comment"> * - 所有语法错误将在控制台中清晰展示，便于开发者快速定位问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意事项：</span></span><br><span class="line"><span class="comment"> * - 所选目录 **必须在 Assets 目录中**，否则路径转换会失败。</span></span><br><span class="line"><span class="comment"> * - 仅检查语法正确性，不执行 Lua 逻辑、不校验运行时引用。</span></span><br><span class="line"><span class="comment"> * - 使用的是底层 C API（LuaDLL），**不会影响项目中现有的 Lua VM（如 LuaState）**。</span></span><br><span class="line"><span class="comment"> * - 工具默认打开标准 Lua 库，兼容绝大部分普通语法。</span></span><br><span class="line"><span class="comment"> * - 检测后请注意控制台输出，按需修复报错脚本。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CheckLuaSyntaxWindow</span> : <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> folderPath, defaultPath = <span class="string">&quot;Assets/_GameCenter/ClientLua/Model/Language&quot;</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="string">&quot;Tools/lua语法检测&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowWindow</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetWindow&lt;CheckLuaSyntaxWindow&gt;(<span class="string">&quot;Lua 语法检测&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        folderPath = <span class="built_in">string</span>.IsNullOrEmpty(folderPath) ? defaultPath : folderPath;</span><br><span class="line">        GUILayout.Label(<span class="string">&quot;选择 Lua 文件目录&quot;</span>, EditorStyles.boldLabel);</span><br><span class="line">        EditorGUILayout.BeginHorizontal();</span><br><span class="line">        EditorGUILayout.LabelField(<span class="string">&quot;目录路径:&quot;</span>, folderPath);</span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;...&quot;</span>, GUILayout.Width(<span class="number">30</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> path = EditorUtility.OpenFolderPanel(<span class="string">&quot;选择 Lua 文件目录&quot;</span>, folderPath, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(path)) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (!path.Contains(<span class="string">&quot;Assets&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(<span class="string">&quot;所选文件夹不在 Assets 目录下，无法处理！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            folderPath = path.Substring(path.IndexOf(<span class="string">&quot;Assets&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        EditorGUILayout.EndHorizontal();</span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;开始检测&quot;</span>)) StartCheckLua(folderPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">StartCheckLua</span>(<span class="params"><span class="built_in">string</span> path</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;===== 开始 Lua 语法检测 ===== <span class="subst">&#123;path&#125;</span> <span class="subst">&#123;Application.dataPath&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更健壮的路径处理</span></span><br><span class="line">        <span class="keyword">var</span> fullPath = Path.GetFullPath(Path.Combine(Application.dataPath, path.Replace(<span class="string">&quot;Assets/&quot;</span>, <span class="string">&quot;&quot;</span>)));</span><br><span class="line">        <span class="keyword">if</span> (!Directory.Exists(fullPath))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">$&quot;路径不存在: <span class="subst">&#123;fullPath&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> L = IntPtr.Zero;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            L = LuaDLL.lua_open();</span><br><span class="line">            <span class="keyword">if</span> (L == IntPtr.Zero)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(<span class="string">&quot;无法创建 Lua 状态&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            LuaDLL.luaL_openlibs(L);</span><br><span class="line">            <span class="keyword">var</span> luaFiles = Directory.GetFiles(fullPath, <span class="string">&quot;*.lua&quot;</span>, SearchOption.AllDirectories);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> file <span class="keyword">in</span> luaFiles)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> relativePath = <span class="string">&quot;Assets&quot;</span> + file.Substring(Application.dataPath.Length);</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> luaCode = File.ReadAllText(file);</span><br><span class="line">                    <span class="keyword">var</span> error = CheckLuaSyntax(luaCode, L);</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(error))</span><br><span class="line">                        Debug.LogError(<span class="string">$&quot;[ERROR] <span class="subst">&#123;relativePath&#125;</span>\n<span class="subst">&#123;error&#125;</span>&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    Debug.LogError(<span class="string">$&quot;[FILE ERROR] 读取文件失败: <span class="subst">&#123;relativePath&#125;</span>\n<span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (L != IntPtr.Zero) LuaDLL.lua_close(L);</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(<span class="string">&quot;===== 检测完成 =====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">CheckLuaSyntax</span>(<span class="params"><span class="built_in">string</span> code, IntPtr L</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 清空栈</span></span><br><span class="line">            LuaDLL.lua_settop(L, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (LuaDLL.luaL_loadstring(L, code) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LuaDLL.lua_pop(L, <span class="number">1</span>); <span class="comment">// 弹出成功加载的函数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> error = LuaDLL.lua_tostring(L, <span class="number">-1</span>);</span><br><span class="line">                LuaDLL.lua_pop(L, <span class="number">1</span>); <span class="comment">// 弹出错误消息</span></span><br><span class="line">                <span class="keyword">return</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> e.Message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Markdown 语法</title>
    <url>/2025/05/09/Markdown%20%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="欢迎使用-Arya-在线-Markdown-编辑器"><a href="#欢迎使用-Arya-在线-Markdown-编辑器" class="headerlink" title="欢迎使用 Arya 在线 Markdown 编辑器"></a>欢迎使用 <code>Arya</code> 在线 Markdown 编辑器</h1><p><a href="https://markdown.lovejade.cn/?ref=markdown.lovejade.cn">Arya</a>，是一款基于 <code>Vue</code>、<code>Vditor</code>，为未来而构建的在线 Markdown 编辑器；轻量且强大：内置粘贴 HTML 自动转换为 Markdown，支持流程图、甘特图、时序图、任务列表，可导出携带样式的图片、PDF、微信公众号特制的 HTML 等等。</p>
<hr>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p><strong>微注</strong>：清空目前这份默认文档，即处于可使用态。<a href="https://markdown.lovejade.cn/?ref=markdown.lovejade.cn">Arya</a> 另一大优点在于：编辑内容只会在您本地进行保存，不会上传您的数据至服务器，<strong>绝不窥测用户个人隐私，可放心使用</strong>；Github 源码：<a href="https://github.com/nicejade/markdown-online-editor">markdown-online-editor</a>，部分功能仍在开发🚧，敬请期待。</p>
<p>默认为<a href="https://hacpai.com/article/1577370404903?ref=github.com">所见即所得</a>模式，可通过 <code>⌘-⇧-M</code>（<code>Ctrl-⇧-M</code>）进行切换；或通过以下方式：</p>
<ul>
<li>所见即所得：<code>⌘-⌥-7</code>（<code>Ctrl-alt-7</code>）；</li>
<li>即时渲染：<code>⌘-⌥-8</code>（<code>Ctrl-alt-8</code>）；</li>
<li>分屏渲染：<code>⌘-⌥-9</code>（<code>Ctrl-alt-9</code>）；</li>
</ul>
<h3 id="PPT-预览"><a href="#PPT-预览" class="headerlink" title="PPT 预览"></a>PPT 预览</h3><p>如果您用作 <code>PPT</code> 预览（入口在<code>设置</code>中），需要注意，这里暂还不能支持各种图表的渲染；您可以使用 <code>---</code> 来定义水平方向上幻灯片，用 <code>--</code> 来定义垂直幻灯片；更多设定可以参见 <a href="https://github.com/hakimel/reveal.js#table-of-contents">RevealJs 文档</a>。</p>
<hr>
<h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p><code>Markdown</code> 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号，以最小的输入代价，生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong>、<em>斜体</em> 或者<a href="https://vue-cli3.lovejade.cn/explore/">超文本链接</a>，更棒的是，它还可以：</p>
<hr>
<h3 id="1-制作待办事宜-Todo-列表"><a href="#1-制作待办事宜-Todo-列表" class="headerlink" title="1. 制作待办事宜 Todo 列表"></a>1. 制作待办事宜 <code>Todo</code> 列表</h3><ul>
<li><input checked disabled type="checkbox"> 🎉 通常 <code>Markdown</code> 解析器自带的基本功能；</li>
<li><input checked disabled type="checkbox"> 🍀 支持<strong>流程图</strong>、<strong>甘特图</strong>、<strong>时序图</strong>、<strong>任务列表</strong>；</li>
<li><input checked disabled type="checkbox"> 🏁 支持粘贴 HTML 自动转换为 Markdown；</li>
<li><input checked disabled type="checkbox"> 💃🏻 支持插入原生 Emoji、设置常用表情列表；</li>
<li><input checked disabled type="checkbox"> 🚑 支持编辑内容保存<strong>本地存储</strong>，防止意外丢失；</li>
<li><input checked disabled type="checkbox"> 📝 支持<strong>实时预览</strong>，主窗口大小拖拽，字符计数；</li>
<li><input checked disabled type="checkbox"> 🛠 支持常用快捷键(<strong>Tab</strong>)，及代码块添加复制</li>
<li><input checked disabled type="checkbox"> ✨ 支持<strong>导出</strong>携带样式的 PDF、PNG、JPEG 等；</li>
<li><input checked disabled type="checkbox"> ✨ 升级 Vditor，新增对 <code>echarts</code> 图表的支持；</li>
<li><input checked disabled type="checkbox"> 👏 支持检查并格式化 Markdown 语法，使其专业；</li>
<li><input checked disabled type="checkbox"> 🦑 支持五线谱、及<a href="https://github.com/b3log/vditor/issues/117?ref=hacpai.com#issuecomment-526986052">部分站点、视频、音频解析</a>；</li>
<li><input checked disabled type="checkbox"> 🌟 增加对<strong>所见即所得</strong>编辑模式的支持(<code>⌘-⇧-M</code>)；</li>
</ul>
<hr>
<h3 id="2-书写一个质能守恒公式-LaTeX"><a href="#2-书写一个质能守恒公式-LaTeX" class="headerlink" title="2. 书写一个质能守恒公式[^LaTeX]"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$<br>E&#x3D;mc^2<br>$$</p>
<hr>
<h3 id="3-高亮一段代码-code"><a href="#3-高亮一段代码-code" class="headerlink" title="3. 高亮一段代码[^code]"></a>3. 高亮一段代码[^code]</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给页面里所有的 DOM 元素添加一个 1px 的描边（outline）;</span></span><br><span class="line">[].<span class="property">forEach</span>.<span class="title function_">call</span>($$(<span class="string">&quot;*&quot;</span>),<span class="keyword">function</span>(<span class="params">a</span>)&#123;</span><br><span class="line">  a.<span class="property">style</span>.<span class="property">outline</span>=<span class="string">&quot;1px solid #&quot;</span>+(~~(<span class="title class_">Math</span>.<span class="title function_">random</span>()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-高效绘制流程图"><a href="#4-高效绘制流程图" class="headerlink" title="4. 高效绘制流程图"></a>4. 高效绘制<a href="https://github.com/knsv/mermaid#flowchart">流程图</a></h3><pre><code class="highlight mermaid">graph TD
    A[用户请求] --&gt; B[语义解析]
    B --&gt; C[RAG检索]
    
    C --&gt;|✅ 知识库匹配| D[上下文增强]
    C --&gt;|❌ 无匹配| E[任务分解]
    
    D --&gt; E
    
    E --&gt; F&#123;工具选择&#125;
    
    F --&gt;|🛠️ 核心工具| G&#123;基础操作&#125;
    F --&gt;|🔌 MCP扩展服务| H&#123;MCP操作&#125;
    
    G --&gt;|✏️ 文件操作| I[读写/替换]
    G --&gt;|🖥️ 系统命令执行| J[执行命令]
    G --&gt;|🔍 代码分析| K[代码分析]
    
    H --&gt;|⚙️ 使用MCP工具| L[使用MCP工具]
    H --&gt;|📦 访问MCP资源| M[访问MCP资源]
    
    I --&gt; N[结果验证]
    J --&gt; N
    K --&gt; N
    L --&gt; N
    M --&gt; N
    
    N --&gt; O&#123;完成判断&#125;
    
    O --&gt;|✅| P[提交最终结果]
    O --&gt;|❌| E</code></pre>

<hr>
<h3 id="5-高效绘制序列图"><a href="#5-高效绘制序列图" class="headerlink" title="5. 高效绘制序列图"></a>5. 高效绘制<a href="https://github.com/knsv/mermaid#sequence-diagram">序列图</a></h3><pre><code class="highlight mermaid">sequenceDiagram
  participant Alice
  participant Bob
  Alice-&gt;John: Hello John, how are you?
  loop Healthcheck
      John-&gt;John: Fight against hypochondria
  end
  Note right of John: Rational thoughts &lt;br/&gt;prevail...
  John--&gt;Alice: Great!
  John-&gt;Bob: How about you?
  Bob--&gt;John: Jolly good!</code></pre>

<hr>
<h3 id="6-高效绘制甘特图"><a href="#6-高效绘制甘特图" class="headerlink" title="6. 高效绘制甘特图"></a>6. 高效绘制<a href="https://github.com/knsv/mermaid#gantt-diagram">甘特图</a></h3><blockquote>
<p><strong>甘特图</strong>内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。</p>
</blockquote>
<pre><code class="highlight mermaid">gantt
  title 项目开发流程
  section 项目确定
    需求分析       :a1, 2019-06-22, 3d
    可行性报告     :after a1, 5d
    概念验证       : 5d
  section 项目实施
    概要设计      :2019-07-05  , 5d
    详细设计      :2019-07-08, 10d
    编码          :2019-07-15, 10d
    测试          :2019-07-22, 5d
  section 发布验收
    发布: 2d
    验收: 3d</code></pre>

<hr>
<h3 id="8-绘制表格"><a href="#8-绘制表格" class="headerlink" title="8. 绘制表格"></a>8. 绘制表格</h3><table>
<thead>
<tr>
<th align="left">作品名称</th>
<th align="left">在线地址</th>
<th align="center">上线日期</th>
</tr>
</thead>
<tbody><tr>
<td align="left">逍遥自在轩</td>
<td align="left"><a href="https://niceshare.site/?ref=markdown.lovejade.cn">https://niceshare.site</a></td>
<td align="center">2024-04-26</td>
</tr>
<tr>
<td align="left">玉桃文飨轩</td>
<td align="left"><a href="https://share.lovejade.cn/?ref=markdown.lovejade.cn">https://share.lovejade.cn</a></td>
<td align="center">2022-08-26</td>
</tr>
<tr>
<td align="left">缘知随心庭</td>
<td align="left"><a href="https://fine.niceshare.site/?ref=markdown.lovejade.cn">https://fine.niceshare.site</a></td>
<td align="center">2022-02-26</td>
</tr>
<tr>
<td align="left">静轩之别苑</td>
<td align="left"><a href="http://quickapp.lovejade.cn/?ref=markdown.lovejade.cn">http://quickapp.lovejade.cn</a></td>
<td align="center">2019-01-12</td>
</tr>
<tr>
<td align="left">晚晴幽草轩</td>
<td align="left"><a href="https://www.jeffjade.com/?ref=markdown.lovejade.cn">https://www.jeffjade.com</a></td>
<td align="center">2014-09-20</td>
</tr>
</tbody></table>
<hr>
<h3 id="9-更详细语法说明"><a href="#9-更详细语法说明" class="headerlink" title="9. 更详细语法说明"></a>9. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考这份 <a href="https://github.com/nicejade/nice-front-end-tutorial/blob/master/tutorial/markdown-tutorial.md">Markdown 资源列表</a>，涵盖入门至进阶教程，以及资源、平台等信息，能让您对她有更深的认知。</p>
<p>总而言之，不同于其它<strong>所见即所得</strong>的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 <code>GitHub</code> 和 技术问答网站 <code>StackOverFlow</code> 的御用书写格式，而且越发流行，正在在向各行业渗透。</p>
<p>最新更新于 2025.04.16</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Overdraw 分析</title>
    <url>/2025/06/17/Unity%20Overdraw%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>在 Unity 中查看界面（UI）的 Overdraw（过度绘制）情况，可以使用 <strong>Unity 的 Scene 视图 + Frame Debugger</strong> 以及 <strong>Profiler 和 RenderDoc 工具</strong>。下面是详细方法：</p>
<hr>
<h2 id="✅-方法一：Scene-视图中的-Overdraw-模式（推荐）"><a href="#✅-方法一：Scene-视图中的-Overdraw-模式（推荐）" class="headerlink" title="✅ 方法一：Scene 视图中的 Overdraw 模式（推荐）"></a>✅ 方法一：Scene 视图中的 Overdraw 模式（推荐）</h2><h3 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h3><ol>
<li>打开 Unity 编辑器。</li>
<li>切换到 <strong>Scene</strong> 视图（不是 Game 视图）。</li>
<li>在 Scene 视图左上角点击 <strong>“Shaded” 下拉菜单</strong>。</li>
<li>选择 <strong>“Overdraw”</strong> 模式。</li>
</ol>
<blockquote>
<p>✅ 在该模式下，颜色越亮说明重叠的次数越多，白色代表非常多次重叠。</p>
</blockquote>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>这个模式主要对 <strong>UI 的渲染顺序</strong> 和 <strong>透明图片叠加</strong> 非常直观。</li>
<li>你需要选中 <code>Canvas</code> 或 UI 元素所在的层级来定位问题。</li>
</ul>
<hr>
<h2 id="✅-方法二：Frame-Debugger（推荐用于查找具体调用）"><a href="#✅-方法二：Frame-Debugger（推荐用于查找具体调用）" class="headerlink" title="✅ 方法二：Frame Debugger（推荐用于查找具体调用）"></a>✅ 方法二：Frame Debugger（推荐用于查找具体调用）</h2><h3 id="操作步骤：-1"><a href="#操作步骤：-1" class="headerlink" title="操作步骤："></a>操作步骤：</h3><ol>
<li>打开 Unity 的 <strong>Window &gt; Analysis &gt; Frame Debugger</strong>。</li>
<li>点击左上角的 <strong>Enable</strong>。</li>
<li>运行游戏，进入你要查看的 UI 界面。</li>
<li>在 Frame Debugger 中浏览每一帧的绘制调用，可以看到哪些 UI 元素被重复绘制。</li>
</ol>
<blockquote>
<p>可以具体看到哪些组件被渲染、是否有冗余的 UI 被 DrawCall 多次渲染。</p>
</blockquote>
<hr>
<h2 id="✅-方法三：Unity-Profiler（整体观察开销）"><a href="#✅-方法三：Unity-Profiler（整体观察开销）" class="headerlink" title="✅ 方法三：Unity Profiler（整体观察开销）"></a>✅ 方法三：Unity Profiler（整体观察开销）</h2><ol>
<li><p>打开 <strong>Window &gt; Analysis &gt; Profiler</strong>。</p>
</li>
<li><p>切换到 <strong>Rendering</strong> 模块。</p>
</li>
<li><p>查看：</p>
<ul>
<li><strong>Draw Calls（绘制调用次数）</strong></li>
<li><strong>Batches（批处理）</strong></li>
<li><strong>Overdraw&#x2F;SetPass Calls</strong></li>
</ul>
</li>
</ol>
<p>虽然 Profiler 不能直接可视化 Overdraw，但可以通过高 Draw Call 和 SetPass 判断是否 UI 渲染过重。</p>
<hr>
<h2 id="✅-方法四：使用-RenderDoc（需要更专业分析）"><a href="#✅-方法四：使用-RenderDoc（需要更专业分析）" class="headerlink" title="✅ 方法四：使用 RenderDoc（需要更专业分析）"></a>✅ 方法四：使用 RenderDoc（需要更专业分析）</h2><p>RenderDoc 是一个图形调试器，可以看到逐像素的绘制信息。</p>
<ol>
<li>安装 RenderDoc 并启用 Unity 支持（Player Settings）。</li>
<li>捕捉一帧 UI 显示画面。</li>
<li>查看 Overdraw 情况以及各层级 UI 的实际渲染。</li>
</ol>
<p>适用于你想深入了解 GPU 层面上的渲染瓶颈时。</p>
<hr>
<h2 id="🎯-小结"><a href="#🎯-小结" class="headerlink" title="🎯 小结"></a>🎯 小结</h2><table>
<thead>
<tr>
<th>工具</th>
<th>用途</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td>Scene View 的 Overdraw 模式</td>
<td>快速查看 UI 哪些地方重叠</td>
<td>快速可视化</td>
</tr>
<tr>
<td>Frame Debugger</td>
<td>精确分析哪些 UI 元素被重复绘制</td>
<td>精准</td>
</tr>
<tr>
<td>Profiler</td>
<td>查看整体 UI 渲染开销</td>
<td>性能趋势</td>
</tr>
<tr>
<td>RenderDoc</td>
<td>专业 GPU 分析工具</td>
<td>最精细</td>
</tr>
</tbody></table>
<hr>
<p>如你是做 UI 优化（如美术导图 or prefab 重构），建议从 <strong>Scene Overdraw + Frame Debugger 结合使用</strong>，可以快速定位 UI 过度绘制区域。</p>
<p>如果你想，我也可以教你怎么看具体哪个 Image 或 Text 的 Overdraw 最高。需要我帮你看图或分析具体 prefab 的结构吗？</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Rebuild 分析</title>
    <url>/2025/06/17/Unity%20Rebuild%20%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>在 Unity 的 <strong>UI 系统（UGUI）中</strong>，<strong>Rebuild</strong> 是指 UI 元素在生命周期中的某些阶段发生变化时触发的一种“重建”流程。频繁的 Rebuild 会带来性能问题，尤其在界面复杂或频繁更新时。下面是关于 Rebuild 的全面分析：</p>
<hr>
<h2 id="🧩-什么是-Rebuild？"><a href="#🧩-什么是-Rebuild？" class="headerlink" title="🧩 什么是 Rebuild？"></a>🧩 什么是 Rebuild？</h2><p>UI 元素发生如下变化时，会触发 Rebuild：</p>
<ul>
<li>位置&#x2F;大小发生变化（<code>RectTransform</code> 变动）</li>
<li>内容变动（Text 文本变了）</li>
<li>属性变动（颜色、字体、sprite 等）</li>
</ul>
<p>Unity 会将这些 UI 元素加入到一个队列，在 Canvas 的渲染阶段进行一次“重建”。</p>
<hr>
<h2 id="🔍-Rebuild-的类型（对应-CanvasUpdate-枚举）"><a href="#🔍-Rebuild-的类型（对应-CanvasUpdate-枚举）" class="headerlink" title="🔍 Rebuild 的类型（对应 CanvasUpdate 枚举）"></a>🔍 Rebuild 的类型（对应 <code>CanvasUpdate</code> 枚举）</h2><p>Unity 的 Rebuild 会按照 <strong>5 个阶段</strong>进行处理，分别是：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> CanvasUpdate &#123;</span><br><span class="line">    Prelayout,</span><br><span class="line">    Layout,</span><br><span class="line">    PostLayout,</span><br><span class="line">    PreRender,</span><br><span class="line">    LatePreRender,</span><br><span class="line">    MaxUpdateValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些阶段由 <code>CanvasUpdateRegistry</code> 控制，主要包括两类 Rebuild：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>触发者</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Layout Rebuild</strong></td>
<td>布局信息变更（如<code>HorizontalLayoutGroup</code>）</td>
<td><code>ILayoutElement</code>、<code>ILayoutController</code></td>
</tr>
<tr>
<td><strong>Graphic Rebuild</strong></td>
<td>视觉元素变更（如 <code>Image</code>, <code>Text</code> 内容）</td>
<td><code>Graphic</code>, <code>IMeshModifier</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="🚨-常见-Rebuild-导致性能问题的原因"><a href="#🚨-常见-Rebuild-导致性能问题的原因" class="headerlink" title="🚨 常见 Rebuild 导致性能问题的原因"></a>🚨 常见 Rebuild 导致性能问题的原因</h2><table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>频繁修改 Text &#x2F; Image</td>
<td>每次都会触发 Layout 或 Graphic Rebuild</td>
</tr>
<tr>
<td>RectTransform 动态变化</td>
<td>会导致父物体及子物体一起重建</td>
</tr>
<tr>
<td>ContentSizeFitter、LayoutGroup 滥用</td>
<td>它们高度依赖 Rebuild，效率低下</td>
</tr>
<tr>
<td>SetActive(false&#x2F;true) UI元素</td>
<td>重新激活会触发全部子元素重建</td>
</tr>
<tr>
<td>动画修改 UI 位置</td>
<td>每帧调用 <code>SetPosition</code> 会触发 Rebuild</td>
</tr>
<tr>
<td>ScrollView 滚动项频繁刷新</td>
<td>若没有对象池复用，每帧都 Rebuild</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔧-如何分析-Rebuild（工具-方法）"><a href="#🔧-如何分析-Rebuild（工具-方法）" class="headerlink" title="🔧 如何分析 Rebuild（工具 &amp; 方法）"></a>🔧 如何分析 Rebuild（工具 &amp; 方法）</h2><h3 id="✅-1-使用-Profiler"><a href="#✅-1-使用-Profiler" class="headerlink" title="✅ 1. 使用 Profiler"></a>✅ 1. 使用 <strong>Profiler</strong></h3><ol>
<li><p>打开 Unity Profiler（Window &gt; Analysis &gt; Profiler）。</p>
</li>
<li><p>查看 <strong>UI 系统模块</strong>（Rendering &#x2F; UI）：</p>
<ul>
<li><strong>Canvas.SendWillRenderCanvases</strong></li>
<li><strong>Canvas.BuildBatch</strong></li>
<li><strong>Canvas.UpdateBatches</strong></li>
<li><strong>Canvas.SendPreWillRenderCanvases</strong></li>
</ul>
<p>如果这些函数耗时很长或频繁出现，说明 Rebuild 很频繁。</p>
</li>
</ol>
<h3 id="✅-2-使用-UI-Debug-工具-Debug-输出"><a href="#✅-2-使用-UI-Debug-工具-Debug-输出" class="headerlink" title="✅ 2. 使用 UI Debug 工具 &#x2F; Debug 输出"></a>✅ 2. 使用 <strong>UI Debug 工具 &#x2F; Debug 输出</strong></h3><h4 id="方法一：在-IMeshModifier-或-ILayoutElement-中添加日志"><a href="#方法一：在-IMeshModifier-或-ILayoutElement-中添加日志" class="headerlink" title="方法一：在 IMeshModifier 或 ILayoutElement 中添加日志"></a>方法一：在 <code>IMeshModifier</code> 或 <code>ILayoutElement</code> 中添加日志</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DebugLayoutElement</span> : <span class="title">MonoBehaviour</span>, <span class="title">ILayoutElement</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputHorizontal</span>()</span> &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;<span class="subst">&#123;name&#125;</span> - CalculateLayoutInputHorizontal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CalculateLayoutInputVertical</span>()</span> &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;<span class="subst">&#123;name&#125;</span> - CalculateLayoutInputVertical&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> minWidth =&gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> preferredWidth =&gt; <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> flexibleWidth =&gt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> minHeight =&gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> preferredHeight =&gt; <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> flexibleHeight =&gt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> layoutPriority =&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：继承-Graphic-打印-OnPopulateMesh"><a href="#方法二：继承-Graphic-打印-OnPopulateMesh" class="headerlink" title="方法二：继承 Graphic 打印 OnPopulateMesh"></a>方法二：继承 <code>Graphic</code> 打印 <code>OnPopulateMesh</code></h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPopulateMesh</span>(<span class="params">VertexHelper vh</span>)</span> &#123;</span><br><span class="line">    Debug.Log(<span class="string">$&quot;<span class="subst">&#123;name&#125;</span> - Graphic Rebuild&quot;</span>);</span><br><span class="line">    <span class="keyword">base</span>.OnPopulateMesh(vh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-如何优化频繁-Rebuild-的-UI"><a href="#✅-如何优化频繁-Rebuild-的-UI" class="headerlink" title="✅ 如何优化频繁 Rebuild 的 UI"></a>✅ 如何优化频繁 Rebuild 的 UI</h2><table>
<thead>
<tr>
<th>优化手段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>合理拆分 Canvas</td>
<td>大的 UI 拆为多个 Canvas（静态&#x2F;动态分开）</td>
</tr>
<tr>
<td>使用 CanvasGroup 控制显隐</td>
<td>避免频繁使用 <code>SetActive</code></td>
</tr>
<tr>
<td>尽量不要频繁修改 Text</td>
<td>特别是数字跳动的情况，建议合并&#x2F;缓存</td>
</tr>
<tr>
<td>减少使用 LayoutGroup + ContentSizeFitter</td>
<td>用 Anchor + 脚本代替</td>
</tr>
<tr>
<td>滚动列表使用对象池复用</td>
<td>避免每帧加载&#x2F;卸载</td>
</tr>
</tbody></table>
<hr>
<h2 id="🎯-补充：Canvas-Rebuild-vs-DrawCall-的区别"><a href="#🎯-补充：Canvas-Rebuild-vs-DrawCall-的区别" class="headerlink" title="🎯 补充：Canvas Rebuild vs DrawCall 的区别"></a>🎯 补充：Canvas Rebuild vs DrawCall 的区别</h2><ul>
<li><strong>Rebuild</strong>：UI 元素的计算、重建、顶点重构阶段，对 CPU 有压力</li>
<li><strong>DrawCall</strong>：UI 实际绘制阶段，对 GPU 有压力</li>
<li>两者互相独立，但经常一起出现（UI 更新频繁就会导致两者上升）</li>
</ul>
<hr>
<h2 id="🧠-总结"><a href="#🧠-总结" class="headerlink" title="🧠 总结"></a>🧠 总结</h2><table>
<thead>
<tr>
<th>关键点</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>Rebuild 是什么</td>
<td>UI 元素更新时的重建逻辑（布局或图形）</td>
</tr>
<tr>
<td>如何查看</td>
<td>Profiler + 日志 + Frame Debugger</td>
</tr>
<tr>
<td>如何优化</td>
<td>拆 Canvas、避免频繁变化、用对象池、少用 LayoutGroup</td>
</tr>
</tbody></table>
<hr>
<p>如果你能贴出当前频繁触发 Rebuild 的 UI 层级截图或结构，我可以进一步帮你定位是哪类组件或结构导致的性能瓶颈。是否需要我给你一个自动统计每帧 UI Rebuild 的脚本？</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Scene 优化</title>
    <url>/2025/06/17/Unity%20Scene%20%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>我做的编辑器拓展开发，卡顿是出现在通过配置生成上万个带指向的3d球体和linerenderer，根据每个点的配置信息来设置球体的旋转偏量，3d空间位置,两个点之间通过linerenderer连接，创建过程耗时很长，卡顿是出现在编辑器静态界面，而非运行状态。当前面临的 <strong>编辑器卡顿问题</strong>，本质上是因为：</p>
<blockquote>
<p>✅ 在 <strong>非运行时的编辑器模式（EditMode）中批量生成上万个带有 Mesh 和 LineRenderer 的 GameObject</strong>，Unity 会：</p>
<ul>
<li>每次 <code>GameObject.Instantiate()</code> 都触发内部注册与序列化</li>
<li>每个 LineRenderer 或 Transform 修改都会立即记录在场景状态中</li>
<li>在主线程阻塞执行，触发 <strong>大量 Hierarchy 刷新、Inspector 重绘、Undo 缓存注册、序列化数据写入</strong><br>→ 导致 Unity 编辑器卡死或极度卡顿</li>
</ul>
</blockquote>
<hr>
<h2 id="✅-针对性优化建议（编辑器扩展模式专属）"><a href="#✅-针对性优化建议（编辑器扩展模式专属）" class="headerlink" title="✅ 针对性优化建议（编辑器扩展模式专属）"></a>✅ 针对性优化建议（编辑器扩展模式专属）</h2><hr>
<h3 id="🧱-一、核心优化原则"><a href="#🧱-一、核心优化原则" class="headerlink" title="🧱 一、核心优化原则"></a>🧱 一、核心优化原则</h3><table>
<thead>
<tr>
<th>问题来源</th>
<th>优化手段</th>
</tr>
</thead>
<tbody><tr>
<td>每个 <code>GameObject</code> 实时创建、注册 Undo、序列化</td>
<td>✅ 使用 <code>EditorApplication.delayCall</code> 分批异步创建 &#x2F; 禁用 Undo</td>
</tr>
<tr>
<td>每次 Transform 设置都会触发刷新</td>
<td>✅ 批量设置坐标，<strong>禁用场景刷新</strong>（SceneView.RepaintControl）</td>
</tr>
<tr>
<td>每个对象生成都立即刷新 Hierarchy</td>
<td>✅ <strong>临时关闭自动刷新界面</strong>，批量结束后一次性刷新</td>
</tr>
<tr>
<td>每次 <code>LineRenderer.SetPositions()</code> 修改也会导致 GC</td>
<td>✅ 合并线段&#x2F;简化结构&#x2F;使用 GPU 绘制优化线渲染</td>
</tr>
</tbody></table>
<hr>
<h3 id="🔧-二、操作级优化方式（编辑器端）"><a href="#🔧-二、操作级优化方式（编辑器端）" class="headerlink" title="🔧 二、操作级优化方式（编辑器端）"></a>🔧 二、操作级优化方式（编辑器端）</h3><h4 id="✅-1-禁用-Undo-RecordObject"><a href="#✅-1-禁用-Undo-RecordObject" class="headerlink" title="✅ 1. 禁用 Undo.RecordObject"></a>✅ 1. 禁用 Undo.RecordObject</h4><p>如果不是必要的编辑器撤销操作，<strong>禁用 <code>Undo.RegisterCreatedObjectUndo()</code></strong> 可以显著减少性能开销：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GameObject go = GameObject.Instantiate(prefab);</span><br><span class="line">go.transform.SetParent(parent, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 删除 Undo 这句 ↓</span></span><br><span class="line"><span class="comment">// Undo.RegisterCreatedObjectUndo(go, &quot;Create Point&quot;);</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="✅-2-批量暂停-Scene-刷新-Hierarchy-重绘"><a href="#✅-2-批量暂停-Scene-刷新-Hierarchy-重绘" class="headerlink" title="✅ 2. 批量暂停 Scene 刷新 + Hierarchy 重绘"></a>✅ 2. 批量暂停 Scene 刷新 + Hierarchy 重绘</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">EditorApplication.delayCall += () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 暂停场景刷新</span></span><br><span class="line">    SceneView.duringSceneGui -= OnSceneGUI; <span class="comment">// 如果你有实时绘制</span></span><br><span class="line">    EditorApplication.QueuePlayerLoopUpdate(); <span class="comment">// 延迟刷新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; configData.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        CreateOnePoint(configData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动刷新场景与 Hierarchy</span></span><br><span class="line">    SceneView.RepaintAll();</span><br><span class="line">    EditorApplication.RepaintHierarchyWindow();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="✅-3-使用-Coroutine-风格的异步分帧生成（模拟帧分批）"><a href="#✅-3-使用-Coroutine-风格的异步分帧生成（模拟帧分批）" class="headerlink" title="✅ 3. 使用 Coroutine 风格的异步分帧生成（模拟帧分批）"></a>✅ 3. 使用 Coroutine 风格的异步分帧生成（模拟帧分批）</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">GeneratePointsStepByStep</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> batchSize = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; allPoints.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        CreateOnePoint(allPoints[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i % batchSize == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 下一帧</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Debug.Log(<span class="string">&quot;生成完成！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 <code>EditorCoroutineUtility.StartCoroutine(GeneratePointsStepByStep(), this)</code> 来调用</p>
<blockquote>
<p>✅ 来自 Unity.EditorCoroutines 包，推荐引入用于编辑器分帧逻辑</p>
</blockquote>
<hr>
<h4 id="✅-4-创建时不要激活-GameObject，最后一起启用"><a href="#✅-4-创建时不要激活-GameObject，最后一起启用" class="headerlink" title="✅ 4. 创建时不要激活 GameObject，最后一起启用"></a>✅ 4. 创建时不要激活 GameObject，最后一起启用</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GameObject go = Instantiate(prefab);</span><br><span class="line">go.SetActive(<span class="literal">false</span>); <span class="comment">// 禁用初始化逻辑和渲染负担</span></span><br><span class="line"><span class="comment">// 设置坐标、旋转等</span></span><br><span class="line">go.SetActive(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="✅-5-使用-Mesh-或-DrawMesh-替代-LineRenderer（合并优化）"><a href="#✅-5-使用-Mesh-或-DrawMesh-替代-LineRenderer（合并优化）" class="headerlink" title="✅ 5. 使用 Mesh 或 DrawMesh 替代 LineRenderer（合并优化）"></a>✅ 5. 使用 Mesh 或 DrawMesh 替代 LineRenderer（合并优化）</h4><ul>
<li>将多个线段数据汇总，手动用 <code>GL.LINES</code> 或 <code>Graphics.DrawMeshNow()</code> 在 SceneView 渲染而不是生成上万个 LineRenderer</li>
<li>或者使用一个 <code>Mesh</code> 合并所有线段的渲染顶点，自定义材质渲染</li>
</ul>
<hr>
<h2 id="📌-Bonus：GPU-绘制线连接方案（不生成-GameObject）"><a href="#📌-Bonus：GPU-绘制线连接方案（不生成-GameObject）" class="headerlink" title="📌 Bonus：GPU 绘制线连接方案（不生成 GameObject）"></a>📌 Bonus：GPU 绘制线连接方案（不生成 GameObject）</h2><ul>
<li>使用一个 <code>ScriptableObject</code> 维护线段列表</li>
<li>在 Scene GUI 中绘制：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Handles.color = Color.green;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; lines.Count; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Handles.DrawLine(lines[i].start, lines[i].end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>➡️ 不创建 GameObject，不占用层级，无 GC&#x2F;卡顿 ✅</p>
<hr>
<h2 id="✅-推荐组合优化方案（低开销）"><a href="#✅-推荐组合优化方案（低开销）" class="headerlink" title="✅ 推荐组合优化方案（低开销）"></a>✅ 推荐组合优化方案（低开销）</h2><table>
<thead>
<tr>
<th>目标</th>
<th>实现方式</th>
</tr>
</thead>
<tbody><tr>
<td>支持查看上万个点 + 连接线</td>
<td><code>Handles.DrawLine()</code> 在 SceneView 中实时渲染</td>
</tr>
<tr>
<td>支持选中点位</td>
<td>注册 <code>HandleUtility.AddDefaultControl()</code> + <code>HandleUtility.PickGameObject</code> 实现点击识别</td>
</tr>
<tr>
<td>仅在运行前批量生成真实物体</td>
<td>提供按钮：“生成 GameObject” → 批量生成，<strong>不自动创建</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="🚀-实用工具推荐"><a href="#🚀-实用工具推荐" class="headerlink" title="🚀 实用工具推荐"></a>🚀 实用工具推荐</h2><ul>
<li>✅ <a href="https://docs.unity3d.com/Packages/com.unity.editorcoroutines@1.0/manual/index.html">Editor Coroutines</a>：编辑器异步分帧执行逻辑</li>
<li>✅ <a href="https://docs.unity3d.com/ScriptReference/SceneView-onSceneGUIDelegate.html">SceneView.onSceneGUIDelegate</a>：用于绘制线、不创建对象</li>
<li>✅ <a href="https://odininspector.com/">Odin Inspector</a>：可视化控制面板和配置生成控制器</li>
</ul>
<hr>
<h2 id="🧠-总结"><a href="#🧠-总结" class="headerlink" title="🧠 总结"></a>🧠 总结</h2><table>
<thead>
<tr>
<th>类型</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>❌ 不要</td>
<td>一次性创建上万个 GameObject + LineRenderer（会卡）</td>
</tr>
<tr>
<td>✅ 推荐</td>
<td>分批延迟创建、禁用 Undo、绘制到 Scene GUI 替代真实对象</td>
</tr>
<tr>
<td>🛠️ 补充</td>
<td>可以提供一个“点位配置→可视化→生成真实节点”的分离工具</td>
</tr>
</tbody></table>
<hr>
<p>你在 <code>OnSceneGUI</code> 中绘制上万条线，导致移动视角卡顿，是 <strong>合理且常见的问题</strong>。原因如下：</p>
<hr>
<h3 id="🧠-原因：Handles-DrawLine-在-OnSceneGUI-中是-CPU-密集型-每帧运行"><a href="#🧠-原因：Handles-DrawLine-在-OnSceneGUI-中是-CPU-密集型-每帧运行" class="headerlink" title="🧠 原因：Handles.DrawLine 在 OnSceneGUI 中是 CPU 密集型 + 每帧运行"></a>🧠 原因：<code>Handles.DrawLine</code> 在 <code>OnSceneGUI</code> 中是 CPU 密集型 + 每帧运行</h3><ul>
<li>每次移动场景视角时，<code>SceneView.OnSceneGUI</code> 都会触发重新绘制</li>
<li><code>Handles.DrawLine</code> 属于 <strong>Immediate Mode GUI</strong>（IMGUI），无法批量合批优化</li>
<li>当你绘制上万个点或线段，编辑器主线程完全吃满（全在 CPU 上渲染、无缓存）</li>
</ul>
<hr>
<h2 id="✅-解决方案：降低绘制密度-使用-GPU-批量绘制"><a href="#✅-解决方案：降低绘制密度-使用-GPU-批量绘制" class="headerlink" title="✅ 解决方案：降低绘制密度 + 使用 GPU 批量绘制"></a>✅ 解决方案：降低绘制密度 + 使用 GPU 批量绘制</h2><hr>
<h3 id="✅-方案一：仅在静止或需要时绘制（减少频率）"><a href="#✅-方案一：仅在静止或需要时绘制（减少频率）" class="headerlink" title="✅ 方案一：仅在静止或需要时绘制（减少频率）"></a>✅ 方案一：仅在静止或需要时绘制（减少频率）</h3><p>你可以 <strong>只在窗口打开或点击按钮时才绘制一次</strong>，而不是一直监听 <code>SceneView.duringSceneGui</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> forceDraw = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;预览线条&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        forceDraw = <span class="literal">true</span>;</span><br><span class="line">        SceneView.RepaintAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSceneGUI</span>(<span class="params">SceneView view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!forceDraw) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 画完一帧后不再绘制</span></span><br><span class="line">    forceDraw = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    DrawLinesOnce(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="✅-方案二：GL-CommandBuffer-批量绘制（推荐）"><a href="#✅-方案二：GL-CommandBuffer-批量绘制（推荐）" class="headerlink" title="✅ 方案二：GL + CommandBuffer 批量绘制（推荐）"></a>✅ 方案二：GL + CommandBuffer 批量绘制（推荐）</h3><p>可以使用 <code>GL.LINES</code> + 自定义材质，在 GPU 中绘制所有线条，一次性渲染，不产生 GC 和 CPU 压力。</p>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>创建一个材质（使用 <code>Unlit/Color</code> 或自定义 Shader）</li>
<li>在 Scene GUI 中注册一个 <code>Camera.onPostRender</code> 或 <code>SceneView.onSceneGUIDelegate</code></li>
<li>使用 <code>GL.Begin(GL.LINES)</code> 批量绘制所有连接线</li>
</ol>
<h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">InitializeOnLoad</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LineDrawer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> Material lineMat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">LineDrawer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SceneView.duringSceneGui += OnSceneGUI;</span><br><span class="line">        lineMat = <span class="keyword">new</span> Material(Shader.Find(<span class="string">&quot;Hidden/Internal-Colored&quot;</span>));</span><br><span class="line">        lineMat.hideFlags = HideFlags.HideAndDontSave;</span><br><span class="line">        lineMat.SetInt(<span class="string">&quot;_ZWrite&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        lineMat.SetInt(<span class="string">&quot;_Cull&quot;</span>, (<span class="built_in">int</span>)UnityEngine.Rendering.CullMode.Off);</span><br><span class="line">        lineMat.SetInt(<span class="string">&quot;_ZTest&quot;</span>, (<span class="built_in">int</span>)UnityEngine.Rendering.CompareFunction.Always);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnSceneGUI</span>(<span class="params">SceneView sceneView</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!shouldDraw) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Handles.BeginGUI();</span><br><span class="line">        <span class="comment">// 可在 GUI 绘制按钮等</span></span><br><span class="line">        Handles.EndGUI();</span><br><span class="line"></span><br><span class="line">        GL.PushMatrix();</span><br><span class="line">        lineMat.SetPass(<span class="number">0</span>);</span><br><span class="line">        GL.LoadProjectionMatrix(sceneView.camera.projectionMatrix);</span><br><span class="line">        GL.modelview = sceneView.camera.worldToCameraMatrix;</span><br><span class="line"></span><br><span class="line">        GL.Begin(GL.LINES);</span><br><span class="line">        GL.Color(Color.yellow);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> (a, b) <span class="keyword">in</span> lines)</span><br><span class="line">        &#123;</span><br><span class="line">            GL.Vertex(a);</span><br><span class="line">            GL.Vertex(b);</span><br><span class="line">        &#125;</span><br><span class="line">        GL.End();</span><br><span class="line"></span><br><span class="line">        GL.PopMatrix();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">bool</span> shouldDraw = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">static</span> List&lt;(Vector3, Vector3)&gt; lines = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetLines</span>(<span class="params">List&lt;(Vector3, Vector3</span>)&gt; lineData)</span></span><br><span class="line">    &#123;</span><br><span class="line">        lines = lineData;</span><br><span class="line">        shouldDraw = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>✅ 优势：</p>
<ul>
<li>使用 GPU 绘制，不卡顿</li>
<li>不生成 GameObject，也不会触发 Scene 刷新</li>
<li>可实时预览 + 快速刷新</li>
</ul>
</blockquote>
<hr>
<h3 id="✅-方案三：对远离视野的线段-点位做视锥剔除"><a href="#✅-方案三：对远离视野的线段-点位做视锥剔除" class="headerlink" title="✅ 方案三：对远离视野的线段&#x2F;点位做视锥剔除"></a>✅ 方案三：对远离视野的线段&#x2F;点位做视锥剔除</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (SceneView.lastActiveSceneView != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> cam = SceneView.lastActiveSceneView.camera;</span><br><span class="line">    Plane[] planes = GeometryUtility.CalculateFrustumPlanes(cam);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> (a, b) <span class="keyword">in</span> links)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GeometryUtility.TestPlanesAABB(planes, <span class="keyword">new</span> Bounds((a + b) / <span class="number">2</span>, Vector3.one * <span class="number">0.5f</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            Handles.DrawLine(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>📌 降低绘制线段数量，对可见部分仅绘制，性能可大幅提升</p>
</blockquote>
<hr>
<h2 id="✅-总结推荐"><a href="#✅-总结推荐" class="headerlink" title="✅ 总结推荐"></a>✅ 总结推荐</h2><table>
<thead>
<tr>
<th>场景需求</th>
<th>推荐方案</th>
</tr>
</thead>
<tbody><tr>
<td>上万条线，实时预览</td>
<td>✅ 使用 <code>GL.LINES</code> 批量绘制，避免 <code>Handles.DrawLine</code></td>
</tr>
<tr>
<td>临时静态可视化</td>
<td>只绘制一次 <code>OnSceneGUI</code>，绘完关闭</td>
</tr>
<tr>
<td>编辑器工具面板控制</td>
<td>提供“开启预览”、“关闭预览”按钮控制绘制状态</td>
</tr>
<tr>
<td>远距离线段过滤</td>
<td>添加视锥剔除只绘可见连接线</td>
</tr>
</tbody></table>
<hr>
<h3 id="❗你遇到的问题"><a href="#❗你遇到的问题" class="headerlink" title="❗你遇到的问题"></a>❗你遇到的问题</h3><ol>
<li><p><strong>使用 <code>GL.LINES</code> 绘制的线段</strong>，确实<strong>不会自动跟随 Scene 中对象的移动</strong>，因为 <code>GL.Vertex</code> 是在 <code>SceneView.camera</code> 的一次性投影矩阵下静态绘制的，除非你主动刷新数据。</p>
</li>
<li><p><strong>你在编辑器 Scene 操作顶点（或对象）时卡顿</strong>，是因为：</p>
<ul>
<li>你每帧都进行 <strong>大量线段计算 + 绘制（如上万个）</strong></li>
<li>并且你不断访问&#x2F;同步变化的坐标 → 每帧都 CPU 扫一次全量顶点 → 毫无缓存</li>
</ul>
</li>
</ol>
<hr>
<h2 id="✅-解决方案：动态、流式、可跟随的高效绘制策略"><a href="#✅-解决方案：动态、流式、可跟随的高效绘制策略" class="headerlink" title="✅ 解决方案：动态、流式、可跟随的高效绘制策略"></a>✅ 解决方案：动态、流式、可跟随的高效绘制策略</h2><hr>
<h3 id="✅-方案一：仅展示当前视野范围的少量线段"><a href="#✅-方案一：仅展示当前视野范围的少量线段" class="headerlink" title="✅ 方案一：仅展示当前视野范围的少量线段"></a>✅ 方案一：<strong>仅展示当前视野范围的少量线段</strong></h3><p>结合视锥体剔除 + 距离裁剪，大幅降低绘制压力：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Plane[] planes = GeometryUtility.CalculateFrustumPlanes(sceneCam);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> (a, b) <span class="keyword">in</span> links)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> mid = (a + b) * <span class="number">0.5f</span>;</span><br><span class="line">    <span class="keyword">if</span> (!GeometryUtility.TestPlanesAABB(planes, <span class="keyword">new</span> Bounds(mid, Vector3.one * <span class="number">1f</span>))) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有视野范围内的才画</span></span><br><span class="line">    GL.Vertex(a);</span><br><span class="line">    GL.Vertex(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="✅-方案二：仅绘制选中或焦点区域的连接线"><a href="#✅-方案二：仅绘制选中或焦点区域的连接线" class="headerlink" title="✅ 方案二：仅绘制选中或焦点区域的连接线"></a>✅ 方案二：<strong>仅绘制选中或焦点区域的连接线</strong></h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Vector3 camPos = sceneCam.transform.position;</span><br><span class="line"><span class="built_in">float</span> maxDrawDistance = <span class="number">100f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> (a, b) <span class="keyword">in</span> links)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((a - camPos).sqrMagnitude &gt; maxDrawDistance * maxDrawDistance &amp;&amp;</span><br><span class="line">        (b - camPos).sqrMagnitude &gt; maxDrawDistance * maxDrawDistance)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    GL.Vertex(a);</span><br><span class="line">    GL.Vertex(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="✅-方案三：数据缓存-变化时更新"><a href="#✅-方案三：数据缓存-变化时更新" class="headerlink" title="✅ 方案三：数据缓存 + 变化时更新"></a>✅ 方案三：<strong>数据缓存 + 变化时更新</strong></h3><p>你需要避免每帧都全量重计算所有坐标。可以这样优化：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Vector3&gt; cachedPoints = <span class="keyword">new</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> needUpdate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateDataIfNeeded</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!needUpdate) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    cachedPoints.Clear();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> go <span class="keyword">in</span> allPointObjects)</span><br><span class="line">        cachedPoints.Add(go.transform.position);</span><br><span class="line"></span><br><span class="line">    needUpdate = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSceneGUI</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    UpdateDataIfNeeded();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制线段用 cachedPoints</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在对象位置变化时设置 <code>needUpdate = true</code>。你可以：</p>
<ul>
<li>用 <code>EditorApplication.hierarchyChanged</code> 监听结构变化</li>
<li>或在 <code>Selection</code> 改变时做刷新</li>
</ul>
<hr>
<h3 id="✅-方案四：使用-Graphics-DrawMeshNow-合批绘制动态线条"><a href="#✅-方案四：使用-Graphics-DrawMeshNow-合批绘制动态线条" class="headerlink" title="✅ 方案四：使用 Graphics.DrawMeshNow 合批绘制动态线条"></a>✅ 方案四：使用 <code>Graphics.DrawMeshNow</code> 合批绘制动态线条</h3><p>自己生成一整张 <code>Mesh</code>（比如线段的 cylinder 或 quad），然后一次性 <code>Graphics.DrawMeshNow()</code> 绘制所有线段，这种方式：</p>
<ul>
<li>支持跟随坐标变动（每帧更新 mesh）</li>
<li>GPU 绘制，不卡</li>
<li>可打包成 <code>GizmosRenderer</code> 或 <code>SceneView</code> 工具</li>
</ul>
<p>这是很多大型编辑器工具（如 DOTS Inspector、AI Debugger）常用方案。</p>
<hr>
<h2 id="🔧-如果你要动态显示-更新线段，并跟随场景中球体移动"><a href="#🔧-如果你要动态显示-更新线段，并跟随场景中球体移动" class="headerlink" title="🔧 如果你要动态显示&#x2F;更新线段，并跟随场景中球体移动"></a>🔧 如果你要动态显示&#x2F;更新线段，并跟随场景中球体移动</h2><h3 id="✅-最佳方案组合建议："><a href="#✅-最佳方案组合建议：" class="headerlink" title="✅ 最佳方案组合建议："></a>✅ 最佳方案组合建议：</h3><table>
<thead>
<tr>
<th>项目</th>
<th>使用方式</th>
</tr>
</thead>
<tbody><tr>
<td>点位</td>
<td>实体使用 <code>GameObject + Sphere</code>（可交互、选中）</td>
</tr>
<tr>
<td>连线</td>
<td>用单个 <code>Mesh</code> 合批绘制所有线段，动态更新（非 <code>LineRenderer</code>，避免生成上万个）</td>
</tr>
<tr>
<td>性能保障</td>
<td>添加视锥体剔除 + 距离剔除逻辑</td>
</tr>
<tr>
<td>数据管理</td>
<td>使用数组缓存点位坐标，仅在坐标改变时更新一次线段 <code>Mesh</code></td>
</tr>
<tr>
<td>触发更新</td>
<td>使用自定义按钮 &#x2F; Unity <code>EditorApplication.update</code> &#x2F; <code>SceneView.duringSceneGui</code> 判断是否需要更新</td>
</tr>
</tbody></table>
<hr>
<h3 id="🚀-是否需要我帮你写一个："><a href="#🚀-是否需要我帮你写一个：" class="headerlink" title="🚀 是否需要我帮你写一个："></a>🚀 是否需要我帮你写一个：</h3><ul>
<li>自动从所有球体位置构建一张合批线段 <code>Mesh</code></li>
<li>支持动态更新（如某球体移动后线段自动更新）</li>
<li>不依赖 LineRenderer 或 GL，每次仅绘制 1 个合批对象</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity 后置界面截图代替</title>
    <url>/2025/06/17/Unity%20%E5%90%8E%E7%BD%AE%E7%95%8C%E9%9D%A2%E6%88%AA%E5%9B%BE%E4%BB%A3%E6%9B%BF/</url>
    <content><![CDATA[<p>这是一个非常实用且高级的 UI 性能优化技巧，尤其适用于<strong>多层 UI 堆叠、全屏窗口频繁切换</strong>的游戏中，比如背包、商店、角色等互相遮挡但不会频繁更新的界面。</p>
<hr>
<h2 id="🧠-目标描述"><a href="#🧠-目标描述" class="headerlink" title="🧠 目标描述"></a>🧠 目标描述</h2><blockquote>
<p><strong>将被遮挡的 UI 页面（非焦点）截图为一张静态图片，然后只显示截图，暂时不渲染真实 UI 元素</strong>，以降低 DrawCall 和 Canvas Rebuild 负担，充分释放 GPU 渲染资源。</p>
</blockquote>
<hr>
<h2 id="✅-技术实现步骤（Unity-UGUI）"><a href="#✅-技术实现步骤（Unity-UGUI）" class="headerlink" title="✅ 技术实现步骤（Unity UGUI）"></a>✅ 技术实现步骤（Unity UGUI）</h2><p>我们以“将后置界面截图 + 替换显示 + 隐藏原始 UI”为例讲解：</p>
<hr>
<h3 id="🧱-Step-1：截图后置-UI（RenderTexture-或-ReadPixels）"><a href="#🧱-Step-1：截图后置-UI（RenderTexture-或-ReadPixels）" class="headerlink" title="🧱 Step 1：截图后置 UI（RenderTexture 或 ReadPixels）"></a>🧱 Step 1：截图后置 UI（RenderTexture 或 <code>ReadPixels</code>）</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Texture2D <span class="title">CaptureUIScreen</span>(<span class="params">RectTransform targetRect</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 获取 UI 区域在屏幕空间的位置</span></span><br><span class="line">    Vector3[] corners = <span class="keyword">new</span> Vector3[<span class="number">4</span>];</span><br><span class="line">    targetRect.GetWorldCorners(corners);</span><br><span class="line">    Rect rect = <span class="keyword">new</span> Rect(corners[<span class="number">0</span>].x, corners[<span class="number">0</span>].y, </span><br><span class="line">                         corners[<span class="number">2</span>].x - corners[<span class="number">0</span>].x, </span><br><span class="line">                         corners[<span class="number">2</span>].y - corners[<span class="number">0</span>].y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 读取像素</span></span><br><span class="line">    Texture2D tex = <span class="keyword">new</span> Texture2D((<span class="built_in">int</span>)rect.width, (<span class="built_in">int</span>)rect.height, TextureFormat.RGB24, <span class="literal">false</span>);</span><br><span class="line">    tex.ReadPixels(rect, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    tex.Apply();</span><br><span class="line">    <span class="keyword">return</span> tex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>✅ <strong>推荐更高效方式：用 <code>RenderTexture + Camera.Render()</code> 单独渲染 UI 区域而不是 ReadPixels，避免阻塞主线程</strong>（下面会说）</p>
</blockquote>
<hr>
<h3 id="📦-Step-2：用-RawImage-显示截图内容"><a href="#📦-Step-2：用-RawImage-显示截图内容" class="headerlink" title="📦 Step 2：用 RawImage 显示截图内容"></a>📦 Step 2：用 <code>RawImage</code> 显示截图内容</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">RawImage screenshotDisplay;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowScreenshot</span>(<span class="params">Texture2D tex</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (screenshotDisplay == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GameObject go = <span class="keyword">new</span> GameObject(<span class="string">&quot;ScreenshotUI&quot;</span>, <span class="keyword">typeof</span>(RectTransform), <span class="keyword">typeof</span>(CanvasRenderer), <span class="keyword">typeof</span>(RawImage));</span><br><span class="line">        go.transform.SetParent(你的Canvas.transform);</span><br><span class="line">        screenshotDisplay = go.GetComponent&lt;RawImage&gt;();</span><br><span class="line">        screenshotDisplay.rectTransform.anchorMin = Vector2.zero;</span><br><span class="line">        screenshotDisplay.rectTransform.anchorMax = Vector2.one;</span><br><span class="line">        screenshotDisplay.rectTransform.offsetMin = Vector2.zero;</span><br><span class="line">        screenshotDisplay.rectTransform.offsetMax = Vector2.zero;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    screenshotDisplay.texture = tex;</span><br><span class="line">    screenshotDisplay.enabled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🔒-Step-3：隐藏真实-UI，锁定点击穿透"><a href="#🔒-Step-3：隐藏真实-UI，锁定点击穿透" class="headerlink" title="🔒 Step 3：隐藏真实 UI，锁定点击穿透"></a>🔒 Step 3：隐藏真实 UI，锁定点击穿透</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">真实UI.SetActive(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 或者只禁用组件，但保留位置</span></span><br><span class="line">真实UI.GetComponent&lt;CanvasGroup&gt;().alpha = <span class="number">0</span>;</span><br><span class="line">真实UI.GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="✅-Step-4（可选）：切换回来时恢复-UI"><a href="#✅-Step-4（可选）：切换回来时恢复-UI" class="headerlink" title="✅ Step 4（可选）：切换回来时恢复 UI"></a>✅ Step 4（可选）：切换回来时恢复 UI</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">真实UI.SetActive(<span class="literal">true</span>);</span><br><span class="line">screenshotDisplay.enabled = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🚀-推荐优化方式：用-RenderTexture-UI-摄像机单独渲染-UI"><a href="#🚀-推荐优化方式：用-RenderTexture-UI-摄像机单独渲染-UI" class="headerlink" title="🚀 推荐优化方式：用 RenderTexture + UI 摄像机单独渲染 UI"></a>🚀 推荐优化方式：用 <code>RenderTexture + UI 摄像机单独渲染 UI</code></h2><p>比 <code>ReadPixels</code> 更高效 ✅</p>
<ol>
<li>给 UI 界面加一层单独的 Canvas（<code>RenderMode = ScreenSpaceCamera</code>）</li>
<li>分配一个专属 UI 摄像机，输出到一个 RenderTexture</li>
<li>把这个 Texture 设置给 <code>RawImage</code></li>
<li>然后<strong>关闭原 UI Canvas 显示，保留截图</strong></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Camera uiCamera;</span><br><span class="line">RenderTexture rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CaptureWithCamera</span>(<span class="params">Canvas uiCanvas</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rt = <span class="keyword">new</span> RenderTexture(Screen.width, Screen.height, <span class="number">0</span>);</span><br><span class="line">    uiCamera.targetTexture = rt;</span><br><span class="line">    uiCamera.Render();</span><br><span class="line"></span><br><span class="line">    screenshotDisplay.texture = rt;</span><br><span class="line">    screenshotDisplay.enabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    uiCanvas.enabled = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📌-实用建议"><a href="#📌-实用建议" class="headerlink" title="📌 实用建议"></a>📌 实用建议</h2><table>
<thead>
<tr>
<th>项目</th>
<th>推荐做法</th>
</tr>
</thead>
<tbody><tr>
<td>UI 层级很多（嵌套 Canvas）</td>
<td>将“不可见的后层 UI”截图后禁用 Canvas 组件</td>
</tr>
<tr>
<td>UI 不频繁交互</td>
<td>完全截图为静态图</td>
</tr>
<tr>
<td>UI 中有动态内容</td>
<td>考虑部分截图或继续动态更新</td>
</tr>
<tr>
<td>需要点击穿透</td>
<td><code>RawImage.raycastTarget = false</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-优点总结"><a href="#✅-优点总结" class="headerlink" title="✅ 优点总结"></a>✅ 优点总结</h2><ul>
<li>🔥 <strong>大幅减少 DrawCall</strong>（隐藏真实 UI，RawImage 只需 1 DrawCall）</li>
<li>🚫 <strong>避免 Canvas Rebuild</strong>（UI 禁用或 alpha&#x3D;0）</li>
<li>🧠 <strong>优化 GPU 帧时间</strong>（尤其是堆叠多个大 UI）</li>
</ul>
<hr>
<h2 id="🎯-举例场景"><a href="#🎯-举例场景" class="headerlink" title="🎯 举例场景"></a>🎯 举例场景</h2><table>
<thead>
<tr>
<th>场景</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>背包界面被“角色换装界面”全屏遮挡</td>
<td>背包 UI 截图并替代显示，关闭其 Canvas</td>
</tr>
<tr>
<td>商店全屏 UI 切到签到页面</td>
<td>商店改为截图，不再实时渲染</td>
</tr>
<tr>
<td>模拟对话剧情</td>
<td>截图背景 UI，前景角色&#x2F;文本保持活动</td>
</tr>
</tbody></table>
<hr>
<p>如你需要我提供一个完整的封装脚本（支持 RenderTexture、RawImage 创建、Canvas 替换控制），可以直接发我你的 UI 管理方式或结构，我给你定制化生成。是否需要？</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity 打图集 - 合批减少DrawCall</title>
    <url>/2025/06/17/Unity%20%E6%89%93%E5%9B%BE%E9%9B%86%20-%20%E5%90%88%E6%89%B9%E5%87%8F%E5%B0%91DrawCall/</url>
    <content><![CDATA[<p>在 Unity 中，通过<strong>打图集（图集打包）+ Canvas 优化策略</strong>可以有效实现 <strong>UI 合批（Batching）</strong>，从而减少 DrawCall 提高性能。下面是详细说明和实战指导：</p>
<hr>
<h2 id="🧩-一、为什么打图集能减少-DrawCall？"><a href="#🧩-一、为什么打图集能减少-DrawCall？" class="headerlink" title="🧩 一、为什么打图集能减少 DrawCall？"></a>🧩 一、为什么打图集能减少 DrawCall？</h2><p>Unity UI 使用的是基于 Canvas 的渲染系统，<strong>同一个材质（图集）+ 同一个 Canvas + 无深度遮挡排序冲突</strong> 时，可以自动合并为一个 DrawCall。</p>
<p>举个例子：</p>
<ul>
<li>如果你有 100 个 UI 元素，使用的是 <strong>相同图集的 Sprite</strong>，且放在 <strong>同一个 Canvas</strong> 下，就只需要 <strong>1 个 DrawCall</strong>。</li>
<li>但如果他们用的是不同贴图、不同材质、不同 Shader，就需要多个 DrawCall。</li>
</ul>
<hr>
<h2 id="📦-二、图集如何打包（使用-Unity-自带-Sprite-Atlas）"><a href="#📦-二、图集如何打包（使用-Unity-自带-Sprite-Atlas）" class="headerlink" title="📦 二、图集如何打包（使用 Unity 自带 Sprite Atlas）"></a>📦 二、图集如何打包（使用 Unity 自带 Sprite Atlas）</h2><h3 id="✅-步骤一：创建-Sprite-Atlas-图集"><a href="#✅-步骤一：创建-Sprite-Atlas-图集" class="headerlink" title="✅ 步骤一：创建 Sprite Atlas 图集"></a>✅ 步骤一：创建 Sprite Atlas 图集</h3><ol>
<li><code>Assets &gt; Create &gt; 2D &gt; Sprite Atlas</code></li>
<li>给图集命名，例如 <code>UIAtlas_Main</code></li>
<li>选中图集，点击 Inspector 中的 <strong>Objects for Packing &gt; Add Object</strong></li>
<li>把你的 Sprite 图标拖进去</li>
<li>勾选 <code>Include in Build</code>（默认开启）</li>
<li>设置 Packing Tag（用于动态图集）</li>
</ol>
<blockquote>
<p>✔️ Unity 在构建或运行时会将图集中 Sprite 合并成一张大图，共用一套材质。</p>
</blockquote>
<hr>
<h3 id="✅-步骤二：确保引用的图片来自图集"><a href="#✅-步骤二：确保引用的图片来自图集" class="headerlink" title="✅ 步骤二：确保引用的图片来自图集"></a>✅ 步骤二：确保引用的图片来自图集</h3><p>你 UI 的 Image、Button 等组件要使用的是 <strong>图集中 Sprite</strong>，而不是原始散图。</p>
<hr>
<h3 id="✅-步骤三：检查合批条件"><a href="#✅-步骤三：检查合批条件" class="headerlink" title="✅ 步骤三：检查合批条件"></a>✅ 步骤三：检查合批条件</h3><p>想要成功合批，必须满足以下<strong>合批三要素</strong>：</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>相同材质（图集打包 + 使用相同 Shader）</td>
<td>否则材质切换会打断合批</td>
</tr>
<tr>
<td>相同 Canvas（Static Canvas 最好）</td>
<td>不同 Canvas 会分开渲染</td>
</tr>
<tr>
<td>没有 UI 组件遮挡冲突（深度&#x2F;排序）</td>
<td>会触发中断合批</td>
</tr>
</tbody></table>
<blockquote>
<p>⚠️ 设置 Sprite 的 <strong>Packing Tag</strong> 也要统一（用于旧的 SpritePacker 系统）</p>
</blockquote>
<hr>
<h2 id="🛠️-三、辅助工具（推荐使用）"><a href="#🛠️-三、辅助工具（推荐使用）" class="headerlink" title="🛠️ 三、辅助工具（推荐使用）"></a>🛠️ 三、辅助工具（推荐使用）</h2><h3 id="✅-Sprite-Atlas-Viewer"><a href="#✅-Sprite-Atlas-Viewer" class="headerlink" title="✅ Sprite Atlas Viewer"></a>✅ Sprite Atlas Viewer</h3><p>查看哪些 Sprite 打进图集。</p>
<h3 id="✅-Frame-Debugger（查看是否合批）"><a href="#✅-Frame-Debugger（查看是否合批）" class="headerlink" title="✅ Frame Debugger（查看是否合批）"></a>✅ Frame Debugger（查看是否合批）</h3><ol>
<li>打开 <code>Window &gt; Analysis &gt; Frame Debugger</code></li>
<li>Enable</li>
<li>在 UI 显示状态下，查看是否多个 UI 共享同一个材质（会合批），如果中间切了材质就说明被打断。</li>
</ol>
<hr>
<h2 id="💡-四、进一步优化建议"><a href="#💡-四、进一步优化建议" class="headerlink" title="💡 四、进一步优化建议"></a>💡 四、进一步优化建议</h2><table>
<thead>
<tr>
<th>优化点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>使用统一 Shader 和材质</strong></td>
<td>比如 UGUI 默认的 <code>UI/Default</code></td>
</tr>
<tr>
<td><strong>静态 UI 和动态 UI 分 Canvas</strong></td>
<td>动态变化（数值、动画）会频繁重建</td>
</tr>
<tr>
<td><strong>使用 CanvasGroup 控制显隐</strong></td>
<td>避免 <code>SetActive</code> 触发重建</td>
</tr>
<tr>
<td><strong>使用 UI 批处理分析器</strong>（Unity 2022+）</td>
<td>可查看 UI DrawCall 合批详情</td>
</tr>
<tr>
<td><strong>避免多 Sprite 图集打包在不同图集中</strong></td>
<td>跨图集无法合批</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-图集打包策略建议（常用实践）"><a href="#✅-图集打包策略建议（常用实践）" class="headerlink" title="✅ 图集打包策略建议（常用实践）"></a>✅ 图集打包策略建议（常用实践）</h2><table>
<thead>
<tr>
<th>图集名</th>
<th>包含内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>UIAtlas_Common</code></td>
<td>通用按钮、底框、面板背景</td>
<td>所有界面共享</td>
</tr>
<tr>
<td><code>UIAtlas_Home</code></td>
<td>主界面相关 UI 图</td>
<td>按功能模块拆分</td>
</tr>
<tr>
<td><code>UIAtlas_Fight</code></td>
<td>战斗中用到的 UI 元素</td>
<td>战斗场景专用，防止资源浪费</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-实战示例总结"><a href="#✅-实战示例总结" class="headerlink" title="✅ 实战示例总结"></a>✅ 实战示例总结</h2><p>假设你有以下 UI：</p>
<ul>
<li>按钮 A 用图 A</li>
<li>按钮 B 用图 B</li>
<li>图 A、图 B 都打在 <code>UIAtlas_Common</code></li>
</ul>
<p>→ 合批 ✅（1 DrawCall）</p>
<p>但如果：</p>
<ul>
<li>按钮 A 用图集 Atlas_A</li>
<li>按钮 B 用图集 Atlas_B</li>
</ul>
<p>→ 不合批 ❌（2 DrawCall）</p>
<hr>
<h2 id="📌-常见合批失败原因排查"><a href="#📌-常见合批失败原因排查" class="headerlink" title="📌 常见合批失败原因排查"></a>📌 常见合批失败原因排查</h2><table>
<thead>
<tr>
<th>问题</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>DrawCall 没减少</td>
<td>图集没用上 &#x2F; 材质不同</td>
</tr>
<tr>
<td>改变 Text 内容导致重新合批</td>
<td>每帧都会触发 Canvas rebuild</td>
</tr>
<tr>
<td>使用了不同的 Shader</td>
<td>材质不同就不能合批</td>
</tr>
<tr>
<td>动态加载的 Sprite 没入图集</td>
<td>需要用 Addressable Atlas &#x2F; SpriteAtlas</td>
</tr>
</tbody></table>
<hr>
<h2 id="🎯-总结"><a href="#🎯-总结" class="headerlink" title="🎯 总结"></a>🎯 总结</h2><table>
<thead>
<tr>
<th>步骤</th>
<th>要点</th>
</tr>
</thead>
<tbody><tr>
<td>打图集</td>
<td>使用 Sprite Atlas 包含所有常用 UI 图</td>
</tr>
<tr>
<td>引用图集</td>
<td>所有 Image &#x2F; SpriteRenderer 使用图集内图片</td>
</tr>
<tr>
<td>同 Canvas</td>
<td>尽量放在一个不频繁变化的 Canvas 下</td>
</tr>
<tr>
<td>用 Frame Debugger 验证</td>
<td>实时查看是否合批成功</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-①-“没有-UI-组件遮挡冲突（深度-排序）”-为什么会影响合批？"><a href="#✅-①-“没有-UI-组件遮挡冲突（深度-排序）”-为什么会影响合批？" class="headerlink" title="✅ ① “没有 UI 组件遮挡冲突（深度&#x2F;排序）” 为什么会影响合批？"></a>✅ ① “没有 UI 组件遮挡冲突（深度&#x2F;排序）” 为什么会影响合批？</h2><h3 id="🔍-背景知识：UI-合批的底层逻辑"><a href="#🔍-背景知识：UI-合批的底层逻辑" class="headerlink" title="🔍 背景知识：UI 合批的底层逻辑"></a>🔍 背景知识：UI 合批的底层逻辑</h3><p>Unity 的 UGUI 合批，基于 <strong>Z-order（绘制顺序）连续性</strong> 实现。也就是说，只有当 UI 元素的渲染顺序连续，且材质一样时，Unity 才能将它们合并成一个 DrawCall。</p>
<h3 id="❌-什么会打断顺序？比如："><a href="#❌-什么会打断顺序？比如：" class="headerlink" title="❌ 什么会打断顺序？比如："></a>❌ 什么会打断顺序？比如：</h3><ol>
<li>插入了一个使用不同材质的 UI 元素</li>
<li>插入了一个透明度不同或开启了特殊 shader 特效的 UI 元素</li>
<li>插入了一个被 <strong>强制改变 Sorting Order</strong>、<strong>Canvas 设置不同 Sorting Layer</strong> 的 UI 元素</li>
</ol>
<h3 id="🧱-举个例子说明："><a href="#🧱-举个例子说明：" class="headerlink" title="🧱 举个例子说明："></a>🧱 举个例子说明：</h3><p>你有这样一个结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Canvas</span><br><span class="line">├── Image_A（图集 UIAtlas_Common）</span><br><span class="line">├── 特效_B（独立材质）</span><br><span class="line">├── Image_C（图集 UIAtlas_Common）</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Image_A</code> 和 <code>Image_C</code> 可合批 ✅</li>
<li>但中间插了 <code>特效_B</code>（材质不同），<strong>会强制结束一次 DrawCall</strong>，然后重新开启下一次。</li>
</ul>
<p>所以实际上你会看到两个 UIAtlas_Common 的 DrawCall：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. DrawCall #1: Image_A</span><br><span class="line">2. DrawCall #2: 特效_B（不同材质）</span><br><span class="line">3. DrawCall #3: Image_C</span><br></pre></td></tr></table></figure>

<h3 id="🎯-原则："><a href="#🎯-原则：" class="headerlink" title="🎯 原则："></a>🎯 原则：</h3><blockquote>
<p>Unity 合批只能在<strong>相邻的、材质一致、ZOrder 不冲突的 UI 元素之间</strong>生效。</p>
</blockquote>
<ul>
<li>哪怕你用的是同一张图集，如果中间有排序变化（比如使用 Canvas override sorting、Sorting Layer、Z轴不同），也会断掉合批。</li>
</ul>
<hr>
<h2 id="✅-②-Packing-Tag-一致性对-Sprite-合批的影响（主要是老系统）"><a href="#✅-②-Packing-Tag-一致性对-Sprite-合批的影响（主要是老系统）" class="headerlink" title="✅ ② Packing Tag 一致性对 Sprite 合批的影响（主要是老系统）"></a>✅ ② Packing Tag 一致性对 Sprite 合批的影响（主要是老系统）</h2><h3 id="🔍-什么是-Packing-Tag？"><a href="#🔍-什么是-Packing-Tag？" class="headerlink" title="🔍 什么是 Packing Tag？"></a>🔍 什么是 Packing Tag？</h3><p>在老版本 Unity（&lt; 2019）使用的是 <strong>Legacy Sprite Packer</strong> 系统。这个系统会根据 Sprite 设置的 <strong>Packing Tag</strong> 把图打进图集。</p>
<h3 id="🧠-原理："><a href="#🧠-原理：" class="headerlink" title="🧠 原理："></a>🧠 原理：</h3><ul>
<li>所有设置了相同 Packing Tag 的 Sprite，会打进同一个图集，生成相同的材质引用。</li>
<li>不同 Packing Tag → 分到不同图集 → 不同材质 → 无法合批</li>
</ul>
<blockquote>
<p>哪怕你两个 Sprite 都放进图集中，但 Packing Tag 不一样，Unity 就会生成两张图 + 两个材质，就无法合批。</p>
</blockquote>
<hr>
<h3 id="✅-在-Unity-2019-新-Sprite-Atlas-中："><a href="#✅-在-Unity-2019-新-Sprite-Atlas-中：" class="headerlink" title="✅ 在 Unity 2019+ 新 Sprite Atlas 中："></a>✅ 在 Unity 2019+ 新 Sprite Atlas 中：</h3><p>Packing Tag 不再是必须项，但你仍然需要：</p>
<ul>
<li>确保 Sprite 被添加到 <strong>同一个 Sprite Atlas 资源</strong>中</li>
<li>Unity 会自动使用统一材质来合并渲染</li>
</ul>
<hr>
<h2 id="📌-快速验证方法"><a href="#📌-快速验证方法" class="headerlink" title="📌 快速验证方法"></a>📌 快速验证方法</h2><p>你可以在 Editor 中使用以下方式检测是否图集和材质统一：</p>
<ol>
<li><p><strong>Frame Debugger</strong>（窗口：Window &gt; Analysis &gt; Frame Debugger）</p>
<ul>
<li>Enable 后看 UI 的绘制调用</li>
<li>如果多个 UI 元素共用一个材质，合批成功；否则就会看到多次 DrawCall 分开渲染</li>
</ul>
</li>
<li><p><strong>Sprite 查看材质</strong></p>
<ul>
<li>选中一个 Sprite，点击 <strong>Inspector &gt; Debug 模式</strong></li>
<li>查看其 <code>Atlas Texture</code> 和 <code>Material</code> 是否相同</li>
</ul>
</li>
</ol>
<hr>
<h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h2><table>
<thead>
<tr>
<th>问题</th>
<th>原因</th>
<th>如何避免</th>
</tr>
</thead>
<tbody><tr>
<td>UI 渲染顺序打断合批</td>
<td>ZOrder 排序冲突或混入不同材质元素</td>
<td>保证 UI 层次清晰、材质连续、不混特效</td>
</tr>
<tr>
<td>Packing Tag 不一致</td>
<td>不同图集或材质会导致不能合并</td>
<td>使用统一图集或统一 Sprite Atlas</td>
</tr>
</tbody></table>
<h2 id="打断合批案例"><a href="#打断合批案例" class="headerlink" title="打断合批案例"></a>打断合批案例</h2><p>你这个结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Canvas</span><br><span class="line">├── Image_A   （图集 UIAtlas_Common）</span><br><span class="line">├── Image_A2  （图集 UIAtlas_Common）</span><br><span class="line">├── 特效_B     （独立材质，非图集）</span><br><span class="line">├── Image_C   （图集 UIAtlas_Common）</span><br><span class="line">├── Image_C2  （图集 UIAtlas_Common）</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="✅-Unity-实际渲染时会怎么做？"><a href="#✅-Unity-实际渲染时会怎么做？" class="headerlink" title="✅ Unity 实际渲染时会怎么做？"></a>✅ Unity 实际渲染时会怎么做？</h3><p>Unity 的 <strong>UGUI 合批（Batching）机制</strong> 在遇到材质变化时会<strong>强制结束当前批次，开始一个新 DrawCall</strong>。</p>
<h3 id="🎨-材质分析："><a href="#🎨-材质分析：" class="headerlink" title="🎨 材质分析："></a>🎨 材质分析：</h3><ul>
<li><code>Image_A</code>、<code>Image_A2</code>、<code>Image_C</code>、<code>Image_C2</code> 都属于 <strong>UIAtlas_Common</strong> 图集，共享 <strong>同一个材质</strong></li>
<li><code>特效_B</code> 使用 <strong>独立材质</strong>，比如带特效 shader 的 Particle 或非图集 Sprite</li>
</ul>
<hr>
<h2 id="📊-实际渲染批次和-DrawCall-结果如下："><a href="#📊-实际渲染批次和-DrawCall-结果如下：" class="headerlink" title="📊 实际渲染批次和 DrawCall 结果如下："></a>📊 实际渲染批次和 DrawCall 结果如下：</h2><table>
<thead>
<tr>
<th>顺序</th>
<th>内容</th>
<th>材质来源</th>
<th>是否合批</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Image_A + A2</td>
<td>UIAtlas_Common</td>
<td>✅ 合批，1个 DrawCall</td>
</tr>
<tr>
<td>2</td>
<td>特效_B</td>
<td>特效材质</td>
<td>❌ 新材质，1个 DrawCall</td>
</tr>
<tr>
<td>3</td>
<td>Image_C + C2</td>
<td>UIAtlas_Common</td>
<td>✅ 重新开始合批，1个 DrawCall</td>
</tr>
</tbody></table>
<h3 id="✅-结果总结："><a href="#✅-结果总结：" class="headerlink" title="✅ 结果总结："></a>✅ 结果总结：</h3><ul>
<li><p><strong>DrawCalls</strong>: <strong>3 个</strong></p>
<ul>
<li>DrawCall #1: Image_A, Image_A2（合批）</li>
<li>DrawCall #2: 特效_B（单独材质）</li>
<li>DrawCall #3: Image_C, Image_C2（重新开始合批）</li>
</ul>
</li>
<li><p><strong>Batches</strong>: 通常也是 <strong>3 个</strong>（如果你在 Profiler 中看 Batches 数和 DrawCall 数一样）</p>
</li>
</ul>
<hr>
<h2 id="🚨-为什么会重新开一个-DrawCall？"><a href="#🚨-为什么会重新开一个-DrawCall？" class="headerlink" title="🚨 为什么会重新开一个 DrawCall？"></a>🚨 为什么会重新开一个 DrawCall？</h2><ul>
<li>UGUI 渲染是按**层级顺序（Transform 顺序）**绘制的</li>
<li>如果中间某个对象使用了不同材质，Unity <strong>无法将两段相同材质之间的元素合批</strong></li>
<li>所以 Image_A 和 Image_C 即使同图集，也 <strong>无法合批</strong></li>
</ul>
<hr>
<h2 id="✅-优化建议（减少-DrawCall-到-2-个甚至-1-个）"><a href="#✅-优化建议（减少-DrawCall-到-2-个甚至-1-个）" class="headerlink" title="✅ 优化建议（减少 DrawCall 到 2 个甚至 1 个）"></a>✅ 优化建议（减少 DrawCall 到 2 个甚至 1 个）</h2><h3 id="方法一：将特效-B-分离出当前-Canvas"><a href="#方法一：将特效-B-分离出当前-Canvas" class="headerlink" title="方法一：将特效_B 分离出当前 Canvas"></a>方法一：将特效_B 分离出当前 Canvas</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Canvas_StaticUI（图集 UI）</span><br><span class="line">├── Image_A</span><br><span class="line">├── Image_A2</span><br><span class="line">├── Image_C</span><br><span class="line">├── Image_C2</span><br><span class="line"></span><br><span class="line">Canvas_FX（独立材质，SortingOrder &gt; StaticUI）</span><br><span class="line">└── 特效_B</span><br></pre></td></tr></table></figure>

<ul>
<li>特效独立 Canvas，不再打断合批</li>
<li>UIAtlas_Common 全部可一次合批 ✅</li>
</ul>
<p>➡️ <strong>DrawCall 减为 2 个（图集 + 特效）</strong></p>
<hr>
<h3 id="方法二：如果特效只是一个闪光贴图，没有动态变化，尝试用图集内贴图代替"><a href="#方法二：如果特效只是一个闪光贴图，没有动态变化，尝试用图集内贴图代替" class="headerlink" title="方法二：如果特效只是一个闪光贴图，没有动态变化，尝试用图集内贴图代替"></a>方法二：如果特效只是一个闪光贴图，没有动态变化，尝试用图集内贴图代替</h3><ul>
<li>把特效贴图也加入到 UIAtlas_Common 图集</li>
<li>改用普通 <code>Image</code> 展示</li>
</ul>
<p>➡️ 所有 5 个都共用图集，<strong>DrawCall 降为 1</strong></p>
<hr>
<h2 id="✅-验证方法"><a href="#✅-验证方法" class="headerlink" title="✅ 验证方法"></a>✅ 验证方法</h2><p>使用 <strong>Frame Debugger</strong>：</p>
<blockquote>
<p><code>Window &gt; Analysis &gt; Frame Debugger &gt; Enable</code></p>
</blockquote>
<ol>
<li>选择 UI 相关 DrawCall，查看是否使用了同一个材质（图集）</li>
<li>如果看到“结束一个批次，开启新材质绘制”，说明被打断</li>
<li>查看断点是否就是你插入的 <code>特效_B</code></li>
</ol>
<hr>
<h2 id="🧠-总结"><a href="#🧠-总结" class="headerlink" title="🧠 总结"></a>🧠 总结</h2><table>
<thead>
<tr>
<th>项目</th>
<th>数值</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>DrawCall</td>
<td>3</td>
<td>特效材质打断合批</td>
</tr>
<tr>
<td>合批数</td>
<td>3</td>
<td>UIAtlas_Common 分两段合批，中间被打断</td>
</tr>
</tbody></table>
<p><strong>优化方式</strong>：将 <code>特效_B</code> 拆分 Canvas 或使用图集贴图代替特效材质，即可合批成功。</p>
<p>如果你希望我帮你写一个自动检测 UI 中打断合批的节点脚本，也可以告诉我。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity 环境安装</title>
    <url>/2025/01/14/Unity%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="unity-模块添加"><a href="#unity-模块添加" class="headerlink" title="unity 模块添加"></a>unity 模块添加</h1><p><a href="https://discussions.unity.com/t/unable-to-add-modules-to-installation-in-unity-hub-3-7-0/935934/12">官方解释</a></p>
<p>这段官方解释详细说明了为什么 <strong>“Add Modules”</strong> 按钮可能缺失以及如何通过手动方式修复。以下是总结和关键要点：</p>
<hr>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a><strong>问题原因</strong></h2><ul>
<li><strong>Unity Hub</strong> 使用 <code>modules.json</code> 文件来记录某个 Unity 编辑器版本的模块安装状态。</li>
<li>如果该文件缺失或未正确生成，Unity Hub 就无法知道有哪些模块已安装，也无法显示 <strong>“Add Modules”</strong> 按钮。</li>
<li>如果编辑器是通过非 Unity Hub 安装的（例如手动下载解压安装），默认没有 <code>modules.json</code> 文件，Unity Hub 将无法管理该版本的模块。所以我们安装unity时hub上可能没有列出我们需要的版本，但是我们可以去官网找到对应的版本链接至UnityHub 这样就相当于使用UnityHub下载，支持模块管理。</li>
</ul>
<hr>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><p>如果你的 Unity 安装缺失 <strong>“Add Modules”</strong> 按钮，可以尝试以下步骤修复：</p>
<h3 id="方法一：手动下载模块"><a href="#方法一：手动下载模块" class="headerlink" title="方法一：手动下载模块"></a>方法一：手动下载模块</h3><ol>
<li>选版本 <a href="https://unity.com/releases/editor/archive">archive</a></li>
<li><a href="https://unity.com/releases/editor/whats-new/2022.3.20#installers">releases</a>，找到组件对应组件模块，如下：</li>
</ol>
<p>   Component installers -&gt;</p>
<p>   Windows :</p>
<ul>
<li>Android Build Support</li>
<li>iOS Build Support</li>
<li>tvOS Build Support</li>
<li>Linux Build Support (IL2CPP)</li>
<li>Linux Build Support (Mono)</li>
<li>Linux Dedicated Server Build Support</li>
<li>Mac Build Support (Mono)</li>
<li>Mac Dedicated Server Build Support</li>
<li>Universal Windows Platform Build Support</li>
<li>WebGL Build Support</li>
<li>Windows Build Support (IL2CPP)</li>
<li>Windows Dedicated Server Build Support</li>
<li>Documentation</li>
</ul>
<h3 id="方法二：创建modules-json"><a href="#方法二：创建modules-json" class="headerlink" title="方法二：创建modules.json"></a>方法二：创建modules.json</h3><h4 id="1-检查-Unity-安装路径"><a href="#1-检查-Unity-安装路径" class="headerlink" title="1. 检查 Unity 安装路径"></a><strong>1. 检查 Unity 安装路径</strong></h4><ul>
<li>打开 Unity Hub 的 <strong>Installs</strong> 页。</li>
<li>点击 Unity 版本右侧的 <strong>齿轮图标</strong>，选择 <strong>“Show in Explorer”</strong> 或 <strong>“Show in Finder”</strong>。</li>
<li>在打开的文件夹中，确认是否存在 <code>modules.json</code> 文件。</li>
</ul>
<h4 id="2-手动创建-modules-json-文件"><a href="#2-手动创建-modules-json-文件" class="headerlink" title="2. 手动创建 modules.json 文件"></a><strong>2. 手动创建 <code>modules.json</code> 文件</strong></h4><p>如果文件缺失，可以手动创建：</p>
<ol>
<li><p>在 Unity 安装目录下新建一个文件，命名为 <code>modules.json</code>。</p>
<ul>
<li>注意文件扩展名必须为 <code>.json</code>。</li>
<li>确保在操作系统中未隐藏扩展名（防止被误命名为 <code>modules.json.txt</code>）。</li>
</ul>
</li>
<li><p>打开文件并添加以下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></li>
<li><p>保存并关闭文件。</p>
</li>
</ol>
<h4 id="3-重启-Unity-Hub"><a href="#3-重启-Unity-Hub" class="headerlink" title="3. 重启 Unity Hub"></a><strong>3. 重启 Unity Hub</strong></h4><ul>
<li>完全退出 Unity Hub，确保它不在系统托盘运行。</li>
<li>重新打开 Unity Hub，检查 <strong>“Add Modules”</strong> 按钮是否出现。</li>
</ul>
<hr>
<h3 id="重要注意事项"><a href="#重要注意事项" class="headerlink" title="重要注意事项"></a><strong>重要注意事项</strong></h3><ol>
<li><p><strong>风险提示</strong>：</p>
<ul>
<li>如果 <code>modules.json</code> 文件信息不正确，可能会导致 Unity Hub 无法正确管理模块安装&#x2F;卸载。</li>
<li>如果问题发生，可以删除 <code>modules.json</code> 文件并重试。</li>
</ul>
</li>
<li><p><strong>推荐使用 Unity Hub 安装编辑器</strong>：</p>
<ul>
<li>Unity Hub 安装会自动生成 <code>modules.json</code>，并确保模块的正确状态。</li>
</ul>
</li>
<li><p><strong>归档下载的版本建议单独管理</strong>：</p>
<ul>
<li>如果从 <a href="https://unity.com/releases/editor/archive">Unity 归档</a>下载的版本，最好直接使用 Unity Hub 安装或按照官方文档的安装步骤手动管理模块。</li>
</ul>
</li>
</ol>
<h3 id="方法三：卸载，使用Unityhub重新安装-【推荐】"><a href="#方法三：卸载，使用Unityhub重新安装-【推荐】" class="headerlink" title="方法三：卸载，使用Unityhub重新安装 【推荐】"></a>方法三：卸载，使用Unityhub重新安装 【推荐】</h3><p><strong>强调：</strong></p>
<ol>
<li>不要使用中国版团结引擎，版本带c的就是</li>
<li>不要单独下载unity editor 安装器，使用UnityHub下载</li>
</ol>
<h2 id="Visual-Studio-的安装"><a href="#Visual-Studio-的安装" class="headerlink" title="Visual Studio 的安装"></a>Visual Studio 的安装</h2><p>在 Unity 开发中，Visual Studio 的安装需要包含以下关键组件，以确保支持 Unity 的所有功能，包括 C# 脚本开发、IL2CPP 构建、调试和测试。</p>
<hr>
<h2 id="推荐的安装步骤"><a href="#推荐的安装步骤" class="headerlink" title="推荐的安装步骤"></a><strong>推荐的安装步骤</strong></h2><ol>
<li>打开 <strong>Visual Studio Installer</strong>。</li>
<li>选择要安装或修改的 Visual Studio 版本（例如 Visual Studio 2022）。</li>
<li>点击 <strong>修改</strong>。</li>
<li>在 <strong>工作负载</strong> 和 <strong>单个组件</strong> 中勾选以下内容。</li>
</ol>
<hr>
<h2 id="必须安装的组件"><a href="#必须安装的组件" class="headerlink" title="必须安装的组件"></a><strong>必须安装的组件</strong></h2><h3 id="工作负载"><a href="#工作负载" class="headerlink" title="工作负载"></a><strong>工作负载</strong></h3><p>以下工作负载是 Unity 开发的基本需求：</p>
<ol>
<li><p><strong>Game development with Unity</strong>（使用 Unity 进行游戏开发）：</p>
<ul>
<li>Unity 的官方推荐工作负载。</li>
<li>包含 Unity 相关工具、调试器、测试工具和集成插件。</li>
</ul>
</li>
<li><p><strong>.NET desktop development</strong>（.NET 桌面开发）：</p>
<ul>
<li>提供必要的 .NET 和 C# 工具。</li>
</ul>
</li>
<li><p>**Desktop development with C++**（C++ 桌面开发）：</p>
<ul>
<li><strong>IL2CPP 构建</strong>所需，用于将 Unity 项目转换为本地 C++ 代码并编译。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="单个组件"><a href="#单个组件" class="headerlink" title="单个组件"></a><strong>单个组件</strong></h3><p>在顶部切换到 <strong>单个组件</strong>，选择以下组件：</p>
<h4 id="C-和-NET"><a href="#C-和-NET" class="headerlink" title="C# 和 .NET"></a><strong>C# 和 .NET</strong></h4><ol>
<li><strong>.NET Framework 4.8 SDK</strong></li>
<li><strong>.NET Framework 4.8 Targeting Pack</strong></li>
<li><strong>NuGet Package Manager</strong></li>
</ol>
<h4 id="C-工具链"><a href="#C-工具链" class="headerlink" title="C++ 工具链"></a><strong>C++ 工具链</strong></h4><ol>
<li><strong>MSVC v143 - VS 2022 C++ x64&#x2F;x86 build tools</strong></li>
<li><strong>Windows 10 SDK（10.x.x.x）</strong> 或更新版本：<ul>
<li>这是 IL2CPP 必需的工具链之一。</li>
</ul>
</li>
<li><strong>C++ CMake tools for Windows</strong></li>
<li><strong>C++&#x2F;CLI support</strong>（可选，针对 .NET 与 C++ 交互的情况）。</li>
</ol>
<h4 id="Unity-工具"><a href="#Unity-工具" class="headerlink" title="Unity 工具"></a><strong>Unity 工具</strong></h4><ol>
<li><strong>Unity Hub</strong>（可选，如果未安装）。</li>
<li><strong>Visual Studio Tools for Unity</strong>：<ul>
<li>提供 Unity 与 Visual Studio 的集成，包括代码提示、调试和错误报告。</li>
</ul>
</li>
</ol>
<h4 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a><strong>调试工具</strong></h4><ol>
<li><strong>JavaScript diagnostics</strong>（用于调试 WebGL 项目）。</li>
<li><strong>Graphics debugger and GPU profiler</strong>（可选，用于调试渲染问题）。</li>
</ol>
<hr>
<h3 id="其他推荐组件"><a href="#其他推荐组件" class="headerlink" title="其他推荐组件"></a><strong>其他推荐组件</strong></h3><ol>
<li><strong>Azure DevOps</strong>（可选，用于版本控制）。</li>
<li><strong>MSBuild</strong>（项目构建工具）。</li>
<li><strong>Live Share</strong>（用于多人协作开发）。</li>
<li><strong>Performance profiler</strong>（可选，性能分析工具）。</li>
</ol>
<hr>
<h2 id="检查-Unity-项目所需的额外内容"><a href="#检查-Unity-项目所需的额外内容" class="headerlink" title="检查 Unity 项目所需的额外内容"></a><strong>检查 Unity 项目所需的额外内容</strong></h2><p>如果你的 Unity 项目需要构建到特定平台，请安装相关的 SDK 和工具：</p>
<ul>
<li><strong>Android</strong>：需要安装 Android SDK 和 NDK，建议通过 Unity Hub 设置。</li>
<li><strong>iOS</strong>：需要 macOS 和 Xcode。</li>
<li><strong>WebGL</strong>：安装 Node.js 和 JavaScript 工具（Visual Studio 会自动提供支持）。</li>
<li><strong>Windows</strong>：确保安装了 <strong>Windows 10 SDK</strong> 和 <strong>C++ 工具链</strong>。</li>
</ul>
<hr>
<p>完成上述设置后，Visual Studio 应能够完整支持 Unity 的开发需求。如果遇到具体问题或提示缺少某个组件，可以根据报错信息查漏补缺，或随时向我提问！</p>
]]></content>
  </entry>
  <entry>
    <title>Unity Jobs System</title>
    <url>/2025/01/10/Unity-Jobs-System/</url>
    <content><![CDATA[<h1 id="Unity-Jobs"><a href="#Unity-Jobs" class="headerlink" title="Unity Jobs"></a>Unity Jobs</h1><p>Unity <strong>Jobs System</strong> 是 Unity 提供的一种高效并行计算框架，用来帮助开发者更好地利用多核 CPU 的计算能力，提高性能。它是 Unity <strong>Data-Oriented Technology Stack (DOTS)</strong> 的核心组件之一，与 <strong>Burst Compiler</strong> 和 <strong>Entity Component System (ECS)</strong> 密切相关。</p>
<hr>
<h3 id="Unity-Jobs-的功能与用途"><a href="#Unity-Jobs-的功能与用途" class="headerlink" title="Unity Jobs 的功能与用途"></a><strong>Unity Jobs 的功能与用途</strong></h3><ol>
<li><p><strong>并行任务处理</strong></p>
<ul>
<li>Unity Jobs 允许你将复杂的计算任务拆分成多个小任务，并分配到多个 CPU 核心上同时运行。</li>
<li>例如，可以用 Jobs System 处理路径寻路、物理模拟、动画运算、大规模 AI 行为、粒子系统等需要高计算量的任务。</li>
</ul>
</li>
<li><p><strong>线程安全</strong></p>
<ul>
<li>Unity Jobs 通过自动管理线程池，避免了开发者手动创建和管理线程带来的复杂性和错误风险。</li>
<li>提供数据访问的约束机制（如 <code>NativeArray</code>），避免多线程访问冲突。</li>
</ul>
</li>
<li><p><strong>性能优化</strong></p>
<ul>
<li>Unity Jobs 和 <strong>Burst Compiler</strong> 配合，能大幅优化计算性能。Burst Compiler 会将 Jobs 转换为高效的原生代码，充分利用 CPU 的 SIMD 指令集。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Unity-Jobs-的核心概念"><a href="#Unity-Jobs-的核心概念" class="headerlink" title="Unity Jobs 的核心概念"></a><strong>Unity Jobs 的核心概念</strong></h3><ol>
<li><p><strong>Job</strong></p>
<ul>
<li>Job 是一个独立的计算任务，通常是一个实现了 <code>IJob</code> 或 <code>IJobParallelFor</code> 接口的结构体。</li>
<li>示例：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyJob : IJob &#123;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numbers.Length; i++) &#123;</span><br><span class="line">            numbers[i] *= <span class="number">2</span>; <span class="comment">// 每个数字乘以2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Job Scheduling</strong></p>
<ul>
<li>使用 <code>JobHandle</code> 调度 Jobs 时，Unity 会将其放入内部的工作队列，分配到可用线程中。</li>
<li>示例：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">MyJob job = <span class="keyword">new</span> MyJob &#123;</span><br><span class="line">    numbers = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">int</span>&gt;(<span class="number">10</span>, Allocator.TempJob)</span><br><span class="line">&#125;;</span><br><span class="line">JobHandle handle = job.Schedule();</span><br><span class="line">handle.Complete();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Native Containers</strong></p>
<ul>
<li>Unity 提供了一些高性能的线程安全数据结构，如 <code>NativeArray</code>、<code>NativeList</code>、<code>NativeHashMap</code>，用于在 Jobs 中传递数据。</li>
<li>它们的设计能有效防止数据竞争，并支持并行访问。</li>
</ul>
</li>
<li><p><strong>Parallel Jobs</strong></p>
<ul>
<li>使用 <code>IJobParallelFor</code> 接口，可以将任务分解为多个并行执行的子任务。</li>
<li>示例：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyParallelJob : IJobParallelFor &#123;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span> &#123;</span><br><span class="line">        numbers[index] *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Burst Compiler</strong></p>
<ul>
<li>Burst 是 Unity Jobs 的性能加速器，通过将代码编译为高度优化的原生代码，显著提升执行效率。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Unity-Jobs-的优点"><a href="#Unity-Jobs-的优点" class="headerlink" title="Unity Jobs 的优点"></a><strong>Unity Jobs 的优点</strong></h3><ol>
<li><strong>自动线程管理</strong><ul>
<li>不需要开发者手动创建线程或管理线程池，减少开发工作量和线程同步问题。</li>
</ul>
</li>
<li><strong>优化 CPU 利用率</strong><ul>
<li>能够充分利用现代多核处理器的性能，特别适合计算密集型任务。</li>
</ul>
</li>
<li><strong>安全性</strong><ul>
<li>通过 <code>NativeArray</code> 和 Job 调度机制，保证多线程操作的安全性。</li>
</ul>
</li>
<li><strong>性能提升</strong><ul>
<li>和 Burst Compiler 配合，能极大提升运行时性能。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Unity-Jobs-的典型应用场景"><a href="#Unity-Jobs-的典型应用场景" class="headerlink" title="Unity Jobs 的典型应用场景"></a><strong>Unity Jobs 的典型应用场景</strong></h3><ol>
<li><strong>路径寻路</strong><ul>
<li>通过并行化 A* 算法或其他寻路算法处理大规模的寻路请求。</li>
</ul>
</li>
<li><strong>AI 行为</strong><ul>
<li>对大规模 AI 单元的行为进行计算和决策。</li>
</ul>
</li>
<li><strong>物理模拟</strong><ul>
<li>处理粒子系统、布料模拟、刚体碰撞等复杂物理运算。</li>
</ul>
</li>
<li><strong>动画计算</strong><ul>
<li>并行计算动画骨骼的变换、插值等数据。</li>
</ul>
</li>
<li><strong>数据处理</strong><ul>
<li>处理大规模数据的排序、过滤、转换等操作。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="需要注意的限制"><a href="#需要注意的限制" class="headerlink" title="需要注意的限制"></a><strong>需要注意的限制</strong></h3><ol>
<li><strong>学习曲线</strong><ul>
<li>Jobs System 的使用需要了解多线程编程的基本概念，以及 Unity 提供的 <code>NativeArray</code> 等工具。</li>
</ul>
</li>
<li><strong>只适用于计算任务</strong><ul>
<li>Jobs System 不直接用于渲染、UI 操作等与主线程相关的任务。</li>
</ul>
</li>
<li><strong>调试困难</strong><ul>
<li>多线程编程的调试相对复杂，尤其是数据竞争和死锁问题。</li>
</ul>
</li>
<li><strong>不支持所有类型</strong><ul>
<li>Jobs 不能直接操作引用类型（如类），只能使用值类型（如结构体）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Unity-Jobs-和其他技术的关系"><a href="#Unity-Jobs-和其他技术的关系" class="headerlink" title="Unity Jobs 和其他技术的关系"></a><strong>Unity Jobs 和其他技术的关系</strong></h3><ol>
<li><strong>与 ECS 的关系</strong><ul>
<li>ECS 是基于数据导向设计的架构，Jobs 是 ECS 的核心计算工具，用于加速 Entity 数据的处理。</li>
</ul>
</li>
<li><strong>与 Burst Compiler 的关系</strong><ul>
<li>Burst Compiler 是 Jobs 性能优化的关键，能将 Jobs 转化为极其高效的机器代码。</li>
</ul>
</li>
<li><strong>与传统多线程的区别</strong><ul>
<li>Jobs 是 Unity 提供的高层次封装，开发者无需直接管理线程，降低了使用多线程的复杂性。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Unity Jobs System 是一个高效的并行计算框架，专注于提高 CPU 密集型任务的执行效率。通过将任务拆分为多个 Job 并分配到多个核心上运行，开发者可以充分利用现代多核 CPU 的性能，显著提升游戏运行效率，同时保持线程安全性和开发简洁性。</p>
<h1 id="Unity-Jobs-System-的几种典型应用场景案例"><a href="#Unity-Jobs-System-的几种典型应用场景案例" class="headerlink" title="Unity Jobs System 的几种典型应用场景案例"></a>Unity Jobs System 的几种典型应用场景案例</h1><p>以下是 Unity Jobs System 的几种典型应用场景，并结合案例代码说明其使用方法。</p>
<hr>
<h3 id="1-路径寻路"><a href="#1-路径寻路" class="headerlink" title="1. 路径寻路"></a>1. <strong>路径寻路</strong></h3><p><strong>场景描述：</strong><br>假设你有大量的 NPC 单位需要同时寻路。如果直接用单线程处理，会因寻路算法的高计算复杂度导致帧率下降。</p>
<p><strong>实现思路：</strong><br>使用 Jobs 将寻路任务分配给多个线程并行处理。</p>
<p><strong>案例代码：</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Collections;</span><br><span class="line"><span class="keyword">using</span> Unity.Jobs;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> PathfindingJob : IJobParallelFor</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> NativeArray&lt;Vector2&gt; startPositions;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> NativeArray&lt;Vector2&gt; targetPositions;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="built_in">float</span>&gt; pathCosts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector2 start = startPositions[index];</span><br><span class="line">        Vector2 target = targetPositions[index];</span><br><span class="line">        pathCosts[index] = Vector2.Distance(start, target); <span class="comment">// 简化的路径代价计算</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PathfindingExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> npcCount = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        NativeArray&lt;Vector2&gt; startPositions = <span class="keyword">new</span> NativeArray&lt;Vector2&gt;(npcCount, Allocator.TempJob);</span><br><span class="line">        NativeArray&lt;Vector2&gt; targetPositions = <span class="keyword">new</span> NativeArray&lt;Vector2&gt;(npcCount, Allocator.TempJob);</span><br><span class="line">        NativeArray&lt;<span class="built_in">float</span>&gt; pathCosts = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">float</span>&gt;(npcCount, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; npcCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            startPositions[i] = Random.insideUnitCircle * <span class="number">10</span>;</span><br><span class="line">            targetPositions[i] = Random.insideUnitCircle * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PathfindingJob job = <span class="keyword">new</span> PathfindingJob</span><br><span class="line">        &#123;</span><br><span class="line">            startPositions = startPositions,</span><br><span class="line">            targetPositions = targetPositions,</span><br><span class="line">            pathCosts = pathCosts</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        JobHandle handle = job.Schedule(npcCount, <span class="number">64</span>);</span><br><span class="line">        handle.Complete();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;NPC <span class="subst">&#123;i&#125;</span> Path Cost: <span class="subst">&#123;pathCosts[i]&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        startPositions.Dispose();</span><br><span class="line">        targetPositions.Dispose();</span><br><span class="line">        pathCosts.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果：</strong><br>通过并行计算，路径代价的计算分布到多个线程，显著减少计算时间。</p>
<hr>
<h3 id="2-AI-行为"><a href="#2-AI-行为" class="headerlink" title="2. AI 行为"></a>2. <strong>AI 行为</strong></h3><p><strong>场景描述：</strong><br>多个 AI 单位需要根据状态和周围环境进行决策，比如寻找最近的敌人。</p>
<p><strong>实现思路：</strong><br>用 Jobs 并行处理每个 AI 的决策。</p>
<p><strong>案例代码：</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AIBehaviorJob : IJobParallelFor</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> NativeArray&lt;Vector3&gt; aiPositions;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> NativeArray&lt;Vector3&gt; enemyPositions;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; closestEnemyIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 aiPosition = aiPositions[index];</span><br><span class="line">        <span class="built_in">float</span> minDistance = <span class="built_in">float</span>.MaxValue;</span><br><span class="line">        <span class="built_in">int</span> nearestEnemy = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; enemyPositions.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">float</span> distance = Vector3.Distance(aiPosition, enemyPositions[i]);</span><br><span class="line">            <span class="keyword">if</span> (distance &lt; minDistance)</span><br><span class="line">            &#123;</span><br><span class="line">                minDistance = distance;</span><br><span class="line">                nearestEnemy = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        closestEnemyIndex[index] = nearestEnemy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AIExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> aiCount = <span class="number">500</span>;</span><br><span class="line">        <span class="built_in">int</span> enemyCount = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        NativeArray&lt;Vector3&gt; aiPositions = <span class="keyword">new</span> NativeArray&lt;Vector3&gt;(aiCount, Allocator.TempJob);</span><br><span class="line">        NativeArray&lt;Vector3&gt; enemyPositions = <span class="keyword">new</span> NativeArray&lt;Vector3&gt;(enemyCount, Allocator.TempJob);</span><br><span class="line">        NativeArray&lt;<span class="built_in">int</span>&gt; closestEnemyIndex = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">int</span>&gt;(aiCount, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; aiCount; i++) aiPositions[i] = Random.insideUnitSphere * <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; enemyCount; i++) enemyPositions[i] = Random.insideUnitSphere * <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        AIBehaviorJob job = <span class="keyword">new</span> AIBehaviorJob</span><br><span class="line">        &#123;</span><br><span class="line">            aiPositions = aiPositions,</span><br><span class="line">            enemyPositions = enemyPositions,</span><br><span class="line">            closestEnemyIndex = closestEnemyIndex</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        JobHandle handle = job.Schedule(aiCount, <span class="number">64</span>);</span><br><span class="line">        handle.Complete();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;AI <span class="subst">&#123;i&#125;</span> Closest Enemy Index: <span class="subst">&#123;closestEnemyIndex[i]&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        aiPositions.Dispose();</span><br><span class="line">        enemyPositions.Dispose();</span><br><span class="line">        closestEnemyIndex.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果：</strong><br>每个 AI 并行计算最近敌人，计算效率显著提升。</p>
<hr>
<h3 id="3-物理模拟"><a href="#3-物理模拟" class="headerlink" title="3. 物理模拟"></a>3. <strong>物理模拟</strong></h3><p><strong>场景描述：</strong><br>大量粒子需要模拟，比如碰撞、加速或力场作用。</p>
<p><strong>实现思路：</strong><br>将每个粒子的物理计算用 Job 并行处理。</p>
<p><strong>案例代码：</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> ParticleSimulationJob : IJobParallelFor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;Vector3&gt; positions;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;Vector3&gt; velocities;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> <span class="built_in">float</span> deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 velocity = velocities[index];</span><br><span class="line">        positions[index] += velocity * deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ParticleExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> particleCount = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">        NativeArray&lt;Vector3&gt; positions = <span class="keyword">new</span> NativeArray&lt;Vector3&gt;(particleCount, Allocator.TempJob);</span><br><span class="line">        NativeArray&lt;Vector3&gt; velocities = <span class="keyword">new</span> NativeArray&lt;Vector3&gt;(particleCount, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化粒子数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; particleCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            positions[i] = Random.insideUnitSphere * <span class="number">10</span>;</span><br><span class="line">            velocities[i] = Random.insideUnitSphere * <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ParticleSimulationJob job = <span class="keyword">new</span> ParticleSimulationJob</span><br><span class="line">        &#123;</span><br><span class="line">            positions = positions,</span><br><span class="line">            velocities = velocities,</span><br><span class="line">            deltaTime = Time.deltaTime</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        JobHandle handle = job.Schedule(particleCount, <span class="number">64</span>);</span><br><span class="line">        handle.Complete();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出部分结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;Particle <span class="subst">&#123;i&#125;</span> Position: <span class="subst">&#123;positions[i]&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        positions.Dispose();</span><br><span class="line">        velocities.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果：</strong><br>所有粒子的运动更新同时完成，适合模拟大量粒子的物理效果。</p>
<hr>
<h3 id="4-数据处理"><a href="#4-数据处理" class="headerlink" title="4. 数据处理"></a>4. <strong>数据处理</strong></h3><p><strong>场景描述：</strong><br>对大量数据进行批量处理，比如排序或筛选。</p>
<p><strong>实现思路：</strong><br>使用 Jobs 加速数据的转换、筛选或操作。</p>
<p><strong>案例代码：</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> DataProcessingJob : IJobParallelFor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; inputData;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; outputData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        outputData[index] = inputData[index] * inputData[index]; <span class="comment">// 简单平方运算</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DataProcessingExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> dataSize = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        NativeArray&lt;<span class="built_in">int</span>&gt; inputData = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">int</span>&gt;(dataSize, Allocator.TempJob);</span><br><span class="line">        NativeArray&lt;<span class="built_in">int</span>&gt; outputData = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">int</span>&gt;(dataSize, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; dataSize; i++) inputData[i] = i;</span><br><span class="line"></span><br><span class="line">        DataProcessingJob job = <span class="keyword">new</span> DataProcessingJob</span><br><span class="line">        &#123;</span><br><span class="line">            inputData = inputData,</span><br><span class="line">            outputData = outputData</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        JobHandle handle = job.Schedule(dataSize, <span class="number">64</span>);</span><br><span class="line">        handle.Complete();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;Input: <span class="subst">&#123;inputData[i]&#125;</span>, Output: <span class="subst">&#123;outputData[i]&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inputData.Dispose();</span><br><span class="line">        outputData.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果：</strong><br>批量数据的处理速度大幅提升。</p>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过 Unity Jobs System，可以轻松实现大量计算任务的并行化，从而显著优化性能。上述场景只是冰山一角，你可以根据项目需求灵活运用 Jobs 系统提升游戏的执行效率。</p>
<h1 id="Execute-方法"><a href="#Execute-方法" class="headerlink" title="Execute 方法"></a>Execute 方法</h1><p>在 Unity 的 <strong>Jobs System</strong> 中，<code>Execute</code> 方法是实现 <code>IJob</code> 或 <code>IJobParallelFor</code> 等接口时必须定义的核心方法。它是 Job 的<strong>入口函数</strong>，负责定义并执行每个任务的具体逻辑。</p>
<hr>
<h3 id="1-Execute-的作用"><a href="#1-Execute-的作用" class="headerlink" title="1. Execute 的作用"></a><strong>1. <code>Execute</code> 的作用</strong></h3><ul>
<li><code>IJob</code>: 当你实现一个普通的 Job（非并行），<code>Execute</code> 会被调用一次，用来执行你的任务逻辑。</li>
<li><code>IJobParallelFor</code>: 当你实现并行 Job 时，<code>Execute</code> 方法会被多次调用，每次处理任务队列中的一个分块或一个索引。</li>
</ul>
<hr>
<h3 id="2-Execute-的签名"><a href="#2-Execute-的签名" class="headerlink" title="2. Execute 的签名"></a><strong>2. <code>Execute</code> 的签名</strong></h3><ul>
<li><p>对于 <code>IJob</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>没有参数，因为它处理的是一个整体任务。</li>
</ul>
</li>
<li><p>对于 <code>IJobParallelFor</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>接受一个 <code>index</code> 参数，表示当前任务的索引。</li>
<li>通常用于访问数组、列表等数据结构的特定元素。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-Execute-的运行机制"><a href="#3-Execute-的运行机制" class="headerlink" title="3. Execute 的运行机制"></a><strong>3. <code>Execute</code> 的运行机制</strong></h3><p>当 Job 被调度时，Unity 的 Job System 会自动调用 <code>Execute</code> 方法，并在适当的时候将任务分发到多个线程中。对于并行 Job，<code>index</code> 参数帮助确定每次调用时应该处理的数据块。</p>
<hr>
<h3 id="4-详细案例"><a href="#4-详细案例" class="headerlink" title="4. 详细案例"></a><strong>4. 详细案例</strong></h3><h4 id="单任务的-IJob"><a href="#单任务的-IJob" class="headerlink" title="单任务的 IJob"></a>单任务的 <code>IJob</code></h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Jobs;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> SimpleJob : IJob</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Hello from SimpleJob!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JobExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SimpleJob job = <span class="keyword">new</span> SimpleJob();</span><br><span class="line">        JobHandle handle = job.Schedule();</span><br><span class="line">        handle.Complete(); <span class="comment">// 等待任务完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello from SimpleJob!</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="并行任务的-IJobParallelFor"><a href="#并行任务的-IJobParallelFor" class="headerlink" title="并行任务的 IJobParallelFor"></a>并行任务的 <code>IJobParallelFor</code></h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Jobs;</span><br><span class="line"><span class="keyword">using</span> Unity.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> ParallelJob : IJobParallelFor</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; inputData;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; resultData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算平方</span></span><br><span class="line">        resultData[index] = inputData[index] * inputData[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ParallelJobExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> size = <span class="number">10</span>;</span><br><span class="line">        NativeArray&lt;<span class="built_in">int</span>&gt; inputData = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">int</span>&gt;(size, Allocator.TempJob);</span><br><span class="line">        NativeArray&lt;<span class="built_in">int</span>&gt; resultData = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">int</span>&gt;(size, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            inputData[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ParallelJob job = <span class="keyword">new</span> ParallelJob</span><br><span class="line">        &#123;</span><br><span class="line">            inputData = inputData,</span><br><span class="line">            resultData = resultData</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        JobHandle handle = job.Schedule(size, <span class="number">2</span>); <span class="comment">// 调度任务，批处理大小为2</span></span><br><span class="line">        handle.Complete(); <span class="comment">// 等待任务完成</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;Index <span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;resultData[i]&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inputData.Dispose();</span><br><span class="line">        resultData.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Index 0: 0</span><br><span class="line">Index 1: 1</span><br><span class="line">Index 2: 4</span><br><span class="line">Index 3: 9</span><br><span class="line">Index 4: 16</span><br><span class="line">Index 5: 25</span><br><span class="line">Index 6: 36</span><br><span class="line">Index 7: 49</span><br><span class="line">Index 8: 64</span><br><span class="line">Index 9: 81</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-调度和并行化的核心"><a href="#5-调度和并行化的核心" class="headerlink" title="5. 调度和并行化的核心"></a><strong>5. 调度和并行化的核心</strong></h3><ul>
<li>Unity Job System 根据你提供的数据规模和分块大小（chunk size）自动管理对 <code>Execute</code> 的调用。</li>
<li><strong>调度参数</strong>：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">JobHandle <span class="title">Schedule</span>(<span class="params"><span class="built_in">int</span> arrayLength, <span class="built_in">int</span> batchSize</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>arrayLength</code>：任务总数（通常与数组长度相同）。</li>
<li><code>batchSize</code>：每次分配给一个线程处理的任务数量。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h3><ul>
<li><code>Execute</code> 是 Job 的核心执行逻辑，由 Unity 的 Job System 在适当的线程中调用。</li>
<li><code>IJob</code> 的 <code>Execute</code> 没有参数，用于处理整体任务。</li>
<li><code>IJobParallelFor</code> 的 <code>Execute</code> 接受一个 <code>index</code> 参数，用于处理特定的数据块或索引。</li>
<li>使用 Jobs System 时，<code>Execute</code> 是定义任务行为的关键入口点。</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity UWA &amp; UWP</title>
    <url>/2025/01/15/Unity-UWA-UWP/</url>
    <content><![CDATA[<p><strong>UWA</strong>（Universal Windows App）和 <strong>UWP</strong>（Universal Windows Platform）之间有密切的关系，但两者不是完全相同的概念。理解它们的关系和区别有助于澄清它们在 Windows 应用开发中的角色。</p>
<h3 id="1-UWA（Universal-Windows-App）"><a href="#1-UWA（Universal-Windows-App）" class="headerlink" title="1. UWA（Universal Windows App）"></a>1. <strong>UWA（Universal Windows App）</strong></h3><ul>
<li><strong>定义</strong>：UWA 是一个 <strong>应用类型</strong>，即特定于 Windows 10 及以上版本的应用，设计目标是能够在不同 Windows 10 设备（如 PC、平板、手机、Xbox、HoloLens 等）之间无缝运行。UWA 强调的是应用本身的跨设备能力。</li>
<li><strong>用途</strong>：它代表了通过 Windows Store 分发的应用，支持在多种设备上安装并运行，旨在让开发者一次编写代码，适配不同类型的 Windows 设备。</li>
</ul>
<h3 id="2-UWP（Universal-Windows-Platform）"><a href="#2-UWP（Universal-Windows-Platform）" class="headerlink" title="2. UWP（Universal Windows Platform）"></a>2. <strong>UWP（Universal Windows Platform）</strong></h3><ul>
<li><strong>定义</strong>：UWP 是 <strong>开发平台</strong> 或 <strong>应用平台</strong>，它是 Windows 10 的一种应用开发框架，提供了一个统一的 API、SDK 和工具集，支持开发能够在所有 Windows 10 设备上运行的应用。UWP 是一个更大的概念，定义了开发者如何为不同设备编写和部署应用。</li>
<li><strong>用途</strong>：UWP 提供了开发跨设备应用的基础设施，开发者通过 UWP 的 API 和工具开发应用，并可以在多种 Windows 设备上运行。开发的应用通常是 UWA（Universal Windows Apps）。</li>
</ul>
<h3 id="关系："><a href="#关系：" class="headerlink" title="关系："></a><strong>关系</strong>：</h3><ul>
<li><strong>UWA 是 UWP 的一种实现</strong>。换句话说，UWA 是指通过 UWP 开发的应用，它们符合 UWP 的标准，并能够跨多个 Windows 10 设备运行。因此，每个 UWA 应用都是基于 UWP 平台开发的。</li>
<li>UWP 是开发 UWA 的框架或平台，提供了开发所需的 API 和工具，而 UWA 则是通过这个框架开发出来的应用类型。</li>
</ul>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a><strong>区别</strong>：</h3><ul>
<li><strong>UWA 是应用，UWP 是平台</strong>：UWA 是一个具体的应用类型（如应用商店中可下载的应用），而 UWP 是用于创建这些应用的开发平台和技术。</li>
<li><strong>UWA 强调应用本身的跨设备能力</strong>，即它可以在多种设备上运行；而 UWP 强调的是开发过程和基础设施，即如何使用统一的 API 开发可以运行在各种设备上的应用。</li>
<li><strong>UWA 是 UWP 的产品</strong>：通过 UWP 开发出来的应用就是 UWA。换句话说，UWA 是 UWP 架构的一个具体实例。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><ul>
<li><strong>UWP</strong> 是一个跨设备应用开发平台，开发者使用 UWP 的 API 和工具来编写应用。例如，Windows SDK、XAML、C# 等。</li>
<li><strong>UWA</strong> 是通过 UWP 开发的实际应用类型。比如，你通过 Visual Studio 和 UWP 开发框架开发了一个应用，并将它发布到 Microsoft Store。这个应用就是 UWA，它可以在 PC、平板、手机、Xbox 等设备上运行。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul>
<li><strong>UWP</strong> 是一个应用开发平台，提供了开发和部署 UWA 应用的基础设施和工具。</li>
<li><strong>UWA</strong> 是通过 UWP 平台开发的跨设备应用，它强调应用的跨设备能力，并通常通过 Microsoft Store 发布。</li>
</ul>
<p>换句话说，UWA 是在 UWP 平台上创建的应用，而 UWP 则是为开发这些应用而提供的一整套框架、工具和 API。</p>
]]></content>
  </entry>
  <entry>
    <title>Unity ScriptableObject</title>
    <url>/2025/01/16/Unity-ScriptableObject/</url>
    <content><![CDATA[<p><a href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-ScriptableObject.html">官方文档</a></p>
<p>在 Unity 中，<code>ScriptableObject</code> 是一种特殊的对象，它允许你在 Unity 编辑器中创建 <strong>可序列化</strong> 的 <strong>自定义数据容器</strong>，并且能够在多个场景、多个游戏对象之间共享数据。<code>ScriptableObject</code> 是继承自 <code>UnityEngine.ScriptableObject</code> 类的一种对象，通常用于存储数据，而不是存储行为（功能）。它是为了减少对 <code>MonoBehaviour</code> 的依赖，提升项目的灵活性和性能。</p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. <strong>基本概念</strong></h3><p><code>ScriptableObject</code> 并不像普通的 <strong>MonoBehaviour</strong> 那样附加到 GameObject 上，而是独立的、非场景物体的对象。它可以在项目中作为资产（Asset）保存，并且多个实例之间可以共享同一份数据，避免了重复存储。</p>
<ul>
<li><strong>普通对象</strong>（如 <code>MonoBehaviour</code>）通常与场景中的对象（GameObject）绑定，每个 GameObject 上可以有多个组件（Component）。</li>
<li><strong>ScriptableObject</strong> 是独立的、与场景无关的对象，它可以作为一个单独的资源在项目中保存和使用。</li>
</ul>
<h3 id="2-用途与优势"><a href="#2-用途与优势" class="headerlink" title="2. 用途与优势"></a>2. <strong>用途与优势</strong></h3><ul>
<li><p><strong>数据管理</strong>：<code>ScriptableObject</code> 非常适合存储各种类型的 <strong>配置数据</strong>、<strong>游戏状态数据</strong>、<strong>角色属性</strong>、<strong>道具配置</strong> 等。这些数据可以在多个场景和多个对象间共享，不需要在每个对象中都存储一份数据。</p>
</li>
<li><p><strong>性能优化</strong>：通过减少在 <code>MonoBehaviour</code> 中重复存储相同数据，<code>ScriptableObject</code> 有助于节省内存和存储空间。此外，<code>ScriptableObject</code> 数据通常会被序列化成资源（Asset），并且在运行时只会读取一次，而不是每次运行时都重新创建。</p>
</li>
<li><p><strong>可重用性</strong>：由于 <code>ScriptableObject</code> 是一个资产资源，可以在多个场景或多个对象之间共享，提升了代码和数据的 <strong>可重用性</strong>。例如，你可以为多个角色创建同一个 <code>ScriptableObject</code> 配置，而不需要每个角色都拥有一份独立的数据。</p>
</li>
<li><p><strong>易于调试与编辑</strong>：<code>ScriptableObject</code> 可以在 Unity 编辑器中查看和编辑，因此对数据的修改更加直观，并且能通过 Inspector 窗口直接进行。</p>
</li>
</ul>
<h3 id="3-创建和使用-ScriptableObject"><a href="#3-创建和使用-ScriptableObject" class="headerlink" title="3. 创建和使用 ScriptableObject"></a>3. <strong>创建和使用 ScriptableObject</strong></h3><p>创建 <code>ScriptableObject</code> 并使用它非常简单。以下是一个创建和使用 <code>ScriptableObject</code> 的基本流程。</p>
<h4 id="步骤-1-创建-ScriptableObject-类"><a href="#步骤-1-创建-ScriptableObject-类" class="headerlink" title="步骤 1: 创建 ScriptableObject 类"></a>步骤 1: 创建 ScriptableObject 类</h4><p>你需要创建一个继承自 <code>ScriptableObject</code> 的类来定义数据结构。您可以使用<code>CreateAssetMenu</code>属性使用您的类创建自定义资产。例如，定义一个表示角色属性的 <code>CharacterData</code> 类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(fileName = <span class="string">&quot;New Character&quot;</span>, menuName = <span class="string">&quot;Game/Character Data&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CharacterData</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> characterName;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> health;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> attack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>CharacterData</code> 类继承自 <code>ScriptableObject</code>，并包含了角色的基本属性（如名字、生命值、攻击力）。</p>
<ul>
<li><code>CreateAssetMenu</code> 特性会让你在 Unity 编辑器的右键菜单中创建该类型的 <code>ScriptableObject</code> 实例。</li>
<li>注意：脚本文件必须与类同名。</li>
</ul>
<h4 id="步骤-2-创建-ScriptableObject-实例"><a href="#步骤-2-创建-ScriptableObject-实例" class="headerlink" title="步骤 2: 创建 ScriptableObject 实例"></a>步骤 2: 创建 ScriptableObject 实例</h4><p>根据CreateAssetMenu代码中的路径来创建资源：<br><code>Assets &gt; Create &gt; xxx &gt; 并选择xxxx</code>。</p>
<p>在 Unity 编辑器中，右键单击 <strong>项目视图</strong>，然后选择 <code>Create &gt; Game &gt; Character Data</code>（这取决于你在 <code>CreateAssetMenu</code> 特性中设置的路径）。这会生成一个新的 <code>CharacterData</code> 资源，你可以为其指定值，例如：</p>
<ul>
<li><code>characterName</code> 设置为 “Hero”。</li>
<li><code>health</code> 设置为 100。</li>
<li><code>attack</code> 设置为 30。</li>
</ul>
<p>你可以创建多个不同的 <code>CharacterData</code> 资源，例如一个 <code>Warrior</code> 和一个 <code>Mage</code>，并将其用于不同的角色。</p>
<h4 id="步骤-3-使用-ScriptableObject-实例"><a href="#步骤-3-使用-ScriptableObject-实例" class="headerlink" title="步骤 3: 使用 ScriptableObject 实例"></a>步骤 3: 使用 ScriptableObject 实例</h4><p>然后，在其他脚本中，你可以引用并使用这个 <code>ScriptableObject</code> 数据。例如，创建一个 <code>Character</code> 类来使用 <code>CharacterData</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Character</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> CharacterData characterData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Character Name: &quot;</span> + characterData.characterName);</span><br><span class="line">        Debug.Log(<span class="string">&quot;Health: &quot;</span> + characterData.health);</span><br><span class="line">        Debug.Log(<span class="string">&quot;Attack: &quot;</span> + characterData.attack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>Character</code> 脚本中，你通过 <code>public</code> 变量将 <code>CharacterData</code> 资源分配给角色对象。然后，你可以在运行时访问和使用这个数据。</p>
<h3 id="4-ScriptableObject-的应用场景"><a href="#4-ScriptableObject-的应用场景" class="headerlink" title="4. ScriptableObject 的应用场景"></a>4. <strong>ScriptableObject 的应用场景</strong></h3><p><code>ScriptableObject</code> 可以用于多种场景，以下是一些典型的应用案例：</p>
<h4 id="1-游戏数据配置"><a href="#1-游戏数据配置" class="headerlink" title="(1) 游戏数据配置"></a>(1) <strong>游戏数据配置</strong></h4><p>许多游戏使用 <code>ScriptableObject</code> 来存储 <strong>配置数据</strong>，如角色属性、物品描述、武器信息等。这些数据通常在多个场景或多个对象中被共享，因此使用 <code>ScriptableObject</code> 可以减少冗余数据存储。</p>
<h4 id="2-状态机或事件系统"><a href="#2-状态机或事件系统" class="headerlink" title="(2) 状态机或事件系统"></a>(2) <strong>状态机或事件系统</strong></h4><p>在状态机或事件系统中，<code>ScriptableObject</code> 可以作为 <strong>事件数据</strong> 或 <strong>状态数据</strong> 的容器，方便管理和修改。例如，在设计一个 <strong>对话系统</strong> 时，每个对话框可以是一个 <code>ScriptableObject</code>，并包含其显示的文本、触发的事件等。</p>
<h4 id="3-可视化脚本"><a href="#3-可视化脚本" class="headerlink" title="(3) 可视化脚本"></a>(3) <strong>可视化脚本</strong></h4><p>如果你正在做可视化脚本（如 <strong>行为树</strong>、<strong>任务系统</strong> 等），<code>ScriptableObject</code> 可以用来存储不同任务或行为的定义，使得设计者可以在编辑器中直接创建和修改这些数据，而不需要编写复杂的代码。</p>
<h4 id="4-音频和动画管理"><a href="#4-音频和动画管理" class="headerlink" title="(4) 音频和动画管理"></a>(4) <strong>音频和动画管理</strong></h4><p>音频管理、动画控制等系统中，<code>ScriptableObject</code> 常用来存储不同的 <strong>音效配置</strong> 或 <strong>动画控制器配置</strong>，这样可以方便地在多个地方共享这些配置。</p>
<h3 id="5-ScriptableObject-与-MonoBehaviour-的区别"><a href="#5-ScriptableObject-与-MonoBehaviour-的区别" class="headerlink" title="5. ScriptableObject 与 MonoBehaviour 的区别"></a>5. <strong>ScriptableObject 与 MonoBehaviour 的区别</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>ScriptableObject</code></th>
<th><code>MonoBehaviour</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>附加到物体</strong></td>
<td>不附加到 GameObject，独立作为资源存在</td>
<td>附加到 GameObject 上作为组件</td>
</tr>
<tr>
<td><strong>序列化</strong></td>
<td>作为资产（Asset）保存，可直接在编辑器中编辑</td>
<td>作为场景中的一部分，编辑时通过组件修改</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td>只要引用它的地方需要它，内存才会存在</td>
<td>在场景中存在，通常与对象生命周期绑定</td>
</tr>
<tr>
<td><strong>共享数据</strong></td>
<td>可以跨多个对象和场景共享同一个 ScriptableObject 实例</td>
<td>每个 <code>MonoBehaviour</code> 实例数据独立</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>不绑定到 <code>GameObject</code>，没有生命周期函数，通常用于存储数据</td>
<td>绑定到 <code>GameObject</code>，有生命周期函数（如 <code>Start()</code>、<code>Update()</code>）</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td>作为资源存储，手动创建和销毁，不会随场景卸载而销毁</td>
<td>和 <code>GameObject</code> 一起管理，销毁时自动销毁</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>用于数据存储、配置、常量，多个场景或对象共享数据</td>
<td>适用于场景中的行为控制、物理计算、UI 控制等</td>
</tr>
<tr>
<td><strong>交互方式</strong></td>
<td>通过资源管理系统（如 Inspector）直接引用</td>
<td>附加到 <code>GameObject</code>，每个 <code>GameObject</code> 可以有多个 <code>MonoBehaviour</code></td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>配置数据、全局状态、事件系统、数据驱动设计</td>
<td>角色控制、AI、UI 更新、物理计算等</td>
</tr>
</tbody></table>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h3><p><code>ScriptableObject</code> 是 Unity 中非常强大的工具，它允许你创建独立于场景的自定义数据容器，并在多个游戏对象、场景间共享这些数据。相比于传统的 <code>MonoBehaviour</code>，<code>ScriptableObject</code> 更适合用于存储游戏的配置、状态数据等，因为它能够减少冗余，提升内存利用率，并且方便在编辑器中进行管理。</p>
]]></content>
  </entry>
  <entry>
    <title>Unity 安装包</title>
    <url>/2025/01/13/Unity-%E5%AE%89%E8%A3%85%E5%8C%85/</url>
    <content><![CDATA[<h1 id="collab-proxy-缺失-PlasticSCM-log4netPlastic-dll"><a href="#collab-proxy-缺失-PlasticSCM-log4netPlastic-dll" class="headerlink" title="collab-proxy 缺失 PlasticSCM&#x2F;log4netPlastic.dll"></a>collab-proxy 缺失 PlasticSCM&#x2F;log4netPlastic.dll</h1><p><strong>描述：</strong></p>
<blockquote>
<p>error CS0006: Metadata file ‘Library&#x2F;PackageCache&#x2F;<a href="mailto:&#x63;&#111;&#109;&#46;&#x75;&#110;&#x69;&#116;&#x79;&#x2e;&#x63;&#x6f;&#x6c;&#108;&#97;&#98;&#x2d;&#112;&#x72;&#111;&#x78;&#121;&#64;&#x32;&#x2e;&#x36;&#46;&#x30;">&#x63;&#111;&#109;&#46;&#x75;&#110;&#x69;&#116;&#x79;&#x2e;&#x63;&#x6f;&#x6c;&#108;&#97;&#98;&#x2d;&#112;&#x72;&#111;&#x78;&#121;&#64;&#x32;&#x2e;&#x36;&#46;&#x30;</a>&#x2F;Lib&#x2F;Editor&#x2F;PlasticSCM&#x2F;log4netPlastic.dll’ could not be found</p>
</blockquote>
<p><strong>原因分析：</strong></p>
<p>这个错误 <code>error CS0006</code> 表示 <strong>编译器无法找到所需的 DLL 文件</strong>，而在你的报错信息中，缺失的文件是 <code>log4netPlastic.dll</code>，它属于 Unity Collaboration 或 PlasticSCM（Unity 的版本控制工具）。</p>
<p>创建项目时，我没有勾选：</p>
<p><img src="/.io//image.png" alt="alt text"> </p>
<p>因此缺少插件。</p>
<hr>
<p><strong>解决步骤：</strong></p>
<ol>
<li>在 <code>manifest.json</code> 中删除了 <code>com.unity.collab-proxy</code> 依赖项</li>
<li>删除项目中的 <code>Library</code> 文件夹（可以直接在文件管理器中删除）。</li>
<li>关闭 Unity 编辑器。</li>
<li>重新打开 Unity 项目。Unity 会重新生成 <code>Library</code> 文件夹并更新依赖关系。</li>
</ol>
<h1 id="多余安装包移除"><a href="#多余安装包移除" class="headerlink" title="多余安装包移除"></a>多余安装包移除</h1><p>在 Unity 项目中，<code>manifest.json</code> 文件的 <code>dependencies</code> 列表定义了当前项目所包含的包。以下是对这些包的分类及其功能的简要介绍，并分析哪些是非必要的，可以根据需求移除。</p>
<hr>
<h3 id="核心包-必要的"><a href="#核心包-必要的" class="headerlink" title="核心包 (必要的)"></a><strong>核心包 (必要的)</strong></h3><p>这些包是 Unity 运行和项目创建所必须的，通常不应移除。</p>
<ol>
<li><p><code>com.unity.modules.</code></p>
<ul>
<li>Unity 的核心模块，大部分是内置引擎功能的模块化组件。</li>
<li>常用模块：<ul>
<li><code>com.unity.modules.animation</code>：动画功能（Mecanim）。</li>
<li><code>com.unity.modules.particlesystem</code>：粒子系统。</li>
<li><code>com.unity.modules.physics</code>：3D 物理系统。</li>
<li><code>com.unity.modules.physics2d</code>：2D 物理系统。</li>
<li><code>com.unity.modules.audio</code>：音频功能。</li>
<li><code>com.unity.modules.ui</code>：UGUI 系统。</li>
<li><code>com.unity.modules.imgui</code>：IMGUI 功能（用于编辑器自定义工具）。</li>
</ul>
</li>
<li>不常用模块：<ul>
<li><code>com.unity.modules.vehicles</code>：车辆模块。</li>
<li><code>com.unity.modules.wind</code>：风力模拟。</li>
<li><code>com.unity.modules.terrainphysics</code>：带物理功能的地形模块。</li>
</ul>
</li>
<li>建议：<strong>根据具体需求保留常用模块，移除不需要的模块</strong>。</li>
</ul>
</li>
<li><p><code>com.unity.ugui</code></p>
<ul>
<li>Unity 的基础 UI 系统（即 <code>UnityEngine.UI</code>）。</li>
<li>建议：必要，保留。</li>
</ul>
</li>
<li><p><code>com.unity.timeline</code></p>
<ul>
<li>提供时间轴功能，用于制作过场动画、剪辑等。</li>
<li>建议：如果项目不涉及动画或时间轴功能，可以移除。</li>
</ul>
</li>
<li><p><code>com.unity.textmeshpro</code></p>
<ul>
<li>高级文本渲染工具，几乎是所有项目的标配。</li>
<li>建议：必要，保留。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="开发工具-可选，根据-IDE"><a href="#开发工具-可选，根据-IDE" class="headerlink" title="开发工具 (可选，根据 IDE)"></a><strong>开发工具 (可选，根据 IDE)</strong></h3><p>这些包与开发环境有关，可以根据所用的开发工具选择性保留。</p>
<ol>
<li><p><code>com.unity.ide.rider</code></p>
<ul>
<li>为 JetBrains Rider 提供支持。</li>
<li>建议：如果使用 Rider 作为 IDE，保留；否则移除。</li>
</ul>
</li>
<li><p><code>com.unity.ide.visualstudio</code></p>
<ul>
<li>为 Visual Studio 提供支持。</li>
<li>建议：如果使用 Visual Studio，保留；否则移除。</li>
</ul>
</li>
<li><p><code>com.unity.ide.vscode</code></p>
<ul>
<li>为 Visual Studio Code 提供支持。</li>
<li>建议：如果使用 VS Code，保留；否则移除。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="协作与测试-可选"><a href="#协作与测试-可选" class="headerlink" title="协作与测试 (可选)"></a><strong>协作与测试 (可选)</strong></h3><p>这些包与项目协作和测试有关，可以根据需求选择。</p>
<ol>
<li><p><code>com.unity.collab-proxy</code></p>
<ul>
<li>Unity Collaborate 的代理包，用于协作和版本控制。</li>
<li>建议：如果不使用 Collaborate（推荐 Git），可以移除。</li>
</ul>
</li>
<li><p><code>com.unity.test-framework</code></p>
<ul>
<li>提供测试框架，用于编写单元测试和集成测试。</li>
<li>建议：如果项目不需要测试，可以移除。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="渲染与特效-根据项目需求"><a href="#渲染与特效-根据项目需求" class="headerlink" title="渲染与特效 (根据项目需求)"></a><strong>渲染与特效 (根据项目需求)</strong></h3><p>与渲染管线和图形功能相关，需根据项目需求选择。</p>
<ol>
<li><code>com.unity.render-pipelines.universal</code><ul>
<li>通用渲染管线（URP），适用于大多数平台的优化渲染解决方案。</li>
<li>建议：如果项目使用内置渲染管线且不使用 URP，可以移除。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="可视化脚本-可选"><a href="#可视化脚本-可选" class="headerlink" title="可视化脚本 (可选)"></a><strong>可视化脚本 (可选)</strong></h3><ol>
<li><code>com.unity.visualscripting</code><ul>
<li>Unity 的可视化脚本系统（Bolt）。</li>
<li>建议：如果项目完全使用 C# 编程，不需要可视化脚本，可以移除。</li>
</ul>
</li>
</ol>
<h2 id="不常用插件"><a href="#不常用插件" class="headerlink" title="不常用插件"></a>不常用插件</h2><p>以下是您提到的 Unity 模块的作用、使用方法以及适用场景的详细说明：</p>
<h3 id="1-com-unity-timeline"><a href="#1-com-unity-timeline" class="headerlink" title="1. com.unity.timeline"></a><strong>1. com.unity.timeline</strong></h3><p><strong>作用</strong></p>
<ul>
<li><strong>Timeline</strong> 是 Unity 提供的可视化时间线编辑工具，用于制作动画、过场动画、游戏事件序列等。</li>
<li>允许通过拖放资源（动画、声音、事件等）来创建复杂的时间轴序列。</li>
</ul>
<p><strong>使用方法</strong></p>
<ol>
<li><strong>打开 Timeline 窗口：</strong><ul>
<li>在 Unity 编辑器中，导航到 <strong>Window &gt; Sequencing &gt; Timeline</strong>。</li>
</ul>
</li>
<li><strong>创建 Timeline：</strong><ul>
<li>选择一个 GameObject，右键点击并选择 <strong>Create Timeline</strong>。</li>
</ul>
</li>
<li><strong>添加轨道（Track）：</strong><ul>
<li>添加动画轨道（Animation Track）、音频轨道（Audio Track）、信号轨道（Signal Track）等。</li>
</ul>
</li>
<li><strong>播放控制：</strong><ul>
<li>使用 PlayableDirector 控制 Timeline 的播放。</li>
</ul>
</li>
</ol>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>过场动画：</strong> 制作带有镜头运动、角色动画和音效的游戏过场。</li>
<li><strong>复杂事件序列：</strong> 比如任务触发时多个游戏对象的交互（如解谜游戏）。</li>
<li><strong>动画合成：</strong> 将多个动画片段组合成复杂动画。</li>
</ul>
<hr>
<h3 id="2-com-unity-visualscripting"><a href="#2-com-unity-visualscripting" class="headerlink" title="2. com.unity.visualscripting"></a><strong>2. com.unity.visualscripting</strong></h3><p><strong>作用</strong></p>
<ul>
<li><strong>Visual Scripting</strong> 是 Unity 提供的可视化脚本工具，允许开发者通过图形界面（无需代码）实现逻辑功能。</li>
<li>为不擅长编程的设计师、艺术家提供了一种实现游戏逻辑的方法。</li>
</ul>
<p><strong>使用方法</strong></p>
<ol>
<li><strong>安装 Visual Scripting 模块：</strong><ul>
<li>在 Unity Package Manager 中搜索并安装 <strong>Visual Scripting</strong>。</li>
</ul>
</li>
<li><strong>创建脚本图（Script Graph）：</strong><ul>
<li>在 GameObject 上添加 <strong>Script Machine</strong> 组件。</li>
<li>打开图形化编辑器，拖放节点实现逻辑。</li>
</ul>
</li>
<li><strong>常见节点：</strong><ul>
<li>条件分支（If）、变量设置&#x2F;获取（Set&#x2F;Get Variable）、事件监听（On Trigger Enter）等。</li>
</ul>
</li>
</ol>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>快速原型开发：</strong> 快速创建和测试逻辑功能。</li>
<li><strong>任务管理：</strong> 制作触发任务、计分板等。</li>
<li><strong>交互设计：</strong> 设计简单的交互功能，比如点击按钮切换场景。</li>
</ul>
<hr>
<h3 id="3-com-unity-modules-vehicles"><a href="#3-com-unity-modules-vehicles" class="headerlink" title="3. com.unity.modules.vehicles"></a><strong>3. com.unity.modules.vehicles</strong></h3><p><strong>作用</strong></p>
<ul>
<li>提供与车辆相关的功能，包括车轮碰撞检测（WheelCollider）和车辆运动控制。</li>
<li>可用于创建具有真实物理特性的车辆。</li>
</ul>
<p><strong>使用方法</strong></p>
<ol>
<li><strong>车辆控制：</strong><ul>
<li>使用 <strong>WheelCollider</strong> 模拟车轮的物理行为（如悬挂、摩擦力）。</li>
<li>为车身（Rigidbody）添加适当的力来驱动车辆。</li>
</ul>
</li>
<li><strong>脚本控制：</strong><ul>
<li>使用 <code>WheelCollider.motorTorque</code> 来控制车轮的动力。</li>
<li>使用 <code>WheelCollider.steerAngle</code> 来控制转向。</li>
</ul>
</li>
</ol>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>赛车游戏：</strong> 制作真实感的车辆物理控制。</li>
<li><strong>车辆模拟：</strong> 比如汽车驾驶模拟器或工程车辆模拟（挖掘机、卡车）。</li>
<li><strong>机器人控制：</strong> 带轮机器人的物理模拟。</li>
</ul>
<hr>
<h3 id="4-com-unity-modules-wind"><a href="#4-com-unity-modules-wind" class="headerlink" title="4. com.unity.modules.wind"></a><strong>4. com.unity.modules.wind</strong></h3><p><strong>作用</strong></p>
<ul>
<li>提供基础的风力模拟功能，主要与树木和植被交互使用。</li>
<li>用于动态模拟场景中风吹动的效果。</li>
</ul>
<p><strong>使用方法</strong></p>
<ol>
<li><strong>添加 Wind Zone：</strong><ul>
<li>在场景中创建一个 <strong>Wind Zone</strong> 对象。</li>
<li>设置风力强度（Wind Main）、湍流（Turbulence）等参数。</li>
</ul>
</li>
<li><strong>与植被交互：</strong><ul>
<li>确保使用 Unity 的 SpeedTree 模型，树叶和枝干会响应 Wind Zone 的风力设置。</li>
</ul>
</li>
</ol>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>自然场景：</strong> 模拟风吹动的效果，比如吹动树叶、草地。</li>
<li><strong>环境模拟：</strong> 模拟暴风雨场景中的风力。</li>
<li><strong>动态效果：</strong> 用于提高场景的动态表现力。</li>
</ul>
<hr>
<h3 id="5-com-unity-modules-terrainphysics"><a href="#5-com-unity-modules-terrainphysics" class="headerlink" title="5. com.unity.modules.terrainphysics"></a><strong>5. com.unity.modules.terrainphysics</strong></h3><p><strong>作用</strong></p>
<ul>
<li>提供地形与物理系统的交互功能，允许物理对象在地形上正确运动和碰撞。</li>
<li>在地形上动态生成物理效果，比如球滚动、车辆行驶等。</li>
</ul>
<p><strong>使用方法</strong></p>
<ol>
<li><strong>创建带物理的地形：</strong><ul>
<li>在地形组件上勾选 <strong>Enable Physics</strong>。</li>
<li>确保地形层级支持物理对象的碰撞（默认是 <code>Default</code> 层）。</li>
</ul>
</li>
<li><strong>与 Rigidbody 交互：</strong><ul>
<li>放置 Rigidbody 的对象（如球、箱子）在地形上，它们会根据地形形状产生物理反应。</li>
</ul>
</li>
</ol>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>物理交互：</strong> 制作游戏中的滑坡效果、车辆行驶效果等。</li>
<li><strong>地形动态变化：</strong> 与其他物理对象互动，如物体滚落、坠毁。</li>
<li><strong>开放世界游戏：</strong> 制作大面积可交互地形，比如山地、丘陵。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th><strong>模块</strong></th>
<th><strong>作用</strong></th>
<th><strong>典型场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>com.unity.timeline</strong></td>
<td>时间轴动画编辑工具</td>
<td>游戏过场动画、事件序列、动画合成</td>
</tr>
<tr>
<td><strong>com.unity.visualscripting</strong></td>
<td>图形化脚本工具</td>
<td>快速原型、任务管理、简单交互逻辑</td>
</tr>
<tr>
<td><strong>com.unity.modules.vehicles</strong></td>
<td>模拟车辆物理行为</td>
<td>赛车游戏、车辆模拟、机器人物理</td>
</tr>
<tr>
<td><strong>com.unity.modules.wind</strong></td>
<td>风力模拟，影响树木和植被</td>
<td>自然场景、暴风雨效果、提高动态表现</td>
</tr>
<tr>
<td><strong>com.unity.modules.terrainphysics</strong></td>
<td>地形与物理交互</td>
<td>开放世界物理效果（滑坡、滚动），动态地形与碰撞</td>
</tr>
</tbody></table>
<p>这些模块主要是针对特定的功能需求开发，如果您的项目需要类似的功能，可以根据需求启用并结合 Unity 提供的 API 使用。</p>
<hr>
<h2 id="移除后的注意事项"><a href="#移除后的注意事项" class="headerlink" title="移除后的注意事项"></a><strong>移除后的注意事项</strong></h2><ol>
<li><p><strong>如何移除</strong></p>
<ul>
<li>打开 <code>manifest.json</code> 文件，直接删除对应依赖项。</li>
<li>运行 Unity，确保不会报错（删除前建议备份）。</li>
</ul>
</li>
<li><p><strong>检查依赖关系</strong></p>
<ul>
<li>某些包可能依赖其他包，移除时需检查项目是否仍能正常运行。</li>
<li>可以通过 Unity 的 <strong>Package Manager</strong> 界面检查依赖关系。</li>
</ul>
</li>
<li><p><strong>性能优化</strong></p>
<ul>
<li>移除非必要的包可以减小项目体积，减少加载时间，优化性能。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="建议的精简示例"><a href="#建议的精简示例" class="headerlink" title="建议的精简示例"></a><strong>建议的精简示例</strong></h2><p>如果你的项目不涉及协作、不使用 URP 或 Visual Scripting 等功能，可以精简为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;com.unity.textmeshpro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3.0.6&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;com.unity.timeline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.7.6&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;com.unity.ugui&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;com.unity.modules.animation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;com.unity.modules.audio&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;com.unity.modules.particlesystem&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;com.unity.modules.physics&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;com.unity.modules.ui&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="未使用的包"><a href="#未使用的包" class="headerlink" title="未使用的包"></a>未使用的包</h1><p>在 Unity 工程中，未使用的包可能会对项目产生一些负面影响，同时移除这些包也能带来诸多好处。以下是具体的分析：</p>
<hr>
<h2 id="未使用包的影响"><a href="#未使用包的影响" class="headerlink" title="未使用包的影响"></a><strong>未使用包的影响</strong></h2><ol>
<li><p><strong>占用磁盘空间</strong></p>
<ul>
<li>Unity 包含的所有依赖项都会存储在 <code>Library</code> 和 <code>Packages</code> 文件夹中，占用本地磁盘空间。</li>
<li>如果包中包含大量未使用的资源、脚本或工具（如渲染管线、测试框架），会使项目体积膨胀。</li>
</ul>
</li>
<li><p><strong>增加加载时间</strong></p>
<ul>
<li>Unity 编辑器启动时会解析所有的依赖项，即使某些包没有实际被使用，它们仍会在加载时被扫描、初始化。</li>
<li>例如，<code>com.unity.collab-proxy</code>（Collaborate 相关工具）会加载协作工具的后台进程，可能会拖慢启动速度。</li>
</ul>
</li>
<li><p><strong>影响构建时间</strong></p>
<ul>
<li>构建时，Unity 会对所有包进行依赖检查，未使用的包仍然会参与构建过程。</li>
<li>这可能增加构建时间，甚至会因为某些包的依赖关系导致不必要的资源被打包进构建文件。</li>
</ul>
</li>
<li><p><strong>代码冗余与冲突</strong></p>
<ul>
<li>部分包会引入额外的 API 和功能模块，如果不使用这些功能，会导致代码库显得臃肿。</li>
<li>一些包可能与项目现有功能发生冲突或引入不必要的复杂性（如 <strong>Visual Scripting</strong> 与手写代码的逻辑冲突）。</li>
</ul>
</li>
<li><p><strong>增加维护成本</strong></p>
<ul>
<li>未使用的包可能随着 Unity 版本更新而失效或产生错误（例如废弃的包无法与新版本兼容）。</li>
<li>开发者需要额外花时间排查是否是这些无用包导致问题。</li>
</ul>
</li>
</ol>
<h2 id="如何安全删除未使用的包"><a href="#如何安全删除未使用的包" class="headerlink" title="如何安全删除未使用的包"></a><strong>如何安全删除未使用的包</strong></h2><ol>
<li><p><strong>使用 Package Manager</strong></p>
<ul>
<li>打开 Unity 编辑器，依次点击 <code>Window -&gt; Package Manager</code>。</li>
<li>找到未使用的包，点击 <code>Remove</code>。项目的包使用 remove ,核心模块（Bulit-in）用 disable</li>
<li>这个方式可以查询包的依赖，但是的逐个移除。</li>
</ul>
</li>
<li><p>手动编辑 <code>manifest.json</code></p>
<ul>
<li>打开项目根目录的 <code>Packages/manifest.json</code> 文件。</li>
<li>找到对应的包依赖，删除对应条目后保存。</li>
<li>删除包后，清理 <code>Library</code> 文件夹，强制 Unity 重新生成项目缓存。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>删除未使用的包可以显著减少项目体积、提升性能和可维护性，但需要谨慎操作，避免删除必要功能。建议通过工具（如 Package Manager）和测试（如完整运行项目）确保安全性，并针对不同项目需求决定具体的优化策略。</p>
<h1 id="Unity-包管理器的四个主要页签"><a href="#Unity-包管理器的四个主要页签" class="headerlink" title="Unity 包管理器的四个主要页签"></a><strong>Unity 包管理器的四个主要页签</strong></h1><ol>
<li><strong>In Project（项目中）</strong>  <ul>
<li><strong>功能</strong>：显示当前项目中安装的包，包括从 Unity Registry 添加的包或自定义包。  </li>
<li><strong>用途</strong>：<ul>
<li>管理项目中使用的功能包，如升级、降级或移除。</li>
</ul>
</li>
<li><strong>场景</strong>：想优化项目依赖，或确认已经安装的包的版本信息。</li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li><strong>Unity Registry（Unity 注册表）</strong>  <ul>
<li><strong>功能</strong>：显示 Unity 官方提供的功能包（<strong>未安装</strong>）。  </li>
<li><strong>用途</strong>：<ul>
<li>安装 Unity 官方维护的工具或模块（如 Animation Rigging、Cinemachine、URP）。</li>
</ul>
</li>
<li><strong>场景</strong>：需要从 Unity 提供的功能库中添加新功能模块。</li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li><strong>My Assets（我的资源）</strong>  <ul>
<li><strong>功能</strong>：显示与当前登录 Unity 账户绑定的 Asset Store 资源。  </li>
<li><strong>用途</strong>：<ul>
<li>从 Asset Store 导入素材、工具或插件到项目中。</li>
</ul>
</li>
<li><strong>场景</strong>：需要使用个人或团队已购买的资源。</li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li><strong>Built-in（内置模块）</strong>  <ul>
<li><strong>功能</strong>：显示 Unity 引擎的核心内置模块（如 Audio、Physics、Terrain 等）。  </li>
<li><strong>特点</strong>：<ul>
<li>这些模块是 Unity 引擎的核心组成部分，默认是启用状态。  </li>
<li>可以选择禁用不需要的模块来减少项目构建体积。</li>
</ul>
</li>
<li><strong>用途</strong>：<ul>
<li>查看哪些内置模块已启用或被禁用。  </li>
<li>在特定场景下禁用不需要的模块（例如，2D 游戏可能不需要 3D Physics）。</li>
</ul>
</li>
<li><strong>场景</strong>：优化项目性能或构建体积时管理内置模块。</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Unity 开发非游戏应用</title>
    <url>/2025/01/15/Unity-%E5%BC%80%E5%8F%91%E9%9D%9E%E6%B8%B8%E6%88%8F%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>Unity 是一个强大的跨平台开发工具，虽然它主要用于游戏开发，但也可以用于开发普通软件（如工具类应用、展示应用或数字孪生系统）。如果目标是使用 Unity 开发普通软件，为了减少项目的体积和复杂度，以及优化性能，可以有选择地移除或禁用一些与普通软件无关的功能和模块。</p>
<p>以下是可以移除或优化的内容：</p>
<hr>
<h3 id="1-移除与游戏开发相关的功能"><a href="#1-移除与游戏开发相关的功能" class="headerlink" title="1. 移除与游戏开发相关的功能"></a><strong>1. 移除与游戏开发相关的功能</strong></h3><h4 id="a-不需要的模块和功能"><a href="#a-不需要的模块和功能" class="headerlink" title="a. 不需要的模块和功能"></a><strong>a. 不需要的模块和功能</strong></h4><p>Unity 包含许多针对游戏开发的模块，普通软件通常用不上，可以在 Unity Hub 中的项目设置中禁用：</p>
<ul>
<li><strong>Physics（物理模块）</strong><ul>
<li>如果不需要物理模拟，可以禁用 2D 和 3D 物理引擎（如 Rigidbody 和 Collider）。</li>
</ul>
</li>
<li><strong>AI Navigation（导航网格）</strong><ul>
<li>如果不需要路径寻路功能，可以禁用该模块。</li>
</ul>
</li>
<li><strong>Animation（动画模块）</strong><ul>
<li>如果没有复杂的动画需求，可以禁用 Mecanim 动画系统。</li>
</ul>
</li>
<li><strong>Particle System（粒子系统）</strong><ul>
<li>如果应用不需要特效，可以移除相关模块。</li>
</ul>
</li>
</ul>
<h4 id="b-项目中未使用的脚本和资源"><a href="#b-项目中未使用的脚本和资源" class="headerlink" title="b. 项目中未使用的脚本和资源"></a><strong>b. 项目中未使用的脚本和资源</strong></h4><ul>
<li>移除示例资源和默认导入的 Assets。</li>
<li>不加载未使用的脚本、插件或材质。</li>
</ul>
<hr>
<h3 id="2-优化项目设置"><a href="#2-优化项目设置" class="headerlink" title="2. 优化项目设置"></a><strong>2. 优化项目设置</strong></h3><h4 id="a-减少渲染相关功能"><a href="#a-减少渲染相关功能" class="headerlink" title="a. 减少渲染相关功能"></a><strong>a. 减少渲染相关功能</strong></h4><p>普通软件的界面通常不需要复杂的渲染效果，可以进行以下优化：</p>
<ul>
<li><strong>禁用实时光照（Realtime Lighting）</strong><ul>
<li>将场景光照设置为静态或简单的全局光照。</li>
</ul>
</li>
<li><strong>移除后处理（Post-Processing）</strong><ul>
<li>如果不需要高质量视觉效果，可以移除后处理堆栈。</li>
</ul>
</li>
<li><strong>减少 Shader 使用</strong><ul>
<li>如果不需要复杂材质，可以使用简单的 Unlit 或 UI 专用 Shader。</li>
</ul>
</li>
</ul>
<h4 id="b-禁用不必要的引擎特性"><a href="#b-禁用不必要的引擎特性" class="headerlink" title="b. 禁用不必要的引擎特性"></a><strong>b. 禁用不必要的引擎特性</strong></h4><ul>
<li><strong>音频模块</strong><ul>
<li>如果软件不涉及音频播放，可以在 Player Settings 中禁用 Audio。</li>
</ul>
</li>
<li><strong>Multiplayer（多人网络模块）</strong><ul>
<li>普通软件不需要 Unity 的 Netcode，可以移除该模块。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-精简打包体积"><a href="#3-精简打包体积" class="headerlink" title="3. 精简打包体积"></a><strong>3. 精简打包体积</strong></h3><h4 id="a-Player-Settings-调整"><a href="#a-Player-Settings-调整" class="headerlink" title="a. Player Settings 调整"></a><strong>a. Player Settings 调整</strong></h4><ul>
<li><strong>Script Stripping（脚本裁剪）</strong><ul>
<li>启用 IL2CPP 并使用 Managed Stripping Level（Medium 或 High），减少不必要的脚本代码。</li>
</ul>
</li>
<li><strong>压缩资源</strong><ul>
<li>使用压缩格式（如 ASTC 或 ETC2）处理贴图，优化打包大小。</li>
</ul>
</li>
</ul>
<h4 id="b-剔除未使用的代码和资源"><a href="#b-剔除未使用的代码和资源" class="headerlink" title="b. 剔除未使用的代码和资源"></a><strong>b. 剔除未使用的代码和资源</strong></h4><ul>
<li>启用 <strong>Strip Engine Code</strong>，剔除未使用的引擎功能。</li>
<li>删除项目中未引用的资源（可以通过 Unity Profiler 或分析工具检查）。</li>
</ul>
<h4 id="c-平台相关优化"><a href="#c-平台相关优化" class="headerlink" title="c. 平台相关优化"></a><strong>c. 平台相关优化</strong></h4><ul>
<li>针对目标平台，移除不需要的平台支持文件：<ul>
<li>在打包时仅选择目标平台（如 Windows、Android），避免引入多余的平台资源。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-简化界面和逻辑"><a href="#4-简化界面和逻辑" class="headerlink" title="4. 简化界面和逻辑"></a><strong>4. 简化界面和逻辑</strong></h3><h4 id="a-使用-UI-专用功能"><a href="#a-使用-UI-专用功能" class="headerlink" title="a. 使用 UI 专用功能"></a><strong>a. 使用 UI 专用功能</strong></h4><p>普通软件的主要交互是通过 UI：</p>
<ul>
<li><strong>Canvas System</strong>：<ul>
<li>使用 Unity 的 UI 系统（如 UGUI 或 TextMeshPro）进行界面设计。</li>
</ul>
</li>
<li><strong>Event System</strong>：<ul>
<li>使用简单的点击、拖拽等事件，而无需复杂的游戏交互。</li>
</ul>
</li>
</ul>
<h4 id="b-使用场景管理优化加载"><a href="#b-使用场景管理优化加载" class="headerlink" title="b. 使用场景管理优化加载"></a><strong>b. 使用场景管理优化加载</strong></h4><ul>
<li><strong>Single Scene 模式</strong><ul>
<li>普通软件通常只有一个主界面，可以使用单场景管理。</li>
</ul>
</li>
<li><strong>AssetBundle 和 Addressables</strong><ul>
<li>如果需要动态加载资源，可用 Addressables 优化资源管理。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-替代默认功能"><a href="#5-替代默认功能" class="headerlink" title="5. 替代默认功能"></a><strong>5. 替代默认功能</strong></h3><p>Unity 的某些功能对普通软件来说可能是过度设计，可以替换为更轻量的实现：</p>
<ul>
<li><strong>日志系统</strong><ul>
<li>替换 Unity 自带的 Debug.Log 为轻量级日志库。</li>
</ul>
</li>
<li><strong>数据存储</strong><ul>
<li>使用 JSON、SQLite 或普通文件替代 PlayerPrefs 进行数据存储。</li>
</ul>
</li>
<li><strong>网络通信</strong><ul>
<li>使用轻量的第三方库（如 RestSharp 或 UnityWebRequest）代替复杂的网络模块。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="推荐开发和优化步骤"><a href="#推荐开发和优化步骤" class="headerlink" title="推荐开发和优化步骤"></a><strong>推荐开发和优化步骤</strong></h3><ol>
<li><p><strong>移除多余功能模块</strong>：</p>
<ul>
<li>在 Unity Hub 的 “Add Modules” 中，仅保留目标平台所需的核心模块。</li>
</ul>
</li>
<li><p><strong>简化图形渲染</strong>：</p>
<ul>
<li>使用简单的材质、禁用光照和阴影。</li>
</ul>
</li>
<li><p><strong>压缩和裁剪项目</strong>：</p>
<ul>
<li>使用 Build Report 检查项目大小，逐步优化资源和代码。</li>
</ul>
</li>
<li><p><strong>优化打包平台</strong>：</p>
<ul>
<li>优先选择轻量的打包设置，如 Android 的 IL2CPP + Minify。</li>
</ul>
</li>
<li><p><strong>UI 专注</strong>：</p>
<ul>
<li>将重点放在用户界面设计上，精简其交互逻辑。</li>
</ul>
</li>
</ol>
<hr>
<p>通过以上优化，你可以让 Unity 成为一个适合普通软件开发的平台。如果需要进一步细化某个方面的操作，欢迎详细讨论！</p>
]]></content>
  </entry>
  <entry>
    <title>Unity 托管代码与非托管代码</title>
    <url>/2025/01/16/Unity-%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E4%B8%8E%E9%9D%9E%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>你提到的“托管代码”与“与托管代码”似乎是对术语的重复或笔误。这里我会解释 <strong>托管代码</strong> 和 <strong>非托管代码</strong>（通常是与托管代码相对的概念），以及它们的区别。</p>
<h3 id="1-托管代码（Managed-Code）"><a href="#1-托管代码（Managed-Code）" class="headerlink" title="1. 托管代码（Managed Code）"></a>1. <strong>托管代码（Managed Code）</strong></h3><p><strong>托管代码</strong> 是由 .NET 运行时（如 <strong>CLR</strong>，即公共语言运行时）托管和管理的代码。也就是说，托管代码的执行是在 <strong>CLR 环境中</strong>进行的，CLR 提供了内存管理、异常处理、垃圾回收、安全性等功能。这意味着开发者无需自己管理内存分配和释放，CLR 会负责这些操作。</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>内存管理</strong>：托管代码的内存管理是由垃圾回收器（GC，Garbage Collector）自动处理的。</li>
<li><strong>类型安全</strong>：CLR 会确保类型的安全性，例如防止类型转换错误、非法内存访问等。</li>
<li><strong>自动垃圾回收</strong>：CLR 会定期回收不再使用的内存空间，避免内存泄漏。</li>
<li><strong>安全性</strong>：CLR 会进行代码的安全检查，确保代码不会执行恶意操作。</li>
<li><strong>平台独立性</strong>：托管代码一般是通过 <strong>中间语言（IL，Intermediate Language）</strong> 编译的，这样可以通过不同平台上的 CLR 实现执行。</li>
</ul>
<p>托管代码的一个例子就是 <strong>C#</strong> 中编写的代码，它会被编译成 <strong>中间语言（IL）</strong>，然后在 .NET 环境中运行。</p>
<p><strong>例如</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就是托管代码，它会被 C# 编译器编译为中间语言（IL），然后通过 CLR 执行。</p>
<h3 id="2-非托管代码（Unmanaged-Code）"><a href="#2-非托管代码（Unmanaged-Code）" class="headerlink" title="2. 非托管代码（Unmanaged Code）"></a>2. <strong>非托管代码（Unmanaged Code）</strong></h3><p><strong>非托管代码</strong> 是指不由 CLR 或类似的运行时环境管理的代码。这类代码直接与操作系统交互，开发者必须手动管理内存、资源和安全性等问题。非托管代码通常是用 <strong>C++<strong>、</strong>C</strong> 或其他低级语言编写的。</p>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>手动内存管理</strong>：开发者需要自己负责分配和释放内存，容易出现内存泄漏问题。</li>
<li><strong>直接访问硬件</strong>：非托管代码能够直接操作硬件，进行系统级别的操作。</li>
<li><strong>无垃圾回收</strong>：没有像 CLR 那样的垃圾回收机制，必须手动释放资源。</li>
<li><strong>性能优势</strong>：由于没有运行时环境的管理，非托管代码通常比托管代码更加高效，尤其是在对性能要求极高的场景下。</li>
</ul>
<p>非托管代码通常被编译为机器码并直接运行在操作系统上。</p>
<p><strong>例如</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 C++ 代码是非托管代码，它被编译为机器代码，直接在操作系统中执行。</p>
<h3 id="3-托管代码与非托管代码的区别"><a href="#3-托管代码与非托管代码的区别" class="headerlink" title="3. 托管代码与非托管代码的区别"></a>3. <strong>托管代码与非托管代码的区别</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>托管代码</th>
<th>非托管代码</th>
</tr>
</thead>
<tbody><tr>
<td>执行环境</td>
<td>运行在 <strong>CLR</strong>（公共语言运行时）中</td>
<td>直接运行在操作系统上</td>
</tr>
<tr>
<td>内存管理</td>
<td>自动由 <strong>垃圾回收器（GC）</strong> 管理</td>
<td>需要开发者手动管理内存</td>
</tr>
<tr>
<td>类型安全</td>
<td>自动进行类型检查，防止类型错误</td>
<td>可能会发生类型错误，必须手动管理</td>
</tr>
<tr>
<td>安全性</td>
<td>CLR 进行安全检查，防止恶意代码执行</td>
<td>代码可能没有安全性保障，易受攻击</td>
</tr>
<tr>
<td>性能</td>
<td>性能较低，因为有垃圾回收等运行时开销</td>
<td>性能较高，因为没有运行时环境的开销</td>
</tr>
<tr>
<td>示例语言</td>
<td>C#、VB.NET、F# 等</td>
<td>C、C++ 等</td>
</tr>
<tr>
<td>可移植性</td>
<td>通过中间语言（IL）可以跨平台运行</td>
<td>必须针对每个平台进行编译</td>
</tr>
</tbody></table>
<h3 id="4-托管代码与非托管代码的交互"><a href="#4-托管代码与非托管代码的交互" class="headerlink" title="4. 托管代码与非托管代码的交互"></a>4. <strong>托管代码与非托管代码的交互</strong></h3><p>虽然托管代码和非托管代码有很多差异，但在实际应用中，它们经常需要互相交互，特别是在需要访问系统底层或与已有的非托管代码库集成时。通常有几种方式来实现托管代码与非托管代码的交互：</p>
<ul>
<li><p><strong>P&#x2F;Invoke（平台调用）</strong>：托管代码可以通过 <strong>P&#x2F;Invoke</strong> 调用非托管的 API（例如 Windows API）。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">DllImport(<span class="string">&quot;kernel32.dll&quot;</span>, CharSet = CharSet.Auto)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">GetConsoleWindow</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        IntPtr hwnd = GetConsoleWindow();</span><br><span class="line">        Console.WriteLine(hwnd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是通过 <strong>P&#x2F;Invoke</strong> 调用 Windows 的非托管函数 <code>GetConsoleWindow</code>。</p>
</li>
<li><p><strong>C++&#x2F;CLI（C++ 和托管代码混合）</strong>：C++&#x2F;CLI 是一种可以同时操作托管代码和非托管代码的语言，可以方便地在同一项目中混合使用 C++（非托管代码）和 C#（托管代码）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#using <span class="string">&lt;System.dll&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ref <span class="keyword">class</span> <span class="title class_">ManagedClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Console::<span class="built_in">WriteLine</span>(<span class="string">&quot;Hello from C++/CLI!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>COM（组件对象模型）</strong>：通过 COM 机制，非托管代码可以通过 COM 接口与托管代码进行交互。</p>
</li>
</ul>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h3><ul>
<li><strong>托管代码</strong> 是由 .NET 运行时管理的代码，它具有内存管理、安全性和平台独立性的优势。常见的托管语言包括 C# 和 VB.NET。</li>
<li><strong>非托管代码</strong> 是直接运行在操作系统上的代码，需要开发者手动管理内存和资源，常见的非托管语言包括 C 和 C++。</li>
<li>在很多情况下，托管代码和非托管代码是需要协同工作的，Unity 中通常使用托管代码（如 C#），但在需要性能或底层系统调用时，也可以使用非托管代码（如 C++）。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Unity 渲染管线选择</title>
    <url>/2025/01/13/Unity-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h3 id="选择渲染模式的建议"><a href="#选择渲染模式的建议" class="headerlink" title="选择渲染模式的建议"></a><strong>选择渲染模式的建议</strong></h3><ol>
<li><p><strong>内置渲染管线 (Built-In Render Pipeline)</strong>  </p>
<ul>
<li><strong>优点</strong>：稳定、易用，适合新手和简单项目。  </li>
<li><strong>缺点</strong>：缺乏现代渲染特性，性能调优复杂。  </li>
<li><strong>适用场景</strong>：小型项目、快速原型开发或简单的 2D&#x2F;3D 游戏。</li>
</ul>
</li>
<li><p><strong>通用渲染管线 (URP)</strong>  </p>
<ul>
<li><strong>优点</strong>：支持跨平台优化，性能优良，现代化工具支持（如 Shader Graph）。  </li>
<li><strong>缺点</strong>：功能不如 HDRP 完善，可能需要手动迁移内置资源。  </li>
<li><strong>适用场景</strong>：中小型 2D&#x2F;3D 游戏或移动平台开发。</li>
</ul>
</li>
<li><p><strong>高清渲染管线 (HDRP)</strong>  </p>
<ul>
<li><strong>优点</strong>：画质卓越，支持高级渲染效果（如实时光线追踪）。  </li>
<li><strong>缺点</strong>：硬件需求高，不适合低端设备。  </li>
<li><strong>适用场景</strong>：高质量 3D 游戏、电影制作或建筑可视化等。</li>
</ul>
</li>
</ol>
<p>根据项目的规模、目标平台和渲染需求选择合适的模板，有助于优化开发体验和性能。</p>
]]></content>
  </entry>
  <entry>
    <title>Unity 程序集</title>
    <url>/2025/01/16/Unity-%E7%A8%8B%E5%BA%8F%E9%9B%86/</url>
    <content><![CDATA[<h2 id="常见的四种程序集"><a href="#常见的四种程序集" class="headerlink" title="常见的四种程序集"></a>常见的四种程序集</h2><p>下面是 <strong>Unity 中的预定义程序集</strong>（Predefined Assemblies）、<strong>默认创建的程序集</strong>（Default Assemblies）、<strong>自定义程序集</strong>（Custom Assemblies）和 <strong>预编译程序集</strong>（Precompiled Assemblies）四者的关系与区别的对比表格：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>预定义程序集 (Predefined Assemblies)</th>
<th>默认创建的程序集 (Default Assemblies)</th>
<th>自定义程序集 (Custom Assemblies)</th>
<th>预编译程序集 (Precompiled Assemblies)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>Unity 引擎提供的核心程序集，包含 Unity 引擎功能</td>
<td>Unity 自动创建的程序集，包含项目的用户代码</td>
<td>开发者手动创建和管理的程序集，通常通过 <code>.asmdef</code> 文件创建</td>
<td>编译后的程序集文件，用于加速编译，减少重新编译时间</td>
</tr>
<tr>
<td><strong>主要内容</strong></td>
<td><code>UnityEngine.dll</code>、<code>UnityEditor.dll</code>、<code>mscorlib.dll</code> 等</td>
<td><code>Assembly-CSharp.dll</code>、<code>Assembly-CSharp-Editor.dll</code> 等</td>
<td>开发者编写的代码，按模块划分，如游戏逻辑、编辑器扩展等</td>
<td>已编译的 <code>.dll</code> 文件，可能是游戏逻辑、工具或者其他功能模块的代码</td>
</tr>
<tr>
<td><strong>创建方式</strong></td>
<td>自动创建，由 Unity 提供</td>
<td>自动创建，由 Unity 生成</td>
<td>开发者手动创建，通过 <code>.asmdef</code> 文件配置</td>
<td>由编译工具（例如 Visual Studio）创建，供编译优化使用</td>
</tr>
<tr>
<td><strong>是否由开发者管理</strong></td>
<td>否（由 Unity 自动管理）</td>
<td>否（由 Unity 自动管理）</td>
<td>是（开发者手动管理）</td>
<td>是（开发者在编译时控制）</td>
</tr>
<tr>
<td><strong>是否支持程序集依赖管理</strong></td>
<td>否</td>
<td>否</td>
<td>是（可以设置程序集间的依赖关系）</td>
<td>是（通过编译工具设置，便于引用和依赖管理）</td>
</tr>
<tr>
<td><strong>是否影响编译性能</strong></td>
<td>否</td>
<td>否</td>
<td>是（合理的程序集划分可以提高编译效率）</td>
<td>是（预编译可减少编译时间，提升开发效率）</td>
</tr>
<tr>
<td><strong>是否包含 Unity 引擎功能</strong></td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td><strong>典型例子</strong></td>
<td><code>UnityEngine.dll</code>、<code>UnityEditor.dll</code></td>
<td><code>Assembly-CSharp.dll</code>、<code>Assembly-CSharp-Editor.dll</code></td>
<td>自定义的 <code>Assembly-MyGame.dll</code> 或 <code>Assembly-Utils.dll</code></td>
<td>编译后的 <code>GameLogic.dll</code> 或者 <code>MyUtils.dll</code></td>
</tr>
<tr>
<td><strong>是否能修改</strong></td>
<td>否</td>
<td>否</td>
<td>是（可以通过 <code>.asmdef</code> 修改）</td>
<td>否（预编译后不可修改，需要重新编译源代码）</td>
</tr>
<tr>
<td><strong>引用方式</strong></td>
<td>自动引入，无需手动管理，Unity 会默认引用</td>
<td>自动引入，无需手动管理，Unity 会默认引用</td>
<td>通过 <code>.asmdef</code> 文件引用，可以手动配置引用关系</td>
<td>需要手动引用已编译的 <code>.dll</code> 文件，通常通过项目配置或 <code>Assembly-CSharp.csproj</code> 引用</td>
</tr>
<tr>
<td><strong>引用范围</strong></td>
<td>全局有效，任何脚本都可以直接使用</td>
<td>全局有效，任何脚本都可以直接使用</td>
<td>按 <code>.asmdef</code> 文件设置的依赖关系范围引用</td>
<td>只在编译后生成的程序集文件中引用，引用方式类似于外部 DLL</td>
</tr>
<tr>
<td><strong>如何引用</strong></td>
<td>自动引入，无需手动引用，Unity 引擎自动加载</td>
<td>自动引入，无需手动引用，Unity 自动加载</td>
<td>必须在 <code>.asmdef</code> 文件中显式配置依赖的程序集，或者手动在代码中通过 <code>using</code> 引用</td>
<td>通过 <code>using</code> 引用预编译后的 DLL，通常需要手动将 <code>.dll</code> 文件添加到项目中并配置引用</td>
</tr>
<tr>
<td><strong>修改后需要重新编译</strong></td>
<td>不需要（Unity 会自动包含）</td>
<td>不需要（Unity 会自动包含）</td>
<td>需要重新编译相关程序集，或修改 <code>.asmdef</code> 文件</td>
<td>需要重新编译源代码并生成新的 <code>.dll</code> 文件</td>
</tr>
</tbody></table>
<h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><ol>
<li><p><strong>预定义程序集</strong>：这些程序集由 Unity 提供，包含了 Unity 引擎的核心功能，开发者不需要管理。它们自动被 Unity 项目引用并编译。</p>
</li>
<li><p><strong>默认创建的程序集</strong>：这些是 Unity 自动为你创建的程序集，包含了项目中的基本脚本代码。默认情况下，Unity 会把代码放在 <code>Assembly-CSharp.dll</code> 等文件中，并为编辑器扩展创建 <code>Assembly-CSharp-Editor.dll</code>。</p>
</li>
<li><p><strong>自定义程序集</strong>：开发者通过 <code>.asmdef</code> 文件来划分和管理自己的代码。这些程序集允许开发者按功能模块组织代码，设置依赖关系，从而提高代码的可维护性和编译效率。</p>
</li>
<li><p><strong>预编译程序集</strong>：这是已经编译好的程序集文件，通常是为了加速编译过程而使用的。开发者可以通过编译工具生成预编译的 <code>.dll</code> 文件，它们在项目中作为模块或工具库使用。</p>
</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>预定义程序集</strong> 和 <strong>默认创建的程序集</strong> 是 Unity 自动生成并管理的，开发者无需关心其内部细节。</li>
<li><strong>自定义程序集</strong> 由开发者通过 <code>.asmdef</code> 文件进行划分和管理，可以根据需要配置依赖关系和模块划分。</li>
<li><strong>预编译程序集</strong> 是提前编译好的程序集文件，用于提高编译效率，减少每次修改后的重新编译时间。</li>
</ul>
<p>通过合理管理这些程序集，可以优化项目结构，提升开发效率，尤其是在大型项目中。</p>
<h2 id="自动引用属性"><a href="#自动引用属性" class="headerlink" title="自动引用属性"></a>自动引用属性</h2><p>在 <strong>Unity 自定义程序集</strong>（Custom Assemblies）中，<code>自动引用属性</code>（Automatic Reference）是一个非常重要的功能，它帮助开发者自动引用其他程序集，无需手动配置依赖关系。下面是对这个功能的详细解释：</p>
<h3 id="1-定义与作用"><a href="#1-定义与作用" class="headerlink" title="1. 定义与作用"></a>1. <strong>定义与作用</strong></h3><ul>
<li><strong>自动引用属性（Automatic Reference）</strong> 是在 <code>.asmdef</code> 文件中配置的一项功能。</li>
<li>它的作用是：当你创建自定义程序集（<code>.asmdef</code> 文件）时，Unity 会自动添加与当前程序集相关的其他程序集引用，减少开发者手动添加引用的麻烦。</li>
<li>通过启用这个属性，Unity 会根据程序集的内容和依赖情况，自动处理该程序集的引用。</li>
</ul>
<h3 id="2-为什么需要自动引用？"><a href="#2-为什么需要自动引用？" class="headerlink" title="2. 为什么需要自动引用？"></a>2. <strong>为什么需要自动引用？</strong></h3><p>   在复杂的 Unity 项目中，可能会有多个程序集相互依赖。例如，UI 逻辑、游戏逻辑、编辑器扩展等通常会被拆分到不同的程序集中。在这种情况下，如果每个程序集都需要手动添加引用，管理起来会非常繁琐且容易出错。</p>
<p>   <strong>自动引用属性</strong> 可以根据程序集的依赖自动完成引用配置，减轻开发者的工作量，确保依赖关系正确。</p>
<h3 id="3-自动引用的工作原理"><a href="#3-自动引用的工作原理" class="headerlink" title="3. 自动引用的工作原理"></a>3. <strong>自动引用的工作原理</strong></h3><ul>
<li>当你为某个程序集（例如 <code>Assembly-UI</code>）创建了 <code>.asmdef</code> 文件，并启用了自动引用属性，Unity 会自动检查与该程序集相关的其他程序集，并为你自动添加引用。</li>
<li>比如，当你在 <code>Assembly-UI</code> 中使用了 <code>UnityEngine</code> 或者 <code>UnityEditor</code> 中的 API，Unity 会自动为该程序集添加对这些程序集的引用。</li>
</ul>
<h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. <strong>使用场景</strong></h3><ul>
<li><strong>简化程序集管理</strong>：在大型项目中，当多个程序集之间有复杂的依赖关系时，自动引用可以确保相关依赖得到正确配置，而不必手动去每个 <code>.asmdef</code> 文件中显式添加引用。</li>
<li><strong>减少错误</strong>：如果手动添加引用，可能会出现漏掉某些依赖或引入错误的程序集版本的问题。自动引用可以减少此类错误，确保引用的程序集始终是正确的。</li>
<li><strong>快速迭代</strong>：自动引用可以加速开发过程中，新的自定义程序集被创建或修改时，依赖关系可以自动处理，而不需要每次都手动配置。</li>
</ul>
<h3 id="5-如何启用自动引用属性"><a href="#5-如何启用自动引用属性" class="headerlink" title="5. 如何启用自动引用属性"></a>5. <strong>如何启用自动引用属性</strong></h3><ul>
<li>在 Unity 编辑器中，选择你的 <code>.asmdef</code> 文件，打开 <strong>Inspector</strong> 面板。</li>
<li>在 <strong>Inspector</strong> 面板中，可以找到 <strong>“Automatic References”</strong> 或 <strong>“Auto References”</strong> 属性（具体名称可能会根据版本有所不同）。</li>
<li>启用该选项后，Unity 会自动处理与其他程序集的依赖关系，无需手动添加引用。</li>
</ul>
<h3 id="6-限制与注意事项"><a href="#6-限制与注意事项" class="headerlink" title="6. 限制与注意事项"></a>6. <strong>限制与注意事项</strong></h3><ul>
<li><strong>手动控制优先</strong>：如果某个自定义程序集的引用依赖关系需要精确控制（例如，避免引入某些不必要的程序集），你仍然可以手动添加或移除某些程序集的引用。自动引用只是提供一个默认的行为，手动配置会覆盖默认行为。</li>
<li><strong>递归引用</strong>：自动引用会在当前程序集的依赖树中查找并自动添加引用，但如果存在循环依赖（例如 A 引用 B，B 又引用 A），可能会导致问题。此时仍需要手动处理依赖关系。</li>
</ul>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. <strong>总结</strong></h3><p>   <code>自动引用属性</code> 是一种便捷的方式，使得 Unity 能够自动管理和引用自定义程序集之间的依赖关系，减少开发者手动添加引用的工作。它有助于避免手动配置过程中可能出现的错误，尤其在大型项目中，能够显著提高效率。</p>
<p>   然而，在某些情况下，开发者仍然需要手动配置或精确控制引用的程序集，特别是当涉及到特殊的依赖或避免循环引用时。</p>
<h2 id="No-Engine-References"><a href="#No-Engine-References" class="headerlink" title="No Engine References"></a>No Engine References</h2><p>在 <strong>Unity</strong> 中，**<code>No Engine References</code>** 是指在 <strong>Assembly Definition (.asmdef)</strong> 文件中，可以为特定程序集设置的一个属性。启用这个属性后，Unity 将会禁用该程序集对 Unity 引擎相关程序集（如 <code>UnityEngine.dll</code> 和 <code>UnityEditor.dll</code>）的引用。</p>
<h3 id="1-No-Engine-References-的作用"><a href="#1-No-Engine-References-的作用" class="headerlink" title="1. No Engine References 的作用"></a>1. <strong><code>No Engine References</code> 的作用</strong></h3><p>启用 <strong><code>No Engine References</code></strong> 属性后，Unity 会确保该程序集不会自动引用任何 Unity 引擎相关的程序集。具体来说，这意味着：</p>
<ul>
<li><strong><code>No Engine References</code></strong> 会移除该程序集对 <code>UnityEngine</code>、<code>UnityEditor</code> 等核心 Unity 引擎程序集的引用。</li>
<li>程序集内部不能直接使用 Unity 引擎提供的类和 API，比如 <code>Transform</code>、<code>GameObject</code>、<code>MonoBehaviour</code> 等。</li>
</ul>
<h3 id="2-为什么要使用-No-Engine-References"><a href="#2-为什么要使用-No-Engine-References" class="headerlink" title="2. 为什么要使用 No Engine References"></a>2. <strong>为什么要使用 <code>No Engine References</code></strong></h3><p>这个属性的主要用途是确保某些程序集不会不小心引用 Unity 引擎的 API，通常这种做法会在以下情况下使用：</p>
<h4 id="a-优化依赖关系"><a href="#a-优化依赖关系" class="headerlink" title="a) 优化依赖关系"></a>a) <strong>优化依赖关系</strong></h4><p>如果你的代码不需要依赖 Unity 引擎的核心 API，启用该属性可以避免不必要的依赖。例如，某些逻辑代码仅仅是处理数据、算法或者一些工具类功能，这类代码不应该与 Unity 引擎的功能产生耦合。</p>
<h4 id="b-跨平台需求"><a href="#b-跨平台需求" class="headerlink" title="b) 跨平台需求"></a>b) <strong>跨平台需求</strong></h4><p>某些平台可能不支持 Unity 引擎的全部功能（如 WebGL、iOS、Android 等），启用 <code>No Engine References</code> 可以避免不兼容的引用。例如，Unity 引擎的某些功能可能在 WebGL 上不可用，而启用该属性可以确保代码不会无意中引用这些不支持的功能。</p>
<h4 id="c-自定义功能模块"><a href="#c-自定义功能模块" class="headerlink" title="c) 自定义功能模块"></a>c) <strong>自定义功能模块</strong></h4><p>如果你想编写一个完全独立的、仅依赖于 .NET 标准库的程序集（例如一些数据处理、网络通信或业务逻辑），则 <code>No Engine References</code> 是一种很好的方式来确保你的程序集与 Unity 引擎的代码完全分离。这样，你的代码只依赖于标准的 C# 库，而不依赖于 Unity 引擎的特殊功能。</p>
<h4 id="d-避免代码依赖问题"><a href="#d-避免代码依赖问题" class="headerlink" title="d) 避免代码依赖问题"></a>d) <strong>避免代码依赖问题</strong></h4><p>在大型项目中，有时开发者希望避免无意中在某些工具或库中引用 Unity 引擎的 API。启用 <code>No Engine References</code> 可以作为一种防止开发人员在不应该引用引擎代码时发生错误的手段。</p>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. <strong>使用场景</strong></h3><p>你可能会在以下情况下使用 <strong><code>No Engine References</code></strong> 属性：</p>
<ul>
<li><p><strong>业务逻辑层</strong>：如果你希望将业务逻辑（例如玩家的分数计算、排行榜、数据处理等）与 Unity 引擎解耦，那么你可以创建一个没有 Unity 引擎引用的程序集，只处理业务逻辑。</p>
</li>
<li><p><strong>跨平台工具类</strong>：你有一些与平台无关的工具类，例如日志管理、网络请求、序列化工具等，这些工具类不应该依赖 Unity 引擎的任何功能。</p>
</li>
<li><p><strong>独立测试代码</strong>：如果你写了单元测试或独立模块，且这些测试&#x2F;模块不需要依赖 Unity 引擎，你可以通过启用这个属性来确保它们不依赖 Unity 引擎。</p>
</li>
</ul>
<h3 id="4-与默认程序集的区别"><a href="#4-与默认程序集的区别" class="headerlink" title="4. 与默认程序集的区别"></a>4. <strong>与默认程序集的区别</strong></h3><p>默认情况下，Unity 会为每个程序集自动添加 <code>UnityEngine</code> 和 <code>UnityEditor</code> 等引擎程序集的引用。如果启用了 **<code>No Engine References</code>**，这些引用将被禁用，意味着你不能在该程序集内直接使用 Unity 引擎的 API。</p>
<h3 id="5-如何使用-No-Engine-References"><a href="#5-如何使用-No-Engine-References" class="headerlink" title="5. 如何使用 No Engine References"></a>5. <strong>如何使用 <code>No Engine References</code></strong></h3><p>在 Unity 中，你可以通过以下步骤为一个程序集启用 <strong><code>No Engine References</code></strong> 属性：</p>
<ol>
<li>在 <strong>Project</strong> 视图中，找到你希望设置的 <strong><code>.asmdef</code> 文件</strong>。</li>
<li>选中该 <strong><code>.asmdef</code> 文件</strong>，然后在 <strong>Inspector</strong> 面板中查看该程序集的设置。</li>
<li>启用 <strong><code>No Engine References</code></strong> 选项。</li>
</ol>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h3><p><strong><code>No Engine References</code></strong> 属性在 Unity 中的主要作用是确保某个程序集不引用 Unity 引擎相关的程序集。它适用于需要与引擎代码解耦的场景，如独立的工具类、跨平台代码或业务逻辑模块。</p>
<p>通过启用这个属性，可以避免不必要的依赖，优化程序集的结构和性能，确保代码的独立性和跨平台性。</p>
<h2 id="Override-References"><a href="#Override-References" class="headerlink" title="Override References"></a>Override References</h2><p>启用 <code>Override References</code> 设置可手动指定此程序集所依赖的预编译程序集。启用 <code>Override References</code> 后，检查器将显示“程序集引用”部分，您可以使用该部分指定引用。</p>
<p>预编译程序集是在 Unity 项目之外编译的库。默认情况下，您在项目中定义的程序集会引用您添加到项目的所有预编译程序集，这与预定义程序集引用所有预编译程序集的方式相匹配。启用 <code>Override References</code> 后，此程序集仅引用您在“程序集引用”下添加的预编译程序集。</p>
<p>注意：为防止项目程序集自动引用预编译程序集，您可以禁用其“自动引用”选项。有关更多信息，请参阅插件检查器。</p>
<h3 id="Assembly-References"><a href="#Assembly-References" class="headerlink" title="Assembly References"></a>Assembly References</h3><p>仅当您启用 <code>Override References</code> 属性（在“常规”部分中）时，才会显示“程序集引用”部分。使用此区域指定此程序集所依赖的预编译程序集的任何引用。</p>
<h2 id="Assembly-Definition-References"><a href="#Assembly-Definition-References" class="headerlink" title="Assembly Definition References"></a>Assembly Definition References</h2><p>程序集定义引用	使用程序集定义资源指定对您创建的其他程序集的引用。Unity 使用这些引用来编译程序集并定义程序集之间的依赖关系。</p>
]]></content>
  </entry>
  <entry>
    <title>butterfly 禁用头像旋转</title>
    <url>/2024/12/16/butterfly-%E7%A6%81%E7%94%A8%E5%A4%B4%E5%83%8F%E6%97%8B%E8%BD%AC/</url>
    <content><![CDATA[<p>当鼠标移到侧边栏头像上时，头像会播放旋转动效，要想禁用可以找到<br>themes\butterfly\source\css_layout\aside.styl文件并按照如下对transform: unset修改即可完成动效屏蔽。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.avatar-img</span></span><br><span class="line">  <span class="attribute">overflow</span>: hidden</span><br><span class="line">  margin: <span class="number">0</span> auto</span><br><span class="line">  width: <span class="number">110px</span></span><br><span class="line">  height: <span class="number">110px</span></span><br><span class="line">  border-radius: <span class="number">70px</span></span><br><span class="line"></span><br><span class="line">  img</span><br><span class="line">    width: <span class="number">100%</span></span><br><span class="line">    height: <span class="number">100%</span></span><br><span class="line">    transition: filter <span class="number">375ms</span> ease-in .<span class="number">2s</span>, transform .<span class="number">3s</span></span><br><span class="line">    object-fit: cover</span><br><span class="line"></span><br><span class="line">    &amp;:hover</span><br><span class="line">      transform: unset</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>butterfly</category>
      </categories>
      <tags>
        <tag>butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>git submodule</title>
    <url>/2025/02/06/git-submodule/</url>
    <content><![CDATA[<p>是的，<strong>Git Submodule</strong> 是一个 <strong>独立的 Git 仓库</strong>，因此它确实有自己的版本管理和开发分支。子模块和主项目是相互独立的 Git 仓库，每个子模块可以拥有自己的分支、版本历史以及 Git 配置。</p>
<h3 id="Git-Submodule-的版本管理和开发分支"><a href="#Git-Submodule-的版本管理和开发分支" class="headerlink" title="Git Submodule 的版本管理和开发分支"></a><strong>Git Submodule 的版本管理和开发分支</strong></h3><ol>
<li><p><strong>独立版本管理：</strong></p>
<ul>
<li>每个子模块（例如 Game Framework 插件）有自己的 Git 仓库，使用自己独立的版本号和提交记录。</li>
<li>当你将子模块添加到主项目时，Git 会记录子模块的<strong>当前提交版本</strong>，并将该信息存储在主项目的 <code>.gitmodules</code> 文件和 <code>.git/config</code> 配置文件中。</li>
<li>例如，当你添加一个子模块时，Git 会记录子模块在主项目中的具体版本（即该子模块的某个提交ID）。</li>
</ul>
</li>
<li><p><strong>子模块的分支管理：</strong></p>
<ul>
<li>每个子模块都有自己的分支管理方式，你可以在子模块内创建、切换和管理分支，就像处理主项目中的分支一样。</li>
<li>当你执行 <code>git submodule update --remote</code> 命令时，Git 会将子模块的代码更新为子模块远程仓库的默认分支（通常是 <code>master</code> 或 <code>main</code>，但你也可以设置其他分支）。</li>
</ul>
</li>
<li><p><strong>管理子模块的版本：</strong></p>
<ul>
<li>子模块的版本控制非常灵活，可以选择将子模块固定在某个版本（提交哈希）或某个分支的最新提交。</li>
<li>在主项目中，如果你想更新子模块到最新版本，只需进入子模块目录并执行：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt;  <span class="comment"># 切换到需要的分支</span></span><br><span class="line">git pull origin &lt;branch-name&gt;  <span class="comment"># 拉取最新代码</span></span><br></pre></td></tr></table></figure></li>
<li>然后在主项目目录中，使用以下命令提交子模块的新版本：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add &lt;submodule-directory&gt;</span><br><span class="line">git commit -m <span class="string">&quot;Update submodule to latest version&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>子模块的分支切换：</strong></p>
<ul>
<li>如果你想切换子模块的分支，可以进入子模块目录，使用 <code>git checkout &lt;branch&gt;</code> 来切换分支：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Packages/GameFramework  <span class="comment"># 进入子模块目录</span></span><br><span class="line">git checkout develop  <span class="comment"># 切换到开发分支</span></span><br><span class="line">git pull origin develop  <span class="comment"># 更新子模块到开发分支的最新代码</span></span><br></pre></td></tr></table></figure></li>
<li>切换完成后，记得回到主项目目录并提交子模块的更新：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../..</span><br><span class="line">git add Packages/GameFramework</span><br><span class="line">git commit -m <span class="string">&quot;Switch submodule to develop branch&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="如何管理子模块的版本"><a href="#如何管理子模块的版本" class="headerlink" title="如何管理子模块的版本"></a><strong>如何管理子模块的版本</strong></h3><ul>
<li><p><strong>固定子模块版本：</strong><br>如果你希望将子模块固定在特定版本（例如某个提交哈希），可以通过以下命令将子模块指向特定的提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
<p>这将确保子模块锁定在特定的提交哈希，而不是拉取该分支的最新版本。</p>
</li>
<li><p><strong>更新子模块到最新提交：</strong><br>如果你想将子模块更新为其远程仓库的最新提交（通常是远程 <code>master</code> 或 <code>main</code> 分支），可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>子模块版本管理文件：</strong><br>子模块的提交信息被保存在主项目的 <code>.gitmodules</code> 和 <code>.git/config</code> 文件中。你可以手动编辑这些文件来指定子模块的 URL 和分支信息，也可以使用 Git 命令行工具来管理。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>独立版本和分支管理</strong>：每个子模块有自己的版本历史和分支，你可以独立管理子模块的版本和分支，不会影响主项目。</li>
<li><strong>灵活的更新和切换</strong>：你可以选择将子模块固定在某个版本，或者随时更新到远程仓库的最新提交。</li>
<li><strong>主项目和子模块的分离</strong>：主项目和子模块是相互独立的 Git 仓库，便于独立管理和协作开发。</li>
</ul>
<p>如果你需要更具体的操作示例或遇到任何问题，随时告诉我！我会帮助你更好地管理子模块。</p>
<h2 id="🔹-为什么使用-Git-Submodule-导入-Game-Framework-插件？"><a href="#🔹-为什么使用-Git-Submodule-导入-Game-Framework-插件？" class="headerlink" title="🔹 为什么使用 Git Submodule 导入 Game Framework 插件？"></a><strong>🔹 为什么使用 Git Submodule 导入 Game Framework 插件？</strong></h2><p>使用 <strong>Git Submodule</strong> 方式导入 <strong>Game Framework 插件</strong> 也是一个非常不错的选择，尤其是在团队协作或者需要频繁更新插件代码的情况下。它的优势和适用场景如下：</p>
<h3 id="✅-优势："><a href="#✅-优势：" class="headerlink" title="✅ 优势："></a><strong>✅ 优势：</strong></h3><ol>
<li><p><strong>版本控制和更新管理：</strong></p>
<ul>
<li>Git Submodule 允许你将 <strong>Game Framework 插件的 Git 仓库</strong> 作为子模块引入主项目，这样你就可以单独管理插件的版本。</li>
<li>如果插件有更新，只需在主项目中执行 <code>git submodule update --remote</code> 来拉取插件的最新版本。</li>
</ul>
</li>
<li><p><strong>保持项目结构清晰：</strong></p>
<ul>
<li>插件代码会作为子模块独立存在于特定文件夹（如 <code>Packages/GameFramework</code>），不会和主项目代码混在一起，保持项目结构的整洁。</li>
</ul>
</li>
<li><p><strong>便于团队协作：</strong></p>
<ul>
<li>你可以将子模块添加到 Git 仓库中，团队成员可以同步子模块版本，确保大家使用相同版本的插件。</li>
<li>团队成员可以通过 <code>git submodule update --init</code> 拉取最新插件，避免了手动导入和更新插件的麻烦。</li>
</ul>
</li>
<li><p><strong>灵活的自定义：</strong></p>
<ul>
<li>如果你需要修改框架的代码，直接进入子模块目录，进行修改，不会影响主项目的其他部分。</li>
<li>你可以将 Game Framework 插件单独进行版本管理，并与主项目的版本控制隔离开。</li>
</ul>
</li>
<li><p><strong>保持一致性：</strong></p>
<ul>
<li>使用 Git Submodule 确保每次从版本库拉取时，插件和主项目的版本一致，避免了手动复制和拖动导致的版本错乱。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="❌-可能的缺点："><a href="#❌-可能的缺点：" class="headerlink" title="❌ 可能的缺点："></a><strong>❌ 可能的缺点：</strong></h3><ol>
<li><p><strong>稍微复杂的操作：</strong></p>
<ul>
<li>子模块需要一些额外的 Git 命令支持，比如初始化子模块、更新子模块等。</li>
<li>如果团队成员不熟悉 Git Submodule，可能需要一些培训。</li>
</ul>
</li>
<li><p><strong>子模块更新需要显式操作：</strong></p>
<ul>
<li>在子模块更新时，开发者需要显式执行 <code>git submodule update</code> 命令来拉取插件的最新代码，而不像 UPM 那样自动处理版本更新。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="🔹-如何使用-Git-Submodule-导入-Game-Framework-插件？"><a href="#🔹-如何使用-Git-Submodule-导入-Game-Framework-插件？" class="headerlink" title="🔹 如何使用 Git Submodule 导入 Game Framework 插件？"></a><strong>🔹 如何使用 Git Submodule 导入 Game Framework 插件？</strong></h2><h3 id="步骤-1：初始化子模块"><a href="#步骤-1：初始化子模块" class="headerlink" title="步骤 1：初始化子模块"></a><strong>步骤 1：初始化子模块</strong></h3><p>首先，假设你已经有一个主项目，接下来将 Game Framework 插件作为子模块添加到你的项目中。</p>
<ol>
<li><p><strong>进入主项目目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/your/unity/project</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>添加 Game Framework 插件作为子模块：</strong><br>假设你要使用的 Game Framework 插件在 GitHub 上，你可以使用以下命令将插件仓库添加为子模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/YourUsername/UnityGameFramework.git Packages/GameFramework</span><br></pre></td></tr></table></figure>

<p>这个命令会将 Game Framework 插件添加到 <code>Packages/GameFramework</code> 目录，并将其作为 Git 子模块加入到主项目中。</p>
</li>
<li><p><strong>初始化子模块：</strong><br>如果你是第一次使用子模块，需要执行以下命令初始化它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提交主项目的变化：</strong><br>完成子模块添加后，你需要将 <code>git submodule</code> 的变动提交到主项目中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Add UnityGameFramework as a submodule&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="步骤-2：更新子模块"><a href="#步骤-2：更新子模块" class="headerlink" title="步骤 2：更新子模块"></a><strong>步骤 2：更新子模块</strong></h3><p>当插件更新时，你可以通过以下步骤更新子模块：</p>
<ol>
<li><p><strong>更新子模块到最新版本：</strong><br>如果 Game Framework 插件有更新，可以执行以下命令拉取最新代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提交更新后的子模块：</strong><br>更新完成后，你需要提交主项目对子模块的更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Update UnityGameFramework submodule to latest version&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>推送更新：</strong><br>更新完成后，推送到远程 Git 仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="步骤-3：团队协作中使用子模块"><a href="#步骤-3：团队协作中使用子模块" class="headerlink" title="步骤 3：团队协作中使用子模块"></a><strong>步骤 3：团队协作中使用子模块</strong></h3><ol>
<li><p><strong>克隆主项目时包含子模块：</strong><br>当团队成员从 Git 仓库克隆主项目时，需要添加 <code>--recurse-submodules</code> 参数来同步子模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recurse-submodules https://github.com/YourUsername/YourUnityProject.git</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>更新子模块：</strong><br>如果已经克隆过主项目，可以使用以下命令更新子模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="🔹-适用场景"><a href="#🔹-适用场景" class="headerlink" title="🔹 适用场景"></a><strong>🔹 适用场景</strong></h2><ul>
<li><strong>长期维护的项目</strong>：如果你使用的 <strong>Game Framework 插件是外部维护的</strong>，Git Submodule 是一个好选择，因为你可以方便地控制插件的版本，避免插件代码直接嵌入到主项目中导致的混乱。</li>
<li><strong>需要修改框架代码</strong>：如果你需要在项目中修改 <strong>Game Framework 插件的代码</strong>，Git Submodule 使得代码独立且可控，避免了直接修改 <code>Assets/</code> 目录中的框架代码。</li>
<li><strong>多人协作开发</strong>：在团队开发中，子模块保证了每个开发者都在使用相同版本的框架，避免了版本不一致导致的错误。</li>
</ul>
<hr>
<h2 id="🔹-总结"><a href="#🔹-总结" class="headerlink" title="🔹 总结"></a><strong>🔹 总结</strong></h2><p>使用 <strong>Git Submodule</strong> 导入 <strong>Game Framework 插件</strong> 是一个非常适合 <strong>团队开发</strong> 和 <strong>长期维护项目</strong> 的解决方案。它能保证代码的清晰结构和良好的版本控制，同时为开发者提供灵活性，可以在不干扰主项目的情况下修改框架代码。如果你打算进行 <strong>框架定制</strong> 或者希望框架代码 <strong>与主项目解耦</strong>，Git Submodule 是一个非常值得推荐的方案。</p>
<p>如果你遇到 Git Submodule 使用中的问题，随时告诉我，我帮你进一步解决！</p>
]]></content>
  </entry>
  <entry>
    <title>github 作为热更新服</title>
    <url>/2025/01/22/github-%E4%BD%9C%E4%B8%BA%E7%83%AD%E6%9B%B4%E6%96%B0%E6%9C%8D/</url>
    <content><![CDATA[<p>要使用 <strong>GitHub</strong> 作为 Unity 项目的热更新资源服务器，你可以通过 GitHub 的 <strong>Releases</strong> 功能来托管和管理资源（如 AssetBundles）。这样，你可以通过 Unity 在运行时动态下载这些资源，而无需每次更新游戏客户端。下面是如何使用 GitHub 来托管 Unity 热更新资源的详细步骤：</p>
<h3 id="1-准备资源（例如-AssetBundles）"><a href="#1-准备资源（例如-AssetBundles）" class="headerlink" title="1. 准备资源（例如 AssetBundles）"></a>1. <strong>准备资源（例如 AssetBundles）</strong></h3><p>首先，你需要将 Unity 项目的资源打包成 <strong>AssetBundles</strong>。这是 Unity 热更新的常见方式。通过 AssetBundles，你可以在游戏运行时动态加载资源，而不需要重新发布整个游戏。</p>
<h4 id="创建-AssetBundles："><a href="#创建-AssetBundles：" class="headerlink" title="创建 AssetBundles："></a>创建 AssetBundles：</h4><ol>
<li><p>在 Unity 中创建 AssetBundle：</p>
<ul>
<li>选择你想要打包的资源（例如场景、模型、纹理等）。</li>
<li>在 Inspector 面板中，给它们指定一个 <strong>AssetBundle 名称</strong>。例如，将所有角色模型的 AssetBundle 命名为 <code>character_assets</code>。</li>
</ul>
</li>
<li><p>打包 AssetBundles：</p>
<ul>
<li>通过 <code>BuildPipeline.BuildAssetBundles</code> 方法将这些资源导出为 AssetBundles 文件。</li>
</ul>
</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssetBundleBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="string">&quot;Assets/Build AssetBundles&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildAllAssetBundles</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        BuildPipeline.BuildAssetBundles(<span class="string">&quot;Assets/AssetBundles&quot;</span>, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行该方法后，你的 AssetBundles 将被打包并存储到 <code>Assets/AssetBundles</code> 目录中。</p>
<h3 id="2-将-AssetBundles-上传到-GitHub"><a href="#2-将-AssetBundles-上传到-GitHub" class="headerlink" title="2. 将 AssetBundles 上传到 GitHub"></a>2. <strong>将 AssetBundles 上传到 GitHub</strong></h3><p>将打包好的 AssetBundles 上传到 GitHub 的 <strong>Release 页面</strong>，使它们成为可公开访问的资源。</p>
<h4 id="创建-GitHub-仓库并上传资源："><a href="#创建-GitHub-仓库并上传资源：" class="headerlink" title="创建 GitHub 仓库并上传资源："></a>创建 GitHub 仓库并上传资源：</h4><ol>
<li><p>在 GitHub 上创建一个新仓库（如果还没有的话）。</p>
</li>
<li><p>将打包好的 AssetBundles 文件（例如 <code>.ab</code> 文件）上传到 GitHub 仓库的 <strong>Releases</strong> 页面。你可以创建一个新的版本（tag）并上传相关的资源文件。</p>
<ul>
<li>进入你的 GitHub 仓库页面，点击 <strong>Releases</strong> 标签。</li>
<li>创建一个新版本，并上传你打包的 AssetBundles 文件。每个版本的资源将对应一个特定的版本号，便于管理更新。</li>
</ul>
</li>
<li><p>你会得到一个资源下载的 URL，类似于：</p>
<ul>
<li><code>https://github.com/your-username/your-repo/releases/download/v1.0/character_assets.ab</code></li>
</ul>
</li>
</ol>
<h3 id="3-在-Unity-中动态下载资源"><a href="#3-在-Unity-中动态下载资源" class="headerlink" title="3. 在 Unity 中动态下载资源"></a>3. <strong>在 Unity 中动态下载资源</strong></h3><p>在游戏运行时，你可以通过 HTTP 请求从 GitHub 下载 AssetBundles 并加载它们。你需要使用 Unity 的 <strong>UnityWebRequest</strong> 来进行下载，并使用 AssetBundle API 来加载和使用资源。</p>
<h4 id="示例代码：从-GitHub-下载-AssetBundle-并加载"><a href="#示例代码：从-GitHub-下载-AssetBundle-并加载" class="headerlink" title="示例代码：从 GitHub 下载 AssetBundle 并加载"></a>示例代码：从 GitHub 下载 AssetBundle 并加载</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Networking;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssetBundleManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> assetBundleURL = <span class="string">&quot;https://github.com/your-username/your-repo/releases/download/v1.0/character_assets.ab&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> AssetBundle loadedAssetBundle;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 下载 AssetBundle</span></span><br><span class="line">        UnityWebRequest request = UnityWebRequest.Get(assetBundleURL);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> request.SendWebRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.result == UnityWebRequest.Result.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 下载成功，加载 AssetBundle</span></span><br><span class="line">            loadedAssetBundle = AssetBundle.LoadFromMemory(request.downloadHandler.data);</span><br><span class="line">            <span class="keyword">if</span> (loadedAssetBundle != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;AssetBundle loaded successfully.&quot;</span>);</span><br><span class="line">                <span class="comment">// 从 AssetBundle 中加载资源</span></span><br><span class="line">                <span class="keyword">var</span> asset = loadedAssetBundle.LoadAsset(<span class="string">&quot;CharacterPrefab&quot;</span>);</span><br><span class="line">                Instantiate(asset);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(<span class="string">&quot;Failed to load AssetBundle.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;Failed to download AssetBundle: &quot;</span> + request.error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-版本控制与更新"><a href="#4-版本控制与更新" class="headerlink" title="4. 版本控制与更新"></a>4. <strong>版本控制与更新</strong></h3><p>为了支持热更新，你需要管理不同版本的 AssetBundles。每次有新的资源更新时，按照以下步骤操作：</p>
<ol>
<li><strong>更新资源</strong>：每次修改或添加资源时，重新打包 AssetBundles，并在 GitHub 上创建新的 Release。</li>
<li><strong>版本管理</strong>：确保每次更新都更新版本号，方便你的游戏检测和下载新的版本。</li>
<li><strong>检查更新</strong>：在游戏启动时，可以通过比较本地和远程版本，来决定是否需要下载最新的资源。例如，你可以将版本号存储在远程的一个 JSON 文件中，游戏启动时检查并决定是否下载新的 AssetBundle。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Networking;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VersionManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> versionURL = <span class="string">&quot;https://github.com/your-username/your-repo/releases/latest/download/version.json&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 下载版本信息</span></span><br><span class="line">        UnityWebRequest versionRequest = UnityWebRequest.Get(versionURL);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> versionRequest.SendWebRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (versionRequest.result == UnityWebRequest.Result.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> json = versionRequest.downloadHandler.text;</span><br><span class="line">            VersionData versionData = JsonUtility.FromJson&lt;VersionData&gt;(json);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查本地版本和远程版本</span></span><br><span class="line">            <span class="keyword">if</span> (versionData.version &gt; PlayerPrefs.GetInt(<span class="string">&quot;Version&quot;</span>, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;New version available, updating...&quot;</span>);</span><br><span class="line">                <span class="comment">// 下载新的 AssetBundle</span></span><br><span class="line">                StartCoroutine(DownloadAssetBundle(versionData.assetBundleURL));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;Failed to download version info.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">DownloadAssetBundle</span>(<span class="params"><span class="built_in">string</span> assetBundleURL</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        UnityWebRequest request = UnityWebRequest.Get(assetBundleURL);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> request.SendWebRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.result == UnityWebRequest.Result.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            AssetBundle loadedAssetBundle = AssetBundle.LoadFromMemory(request.downloadHandler.data);</span><br><span class="line">            <span class="keyword">if</span> (loadedAssetBundle != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;AssetBundle updated.&quot;</span>);</span><br><span class="line">                PlayerPrefs.SetInt(<span class="string">&quot;Version&quot;</span>, versionData.version); <span class="comment">// 保存新版本号</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(<span class="string">&quot;Failed to load AssetBundle.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">System.Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VersionData</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> version;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> assetBundleURL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-优点与挑战"><a href="#5-优点与挑战" class="headerlink" title="5. 优点与挑战"></a>5. <strong>优点与挑战</strong></h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>简单易用</strong>：GitHub 为你提供了免费的文件托管服务，你只需要通过 GitHub Releases 上传 AssetBundles 即可。</li>
<li><strong>版本控制</strong>：通过 GitHub 的 Release 标签，你可以很方便地管理和发布不同版本的资源。</li>
<li><strong>公开访问</strong>：GitHub 的资源链接是公开的，玩家可以在游戏运行时直接从这些 URL 下载最新的资源。</li>
</ul>
<h4 id="挑战："><a href="#挑战：" class="headerlink" title="挑战："></a>挑战：</h4><ul>
<li><strong>访问速度与带宽限制</strong>：GitHub 的带宽和下载速度可能会受到限制，尤其是当下载量增多时，可能会影响资源的加载速度。</li>
<li><strong>资源存储限制</strong>：虽然 GitHub 免费账户有一定的存储空间限制，但对于小型项目和低频更新，GitHub 是一个可行的选择。大规模项目可能需要其他更高效的 CDN 服务。</li>
<li><strong>安全性</strong>：公开的资源如果不进行加密或版本管理，可能会被非授权的用户获取和篡改。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>使用 <strong>GitHub</strong> 作为热更新资源服务器对于小型游戏或独立开发者来说是一个实用且免费的选择。你只需上传 AssetBundles 到 GitHub 的 Releases 页面，并通过 Unity 的 <code>UnityWebRequest</code> 下载并加载资源。不过，需要注意带宽、存储限制以及合理管理版本更新，确保游戏能够正确地下载并加载最新资源。</p>
]]></content>
  </entry>
  <entry>
    <title>git修改历史提交</title>
    <url>/2024/12/09/git%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4/</url>
    <content><![CDATA[<h1 id="git-reset命令"><a href="#git-reset命令" class="headerlink" title="git reset命令"></a>git reset命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --soft 29f9bbd77da69902335cad77a12eac7b022b9f63</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-1.png"><br><code>git reset --soft</code> 命令是 Git 中的一个强大工具，它可以用于回退到某个特定的提交，同时保留文件的修改内容。这里是对该命令的详细解释：</p>
<h2 id="命令结构"><a href="#命令结构" class="headerlink" title="命令结构"></a>命令结构</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --soft &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>git reset</code> 是 Git 的一个基本命令，用于将当前的分支回退到指定的提交，并调整索引和工作目录中的内容。</li>
<li><code>--soft</code> 是 <code>git reset</code> 的一个选项，决定了在回退时如何处理文件的状态。<code>--soft</code> 会将 <code>HEAD</code> 移动到指定的 commit，但 <strong>不会修改工作目录</strong>  和 <strong>索引</strong> （也就是暂存区），因此你仍然可以看到文件的修改。</li>
</ul>
<p><strong>各部分的解释：</strong></p>
<ol>
<li><strong><code>&lt;commit-hash&gt;</code></strong> ：</li>
</ol>
<ul>
<li><code>&lt;commit-hash&gt;</code> 是你想回退到的 commit 的哈希值。可以是一个完整的哈希（如 <code>29f9bbd77da69902335cad77a12eac7b022b9f63</code>）或者它的前几位字符（例如，<code>29f9bbd</code>）。<code>git log</code> 可以帮助你查找这个哈希值。</li>
</ul>
<ol start="2">
<li><strong><code>--soft</code> 选项</strong> ：</li>
</ol>
<ul>
<li><code>--soft</code> 选项使得 Git <strong>只移动 HEAD</strong> ，即将当前分支指针（HEAD）回退到指定的 commit，但 <strong>保留工作目录和暂存区的内容不变</strong> 。换句话说，你的文件更改不会丢失，修改内容仍然会保留在暂存区。</li>
<li>如果你有一些修改没有提交，<code>git reset --soft</code> 会将这些修改<strong>保留</strong> ，并将它们放回暂存区，让你可以再次提交。</li>
</ul>
<p><strong>具体的效果：</strong></p>
<ol>
<li><strong><code>HEAD</code> 会回退</strong> ：这会将当前分支的 HEAD 指针（即当前正在工作的提交）指向指定的 commit。</li>
<li><strong>工作目录不变</strong> ：你的工作目录中的文件不会被修改，意味着所有修改都会被保留，你的文件内容依然存在。</li>
<li><strong>暂存区不变</strong> ：所有已暂存的文件也会被保留，意味着如果你之前用 <code>git add</code> 添加了修改，那么这些修改依然会保留在暂存区。</li>
</ol>
<p><strong>举个例子：</strong></p>
<p>假设你有如下提交历史：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span> a1b2c3d <span class="operator">-</span> 最新的提交</span><br><span class="line"><span class="keyword">commit</span> <span class="number">29</span>f9bbd <span class="operator">-</span> 需要回退到的提交</span><br><span class="line"><span class="keyword">commit</span> d4e5f6g <span class="operator">-</span> 更早的提交</span><br></pre></td></tr></table></figure>

<ul>
<li>如果你执行 <code>git reset --soft 29f9bbd77da69902335cad77a12eac7b022b9f63</code>，这会发生以下变化：<ul>
<li><strong><code>HEAD</code></strong>  会指向 <code>29f9bbd</code> 提交，即回到你指定的提交。</li>
<li><strong>工作目录</strong>  保持不变，你的文件内容依然会保留。</li>
<li><strong>暂存区</strong>  也保持不变，你之前 <code>git add</code> 的修改仍然会保留。</li>
</ul>
</li>
</ul>
<p>这样，你就可以修改代码并重新提交，而不丢失之前的修改。</p>
<p><strong>常见的用法：</strong></p>
<ul>
<li><strong>撤销最近的提交并保留修改</strong> ：假设你做了一个提交，但发现需要修改其中的内容，你可以使用 <code>git reset --soft HEAD^</code>（<code>HEAD^</code> 是指上一个提交）。这会撤销最近的提交，并保留你工作目录和暂存区的内容，允许你重新修改并提交。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><code>git reset --soft &lt;commit-hash&gt;</code> 会将 <code>HEAD</code> 回退到指定的 commit，但 <strong>保留文件内容和暂存区的修改</strong> 。这适用于想要撤销某个提交，但又不希望丢失工作进度的情况。</li>
<li>使用此命令时，你可以修改或更新暂存区的文件，再次进行提交。</li>
</ul>
<h2 id="reset-三种模式"><a href="#reset-三种模式" class="headerlink" title="reset 三种模式"></a><code>reset</code> <a href="https://x.zhixing.co/devops/the-differences-and-usages-of-3-modes-git-reset/">三种模式</a></h2><p>分别是 <code>--soft</code>、<code>--mixed</code> 和 <code>--hard</code>，它们的作用和影响不同。下面是对每种模式的详细讲解：<br><img src="/.io//image.png"></p>
<ol>
<li><strong><code>git reset --soft &lt;commit&gt;</code></strong></li>
</ol>
<ul>
<li><strong>作用</strong> ：将 <code>HEAD</code> 指针回退到指定的 commit，但 <strong>不更改工作目录和暂存区</strong> 。</li>
<li><strong>效果</strong> ：<ul>
<li><code>HEAD</code> 回退到指定的提交，即当前分支指针会指向指定的提交。</li>
<li><strong>工作目录（Working Directory）</strong>  不变，文件的内容保留不变。</li>
<li><strong>暂存区（Staging Area）</strong>  保持不变，之前已经暂存的文件仍然存在于暂存区。</li>
</ul>
</li>
<li><strong>使用场景</strong> ：<ul>
<li>用于撤销最后一次提交并修改其中的内容，但保留文件更改和暂存区内容。适合你想重新提交修改内容时使用。</li>
</ul>
</li>
<li><strong>示例</strong> ：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure>

<p>这个命令将 HEAD 回退到上一个提交（<code>HEAD~1</code>），但是保留当前工作目录和暂存区中的修改。你可以编辑文件、重新暂存并提交。</p>
<ol start="2">
<li><strong><code>git reset --mixed &lt;commit&gt;</code></strong>  （默认选项）</li>
</ol>
<ul>
<li><strong>作用</strong> ：将 <code>HEAD</code> 回退到指定的 commit，并且 <strong>更新暂存区</strong> （即撤销暂存），但 <strong>不更改工作目录</strong> 。</li>
<li><strong>效果</strong> ：<ul>
<li><code>HEAD</code> 回退到指定的提交。</li>
<li><strong>工作目录</strong>  不变，文件内容保留不变。</li>
<li><strong>暂存区（Staging Area）</strong>  被更新为与指定 commit 的内容一致。也就是说，撤销所有已经 <code>git add</code> 的文件，将它们从暂存区中移除，但文件内容仍然保持在工作目录中。</li>
</ul>
</li>
<li><strong>使用场景</strong> ：<ul>
<li>用于撤销提交并取消暂存文件，但你仍然想保留文件修改。适用于需要修改代码但不想保留当前暂存区修改的场景。</li>
</ul>
</li>
<li><strong>示例</strong> ：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --mixed HEAD~1</span><br></pre></td></tr></table></figure>

<p>这个命令将 HEAD 回退到上一个提交，并且从暂存区移除修改，但文件内容仍然保留。相当于撤销最近的 <code>git add</code> 操作。</p>
<ol start="3">
<li><strong><code>git reset --hard &lt;commit&gt;</code></strong></li>
</ol>
<ul>
<li><strong>作用</strong> ：将 <code>HEAD</code>、<strong>暂存区</strong>  和 <strong>工作目录</strong>  都回退到指定的 commit。</li>
<li><strong>效果</strong> ：<ul>
<li><code>HEAD</code> 回退到指定的提交。</li>
<li><strong>工作目录</strong>  会被重置为指定 commit 的内容，所有未提交的修改（无论是暂存区的还是工作目录的）都会被丢弃。</li>
<li><strong>暂存区</strong>  也会被重置，撤销所有已暂存的文件。</li>
</ul>
</li>
<li><strong>使用场景</strong> ：<ul>
<li>用于彻底放弃当前的修改，回到某个提交状态。适用于你想完全撤销修改并且不保留任何更改时使用。</li>
</ul>
</li>
<li><strong>示例</strong> ：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD~1</span><br></pre></td></tr></table></figure>

<p>这个命令会将 HEAD 回退到上一个提交，并且<strong>彻底丢弃</strong> 工作目录和暂存区中的所有修改。<strong>注意</strong> ：此操作无法恢复，慎重使用！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table>
<thead>
<tr>
<th>选项</th>
<th>HEAD</th>
<th>工作目录</th>
<th>暂存区</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>soft</td>
<td>回退到指定 commit</td>
<td>保持不变</td>
<td>保持不变</td>
<td>用于撤销提交并重新提交，保留修改和暂存区内容</td>
</tr>
<tr>
<td>mixed</td>
<td>回退到指定 commit</td>
<td>保持不变</td>
<td>更新为指定 commit 内容</td>
<td>用于撤销提交并取消暂存，保留工作目录的内容</td>
</tr>
<tr>
<td>hard</td>
<td>回退到指定 commit</td>
<td>重置为指定 commit 内容</td>
<td>重置为指定 commit 内容</td>
<td>用于彻底丢弃修改，回到某个 commit 状态</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><img src="/.io//image-2.png"></th>
<th><img src="/.io//image-3.png"></th>
<th><img src="/.io//image-4.png"></th>
</tr>
</thead>
</table>
<p><strong>适用场景举例：</strong></p>
<ul>
<li><strong><code>--soft</code></strong> ：你想撤销最近的提交，但不丢失文件修改，准备重新提交。</li>
<li><strong><code>--mixed</code></strong> ：你想撤销提交并取消暂存，但仍然保留修改，进行后续编辑。</li>
<li><strong><code>--hard</code></strong> ：你想丢弃所有本地的修改并回到某个提交的状态，彻底放弃当前修改。</li>
</ul>
<p><code>每个选项的影响不同，选择时需要根据实际需求来决定。</code></p>
<p><strong>git reset</strong> 会改变提交历史，建议不要在公共分支使用，如果在公共分支撤销提交可以使用 <strong>git revert</strong> ，它会保留记录。在前端开发中，如果修改只存在于本地，并且你确定不需要这些修改，可以使用 git reset 来快速清理。但如果修改已经推送到远程分支，或者你只是想撤销某个特定的提交，为了避免影响团队协作和代码历史的完整性，强烈建议使用 git revert。 尤其是在多人协作的项目中，revert 更安全可靠。</p>
<p><strong>hard</strong> 模式不仅会丢失已提交的改动，还可能丢失本地未提交的改动，要慎重使用。</p>
<h1 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h1><p>git revert是用于“反做”某一个版本，以达到撤销该版本的修改的目的。比如，我们commit了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西(test2)<br><img src="/.io//image-6.png"></p>
<h1 id="revert-vs-reset"><a href="#revert-vs-reset" class="headerlink" title="revert vs reset"></a>revert vs reset</h1><table>
<thead>
<tr>
<th>特性</th>
<th>git reset</th>
<th>git revert</th>
</tr>
</thead>
<tbody><tr>
<td>修改历史</td>
<td>会修改分支历史</td>
<td>不会修改分支历史，而是创建一个新的提交</td>
</tr>
<tr>
<td>应用场景</td>
<td>本地开发，未推送的修改</td>
<td>已经推送的提交</td>
</tr>
<tr>
<td>安全性</td>
<td>相对低，可能会丢失提交</td>
<td>相对高，保留完整的提交历史</td>
</tr>
<tr>
<td>精确度</td>
<td>可以回退到任意提交</td>
<td>可以精确撤销某个提交的更改</td>
</tr>
<tr>
<td>应用场景</td>
<td>1.本地开发，还未推送: 当你提交了一些错误的更改，或者想放弃一些本地的修改，可以使用 reset 来撤销这些更改。2.修改提交历史: 例如，合并多个提交为一个，或者修改某个提交的message。3.放弃合并: 如果你在合并分支时遇到冲突，并且决定放弃合并，可以使用 reset 回到合并前的状态。</td>
<td>1.已经推送的提交: 当你需要撤销一个已经推送到远程仓库的提交时，应该使用 revert，因为它不会修改已有的提交历史，避免了团队协作中的混乱。2.只想撤销某个特定提交: revert 可以精确地撤销某个提交的更改，而不会影响其他提交。</td>
</tr>
</tbody></table>
<p>推荐：</p>
<p><a href="https://x.zhixing.co/devops/the-differences-and-usages-of-git-merge-rebase/">Git merge &amp; rebase 区别和用法</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习</title>
    <url>/2024/12/11/git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/.io//image.png" alt="alt text"></p>
<p><img src="/.io//image-1.png" alt="alt text"><br><img src="/.io//image-2.png" alt="alt text"></p>
<h2 id="git文件的三种状态"><a href="#git文件的三种状态" class="headerlink" title="git文件的三种状态"></a>git文件的三种状态</h2><p>已修改(modified)<br>已经修改了工作区的某些文件。</p>
<p>已暂存(staged)<br>已经执行了add操作，但还没有提交，只是暂存在提交清单里。</p>
<p>已提交(commited)<br>已经提交到本地仓库里，但还没push到远端仓库。<br><img src="/.io//image-3.png" alt="alt text"><br><a href="https://cycle263.github.io/blogs/team/git/advanced.html">参考资料</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git无法访问外网</title>
    <url>/2024/12/31/git%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91/</url>
    <content><![CDATA[<h2 id="事情经过"><a href="#事情经过" class="headerlink" title="事情经过"></a>事情经过</h2><p>使用vscode git 提交代码和 hexo d时</p>
<p>莫名其妙出现 github ssh 22端口无法访问的情况：</p>
<p>尝试过切换成443端口<br>使用https访问远程，但是github客户端可以访问</p>
<p>怀疑是网络问题，没添加代理：</p>
<p>给vscode添加代理<br>给git添加代理</p>
<p>怀疑clash for windows 没开系统代理或者规则错误：</p>
<p>开启 system proxy<br>启用 global 规则</p>
<p>使用vscode、 cmd 、powershell和git ping Google.com 和 ping github.com都无效，只能ping 国内网站。</p>
<p>使用git bash clone 远程仓库一般都是没问题的，但是还是失败了，</p>
<p>致使明白翻墙工具的系统代理没开成功，遂比较另一台电脑，执行ping Google.com可以，对比翻墙工具的设置，</p>
<p>找到罪魁祸首是：tun mode</p>
<hr>
<h2 id="Clash-for-Windows-的-TUN-模式"><a href="#Clash-for-Windows-的-TUN-模式" class="headerlink" title="Clash for Windows 的 TUN 模式"></a>Clash for Windows 的 TUN 模式</h2><p>是一种用于透明代理的高级功能，可以影响网络流量的路由方式。以下是详细说明：</p>
<p><strong>什么是 TUN 模式？</strong><br>TUN 模式是基于操作系统的虚拟网络接口（TUN&#x2F;TAP）的工作方式，用于拦截和重定向网络流量。通过 TUN 模式，Clash 可以透明地代理应用程序的流量，而无需每个应用程序单独设置代理。</p>
<ul>
<li><p><strong>TUN 的工作原理</strong> ：</p>
<ul>
<li><p>它创建一个虚拟网卡，接收系统的所有网络流量。</p>
</li>
<li><p>根据 Clash 的代理规则，对网络请求进行分流或直接代理。</p>
</li>
</ul>
</li>
<li><p><strong>与系统代理的区别</strong> ：</p>
<ul>
<li><p>系统代理需要应用程序支持 HTTP&#x2F;HTTPS 或 SOCKS 协议，并手动配置代理。</p>
</li>
<li><p>TUN 模式可以自动拦截所有网络请求，适用于不支持代理配置的程序（如部分游戏或终端工具）。</p>
</li>
</ul>
</li>
</ul>
<h3 id="TUN-模式对系统代理的影响-为什么影响系统代理？"><a href="#TUN-模式对系统代理的影响-为什么影响系统代理？" class="headerlink" title="TUN 模式对系统代理的影响 为什么影响系统代理？"></a><strong>TUN 模式对系统代理的影响</strong> <strong>为什么影响系统代理？</strong></h3><ol>
<li><strong>默认拦截所有流量</strong> ：</li>
</ol>
<ul>
<li>TUN 模式接管了系统的大部分网络流量，可能会导致一些程序不再使用系统代理。</li>
</ul>
<ol start="2">
<li><strong>规则优先级问题</strong> ：</li>
</ol>
<ul>
<li>如果 Clash 的规则设置不正确，可能导致部分流量未能正确代理或被错误路由。</li>
</ul>
<ol start="3">
<li><strong>与其他代理冲突</strong> ：</li>
</ol>
<ul>
<li><p>如果系统已经配置了其他代理设置，TUN 模式可能会导致冲突，从而影响代理功能。<br><strong>常见问题</strong>  </p>
</li>
<li><p><strong>系统代理无效</strong> ：TUN 模式可能覆盖了系统代理设置。</p>
</li>
<li><p><strong>部分应用程序无法联网</strong> ：TUN 模式可能未正确配置分流规则，导致流量被错误处理。</p>
</li>
</ul>
<h3 id="解决方法-启用-TUN-模式的正确方式"><a href="#解决方法-启用-TUN-模式的正确方式" class="headerlink" title="解决方法 启用 TUN 模式的正确方式"></a><strong>解决方法</strong> <strong>启用 TUN 模式的正确方式</strong></h3><ol>
<li><p>打开 Clash for Windows。</p>
</li>
<li><p>在设置中启用 TUN 模式：  <strong>General &gt; TUN Mode</strong>  勾选开启。</p>
</li>
<li><p>确保 DNS 设置启用：   在 <strong>DNS Settings</strong>  中启用 “Enable”。</p>
</li>
</ol>
<p><strong>调整代理规则</strong>  </p>
<ol>
<li><p>确保规则优先级正确：</p>
<p>  例如： </p>
<ul>
<li>将 <code>Direct</code> 设置为默认策略。</li>
<li>对需要代理的流量（如 GitHub）添加规则，强制走代理。</li>
</ul>
</li>
<li><p>检查规则文件是否准确无误（可以通过日志查看流量是否正确路由）。</p>
</li>
<li><p>测试网络连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping https://github.com</span><br></pre></td></tr></table></figure>
<p><strong>关闭 TUN 模式（如果不需要）</strong></p>
</li>
</ol>
<ul>
<li>如果系统代理已经满足需求，可以关闭 TUN 模式：<ol>
<li>打开 Clash 设置。</li>
<li>取消勾选 <strong>TUN Mode</strong> 。</li>
<li>确保 <strong>System Proxy</strong>  启用。</li>
</ol>
</li>
</ul>
<p><strong>TUN 模式的适用场景</strong> </p>
<ul>
<li>用于拦截不支持手动代理配置的程序流量。</li>
<li>适用于需要全局透明代理的环境，如部分终端工具或游戏。</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 路径表示</title>
    <url>/2024/12/01/hexo%20%E8%B7%AF%E5%BE%84%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<p>在 Hexo 中，路径表示（即如何表示文件和目录的路径）有几个常见的用法和约定，具体取决于你是在配置站点、创建内容，还是处理资源。以下是常见的路径表示方式和相关解释：</p>
<h2 id="相对路径与绝对路径"><a href="#相对路径与绝对路径" class="headerlink" title="相对路径与绝对路径"></a><strong>相对路径与绝对路径</strong></h2><ul>
<li><p><strong>相对路径</strong> ：Hexo 中很多地方使用相对路径，通常相对路径是相对于 Hexo 项目的根目录或某些子目录的。例如：</p>
<ul>
<li><code>source/_posts/</code> 表示博客文章的存储位置。</li>
<li><code>source/_pages/</code> 表示页面文件的存储位置。</li>
</ul>
</li>
<li><p><strong>绝对路径</strong> ：通常是相对于网站根目录的路径，例如：</p>
<ul>
<li><code>/about/</code> 代表网站根目录下的 <code>about</code> 页面（通常通过 Hexo 配置生成）。</li>
</ul>
</li>
</ul>
<h2 id="Hexo-配置文件中的路径表示"><a href="#Hexo-配置文件中的路径表示" class="headerlink" title="Hexo 配置文件中的路径表示"></a><strong>Hexo 配置文件中的路径表示</strong></h2><p>在 Hexo 的 <code>_config.yml</code> 配置文件中，许多路径表示都是相对于站点根目录的。例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo站点的URL</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 博客的URL路径</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存放站点文件的目录</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>url</code></strong> ：表示站点的根 URL。</li>
<li><strong><code>permalink</code></strong> ：指定生成的文章 URL 格式。<code>/</code> 斜杠表示站点根目录。</li>
<li><strong><code>source_dir</code></strong>  和 <strong><strong><code>source_dir</code></strong>  和 <code>public_dir</code></strong> ：定义了源文件和生成后的文件所在的目录。</li>
</ul>
<h2 id="创建文章与页面的路径表示"><a href="#创建文章与页面的路径表示" class="headerlink" title="创建文章与页面的路径表示"></a><strong>创建文章与页面的路径表示</strong></h2><p>在 Hexo 中，创建文章和页面时通常会有路径约定：</p>
<ul>
<li><strong>文章路径</strong> ：默认情况下，文章会存放在 <code>source/_posts/</code> 目录下。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;My First Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>该命令会在 <code>source/_posts/</code> 目录下创建一个新的 Markdown 文件，文件名是文章标题的拼音。</p>
<ul>
<li><strong>页面路径</strong> ：页面会存放在 <code>source/_pages/</code> 目录下。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;About&quot;</span></span><br></pre></td></tr></table></figure>

<p>该命令会在 <code>source/_pages/</code> 下创建一个新的页面文件，通常用于站点的静态页面（如关于页面、联系页面等）。</p>
<h2 id="静态资源路径表示"><a href="#静态资源路径表示" class="headerlink" title="静态资源路径表示"></a><strong>静态资源路径表示</strong></h2><p>在 Hexo 中，静态资源（如图片、JavaScript 文件、CSS 文件等）通常放在 <code>source</code> 目录中的子目录中，然后通过相对路径引用。这些资源会被复制到 <code>public</code> 目录下，并可以通过 URL 引用。</p>
<ul>
<li>例如，你可以把图片放在 <code>source/images/</code> 目录中，引用时使用相对路径：</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Image</span>](<span class="link">images/my-image.jpg</span>)</span><br></pre></td></tr></table></figure>

<p>该图片会被复制到 <code>public/images/</code> 目录，并且可以通过 <code>/images/my-image.jpg</code> 访问。</p>
<h2 id="主题配置中的路径"><a href="#主题配置中的路径" class="headerlink" title="主题配置中的路径"></a><strong>主题配置中的路径</strong></h2><p>在 Hexo 主题的 <code>_config.yml</code> 配置文件中，通常会有一些与路径相关的设置，特别是与静态资源和模板文件相关的路径。例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主题中静态资源的路径</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/favicon.ico</span></span><br><span class="line"><span class="attr">logo:</span> <span class="string">/images/logo.png</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>favicon</code> 和 <code>logo</code> 等设置中使用的是站点根目录的路径（如 <code>/images/logo.png</code>），这些路径在生成站点时会指向 <code>public</code> 目录中的相应位置。</li>
</ul>
<h2 id="URL-路径与文件路径的映射"><a href="#URL-路径与文件路径的映射" class="headerlink" title="URL 路径与文件路径的映射"></a><strong>URL 路径与文件路径的映射</strong></h2><p>Hexo 将博客文章文件的路径（例如 <code>source/_posts/</code>）转换为对应的 URL 路径。例如，如果你有一个 <code>source/_posts/2024/hello-world.md</code> 的文章文件，Hexo 会将其转换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://yoursite.com/2024/hello-world/</span><br></pre></td></tr></table></figure>

<p>路径映射规则是通过 <code>_config.yml</code> 中的 <code>permalink</code> 配置项进行控制的。你可以自定义文章的 URL 路径格式，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br></pre></td></tr></table></figure>

<p>这样，文章的 URL 路径会包含年份、月份、日期和文章标题。</p>
<h2 id="路径和文件系统中的斜杠"><a href="#路径和文件系统中的斜杠" class="headerlink" title="路径和文件系统中的斜杠"></a>路径和文件系统中的斜杠</h2><ul>
<li>在 Hexo 中，路径使用 <code>/</code> 斜杠表示文件和目录之间的分隔符。即使在 Windows 系统中，Hexo 仍然使用 <code>/</code> 作为路径分隔符，这是因为 Hexo 在不同操作系统上有统一的路径处理方式。</li>
</ul>
<h2 id="Hexo-路径表示的小技巧"><a href="#Hexo-路径表示的小技巧" class="headerlink" title="Hexo 路径表示的小技巧"></a><strong>Hexo 路径表示的小技巧</strong></h2><ul>
<li><strong>绝对路径引用：</strong>  如果想要在站点中引用根目录下的文件，可以使用 <code>/</code> 开头的绝对路径。例如，<code>/images/logo.png</code> 会引用 <code>public/images/logo.png</code>。</li>
<li><strong>相对路径引用：</strong>  在文章或页面中引用文件时，通常使用相对路径。例如，<code>./images/photo.jpg</code> 会引用 <code>source/images/photo.jpg</code>。</li>
</ul>
<p><strong>例子：在 Hexo 中使用路径</strong></p>
<p>假设你有以下文件结构：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">hexo/</span><br><span class="line">  source/</span><br><span class="line">    _posts/</span><br><span class="line">      <span class="keyword">my</span>-first-post.md</span><br><span class="line">    images/</span><br><span class="line">      logo.png</span><br><span class="line">  themes/</span><br><span class="line">    <span class="keyword">my</span>-theme/</span><br><span class="line">      _config.yml</span><br><span class="line">  _config.yml</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>创建一个新文章</strong> ：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;My First Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将在 <code>source/_posts/</code> 中创建一个 <code>my-first-post.md</code> 文件。</p>
<ol start="2">
<li><strong>在文章中引用图片</strong> ：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Logo</span>](<span class="link">/images/logo.png</span>)</span><br></pre></td></tr></table></figure>

<p>这会引用 <code>public/images/logo.png</code> 文件。</p>
<ol start="3">
<li><strong>修改 <code>_config.yml</code> 配置</strong> ：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">http://mywebsite.com</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br></pre></td></tr></table></figure>

<p>这将使生成的文章 URL 类似于 <code>http://mywebsite.com/2024/01/01/my-first-post/</code>。</p>
<p><strong>总结</strong></p>
<p>在 Hexo 中，路径的表示方式通常依赖于文件系统的位置、站点的根目录以及 <code>_config.yml</code> 中的配置。你可以使用相对路径和绝对路径来链接文章、页面、静态资源，并通过配置文件来控制 URL 路径和静态资源的位置。</p>
<h2 id="和"><a href="#和" class="headerlink" title=".&#x2F;和..&#x2F;"></a>.&#x2F;和..&#x2F;</h2><p><code>./</code> 和 <code>../</code> 是文件路径中的相对路径符号，通常用于指示文件系统中的位置。它们在命令行、编程、文件引用等场景中都非常常见。下面是它们的具体含义：</p>
<h3 id="的含义"><a href="#的含义" class="headerlink" title="./ 的含义"></a><code>./</code> 的含义</h3><ul>
<li><code>./</code> 表示当前目录（即你当前所在的目录）。</li>
<li>它通常用来表示当前目录下的某个文件或文件夹，或者作为命令行中的前缀来执行当前目录中的程序。</li>
</ul>
<p><strong>例子：</strong></p>
<ul>
<li><code>./file.txt</code>：指当前目录下的 <code>file.txt</code> 文件。</li>
<li>在命令行中执行当前目录中的程序：<code>./myprogram</code>。<br>在 Hexo 或其他 Web 开发场景中，<code>./</code> 主要用于引用当前目录中的文件。例如，在文章中引用当前目录下的图片：</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">My Image</span>](<span class="link">./images/photo.jpg</span>)</span><br></pre></td></tr></table></figure>

<p>这表示引用 <code>source/images/photo.jpg</code> 文件。</p>
<h3 id="的含义-1"><a href="#的含义-1" class="headerlink" title="../ 的含义"></a><code>../</code> 的含义</h3><ul>
<li><code>../</code> 表示上一级目录（即当前目录的父目录）。</li>
<li>它通常用于返回到当前目录的上一级目录，在文件系统中向上移动一个层级。</li>
</ul>
<p><strong>例子：</strong></p>
<ul>
<li><code>../file.txt</code>：指的是上一级目录中的 <code>file.txt</code> 文件。</li>
<li><code>../../</code>：表示上上一级目录。<br>在 Hexo 或其他开发场景中，<code>../</code> 用于引用上级目录中的文件。例如，假设你在 <code>source/_posts/</code> 目录下，并且想要引用 <code>source/images/</code> 目录中的文件，可以使用 <code>../</code>：</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Logo</span>](<span class="link">../images/logo.png</span>)</span><br></pre></td></tr></table></figure>

<p>这表示从当前目录 <code>source/_posts/</code> 向上一级（即 <code>source/</code>）跳转，再进入 <code>images/</code> 目录，最终引用 <code>logo.png</code> 文件。</p>
<p><strong>实际示例</strong></p>
<p>假设文件结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo/</span><br><span class="line">  <span class="built_in">source</span>/</span><br><span class="line">    _posts/</span><br><span class="line">      post1.md</span><br><span class="line">    images/</span><br><span class="line">      logo.png</span><br></pre></td></tr></table></figure>

<ul>
<li>如果你在 <code>post1.md</code> 文件中想要引用 <code>logo.png</code> 文件：</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Logo</span>](<span class="link">../images/logo.png</span>)</span><br></pre></td></tr></table></figure>

<p>这样，<code>../</code> 表示从 <code>source/_posts/</code> 目录向上返回到 <code>source/</code> 目录，然后再进入 <code>images/</code> 目录。</p>
<ul>
<li>如果你在 <code>source/images/</code> 中，想引用 <code>source/_posts/post1.md</code> 文件：</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Post 1</span>](<span class="link">../_posts/post1.md</span>)</span><br></pre></td></tr></table></figure>

<p>这样，<code>../</code> 会让你从 <code>images/</code> 目录返回到 <code>source/</code>，然后进入 <code>_posts/</code> 目录。</p>
<p><strong>总结：</strong></p>
<ul>
<li><strong><code>./</code></strong> ：当前目录。</li>
<li><strong><code>../</code></strong> ：上一级目录（父目录）。</li>
</ul>
<p>这两个符号是相对路径的一部分，帮助你在不同的目录之间进行导航。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo butterfly 添加rightside 按钮</title>
    <url>/2025/01/21/hexo-butterfly-%E6%B7%BB%E5%8A%A0rightside-%E6%8C%89%E9%92%AE/</url>
    <content><![CDATA[<p>F12调试，查找对应元素的id:页面点击关联至页面元素html标签</p>
<p>themes\butterfly\layout\includes\rightside.pug</p>
<p>themes\butterfly\source\js\main.js</p>
<p>查找 hide-aside-btn  </p>
<p><img src="/.io//image.png"></p>
<p>pug写布局<br>styl写样式<br>main.js控件调用的功能逻辑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pug代码，遍历生成自定义按钮：</span><br><span class="line"></span><br><span class="line">mixin <span class="title function_">rightsideItem</span>(array)</span><br><span class="line">  each item <span class="keyword">in</span> array</span><br><span class="line">    <span class="keyword">case</span> item</span><br><span class="line">      when <span class="string">&#x27;customButton&#x27;</span></span><br><span class="line">        button#custom-<span class="title function_">button</span>(type=<span class="string">&quot;button&quot;</span> title=<span class="string">&quot;全屏阅读&quot;</span>)</span><br><span class="line">          i.<span class="property">fas</span>.<span class="property">fa</span>-star</span><br><span class="line"></span><br><span class="line">添加按钮到列表：</span><br><span class="line"></span><br><span class="line">#rightside</span><br><span class="line">  - <span class="keyword">const</span> &#123; enable, hide, show &#125; = theme.<span class="property">rightside_item_order</span></span><br><span class="line">  - <span class="keyword">const</span> hideArray = enable ? hide &amp;&amp; hide.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>) : [<span class="string">&#x27;readmode&#x27;</span>,<span class="string">&#x27;translate&#x27;</span>,<span class="string">&#x27;darkmode&#x27;</span>,<span class="string">&#x27;hideAside&#x27;</span>, <span class="string">&#x27;customButton&#x27;</span>]</span><br><span class="line">  - <span class="keyword">const</span> showArray = enable ? show &amp;&amp; show.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>) : [<span class="string">&#x27;toc&#x27;</span>,<span class="string">&#x27;chat&#x27;</span>,<span class="string">&#x27;comment&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按钮click事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;custom-button&#x27;</span>: <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      <span class="comment">// 自定义按钮（阅读模式）</span></span><br><span class="line">      <span class="comment">// document.getElementById(&quot;custom-button&quot;).addEventListener(&quot;click&quot;, function () &#123;</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> page;</span><br><span class="line">        <span class="keyword">const</span> _page = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (_page)</span><br><span class="line">          page = _page;</span><br><span class="line">        <span class="keyword">const</span> _post = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;post&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (_post)</span><br><span class="line">          page = _post;</span><br><span class="line">        page.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&quot;100%&quot;</span>; <span class="comment">// 撑满屏幕</span></span><br><span class="line">        <span class="comment">// page.style.setProperty(&quot;padding&quot;, &quot;160px&quot;, &quot;important&quot;);</span></span><br><span class="line">        page.<span class="property">style</span>.<span class="property">padding</span> = <span class="string">&quot;86px&quot;</span>; <span class="comment">// 撑满屏幕 不加单位视为百分百</span></span><br><span class="line">        <span class="keyword">const</span> content = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;content-inner&quot;</span>);</span><br><span class="line">        content.<span class="property">style</span>.<span class="property">maxWidth</span> = <span class="string">&quot;100%&quot;</span>; <span class="comment">// 撑满屏幕</span></span><br><span class="line">        content.<span class="property">style</span>.<span class="property">margin</span> = <span class="string">&quot;0&quot;</span>; <span class="comment">// 撑满屏幕</span></span><br><span class="line">        content.<span class="property">style</span>.<span class="property">padding</span> = <span class="string">&quot;0&quot;</span>; <span class="comment">// 撑满屏幕</span></span><br><span class="line">      <span class="comment">// &#125;)</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>


<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>_config.butterfly.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;style&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;  .custom-action-buttons &#123;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    position: fixed;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    bottom: -5px;&#x27;</span> <span class="comment"># 调整按钮位置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    right: 10px;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    z-index: 100;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;  &#125;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;  .custom-action-buttons .action-item &#123;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    width: 35px;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    height: 35px;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    background-color: #1f1f1f;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    border-radius: 5px;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    display: flex;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    justify-content: center;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    align-items: center;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    color: white;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    cursor: pointer;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    margin-bottom: 10px;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;  &#125;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;  .custom-action-buttons .action-item:hover &#123;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    background-color: #555;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;  &#125;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;/style&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;div class=&quot;custom-action-buttons&quot;&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;  &lt;div class=&quot;action-item&quot; id=&quot;custom-music-button&quot; onclick=&quot;toggleMusic()&quot;&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    &lt;i class=&quot;fas fa-music&quot;&gt;&lt;/i&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;  &lt;/div&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;/div&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;script&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;  function toggleMusic() &#123;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    const musicPlayer = document.getElementById(&quot;music-player&quot;);&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    if (musicPlayer.style.display === &quot;none&quot;) &#123;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;      musicPlayer.style.display = &quot;block&quot;;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    &#125; else &#123;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;      musicPlayer.style.display = &quot;none&quot;;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    &#125;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;  &#125;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;/script&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;div id=&quot;music-player&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;script&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;  fetch(&quot;/music/playlist.json&quot;)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    .then(response =&gt; response.json())&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    .then(data =&gt; &#123;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;      const ap = new APlayer(&#123;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;        container: document.getElementById(&quot;music-player&quot;),&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;        fixed: true,&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;        autoplay: false,&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;        audio: data,&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;        lrcType: 3&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;      &#125;);&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    &#125;)&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    .catch(error =&gt; console.error(&quot;Error loading playlist:&quot;, error));&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;/script&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="分别创建"><a href="#分别创建" class="headerlink" title="分别创建"></a>分别创建</h3><p>将 HTML、CSS 和 JavaScript 提取到独立的文件中，利用 Hexo 的 <code>asset</code> 机制进行引用。：</p>
<ol>
<li><strong>HTML</strong> (通过 <code>inject</code> 注入)</li>
</ol>
<p>在 <code>inject.bottom</code> 配置中，只保留最简洁的 HTML 结构，避免将 CSS 和 JavaScript 内联。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;/path/to/custom/styles.css&quot;&gt;&#x27;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;div class=&quot;custom-action-buttons&quot;&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;  &lt;div class=&quot;action-item&quot; id=&quot;custom-music-button&quot;&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;    &lt;i class=&quot;fas fa-music&quot;&gt;&lt;/i&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;  &lt;/div&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;/div&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;div id=&quot;music-player&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;&lt;script src=&quot;/path/to/custom/scripts.js&quot;&gt;&lt;/script&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>CSS</strong> (放在 <code>themes/butterfly/source/css/custom/styles.css</code> 文件中)</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* custom/styles.css */</span></span><br><span class="line"><span class="selector-class">.custom-action-buttons</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">5px</span>; <span class="comment">/* 调整按钮位置 */</span></span><br><span class="line">  <span class="attribute">right</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-action-buttons</span> <span class="selector-class">.action-item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">35px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">35px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#1f1f1f</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-action-buttons</span> <span class="selector-class">.action-item</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#555</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>JavaScript</strong> (放在 <code>themes/butterfly/source/js/custom/scripts.js</code> 文件中)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// custom/scripts.js</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;custom-music-button&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, toggleMusic);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toggleMusic</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> musicPlayer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;music-player&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (musicPlayer.<span class="property">style</span>.<span class="property">display</span> === <span class="string">&quot;none&quot;</span>) &#123;</span><br><span class="line">    musicPlayer.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    musicPlayer.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载音乐播放器</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/music/playlist.json&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ap = <span class="keyword">new</span> <span class="title class_">APlayer</span>(&#123;</span><br><span class="line">      <span class="attr">container</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;music-player&quot;</span>),</span><br><span class="line">      <span class="attr">fixed</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">autoplay</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">audio</span>: data,</span><br><span class="line">      <span class="attr">lrcType</span>: <span class="number">3</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error loading playlist:&quot;</span>, error));</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>两种方式都有弊端：</p>
<ul>
<li>第一种方式更加规范，但是由于带动了主题代码，升级主题可能会导致原来的脚本丢失。</li>
<li>第二种方式更灵活，但是这么写不方便调试和阅读，如果将代码分别放到新建立的css和js代码中，使用引用脚本又有点小题大做。</li>
</ul>
<h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><ol>
<li><p><strong>减少 HTML 字符串的拼接</strong>：<br>在 Hexo 的 <code>inject</code> 配置中，你目前是通过多行字符串拼接的方式插入 HTML、CSS 和 JavaScript。这会增加代码的冗长并且可能使其难以维护。可以考虑将 HTML、CSS 和 JavaScript 提取到独立的文件中，利用 Hexo 的 <code>asset</code> 机制进行引用。</p>
</li>
<li><p><strong>减少内联 CSS 和 JavaScript</strong>：<br>将 CSS 和 JavaScript 移动到外部文件中，而不是直接嵌入在 <code>inject</code> 配置中。这不仅可以减少页面的大小，还能提高代码的可重用性和可维护性。</p>
</li>
<li><p><strong>使用 Pug 或 CSS 来代替 HTML 和内联样式</strong>：<br>如果你希望代码更简洁，可以使用 Pug 模板和 CSS 来实现布局和样式，而不是直接在 <code>inject</code> 中写 HTML 和 CSS。</p>
</li>
<li><p><strong>优化 JavaScript 和事件绑定</strong>：<br>通过 <code>addEventListener</code> 方式绑定事件，而不是在 HTML 中使用 <code>onclick</code> 属性，这样可以使 JavaScript 更加分离并且可维护。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>hexo 图片加载方案</title>
    <url>/2024/12/11/hexo-%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="安装-hexo-asset-image-插件"><a href="#安装-hexo-asset-image-插件" class="headerlink" title="安装 hexo-asset-image 插件"></a>安装 hexo-asset-image 插件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>打开node_modules\hexo-asset-image\index.js文件59行附近：<br>修改代码为如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src = srcArray.join(&#x27;/&#x27;);这个是源码,从这下面开始修改替换</span></span><br><span class="line"><span class="keyword">var</span> baseUrl = data.<span class="property">permalink</span>;</span><br><span class="line"><span class="comment">// 判断当前页面是否为文章</span></span><br><span class="line"><span class="keyword">if</span> (data.<span class="property">layout</span> === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 匹配最后两个斜杠间的内容和最后的斜杠，并替换为单个斜杠，目的是去掉文档存放的文件夹名</span></span><br><span class="line">    baseUrl = data.<span class="property">permalink</span>.<span class="title function_">replace</span>(<span class="regexp">/\/[^\/]+\/$/</span>, <span class="string">&#x27;/&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line">$(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, baseUrl +src);</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;update link as:--&gt;&quot;</span>+baseUrl+src);</span><br></pre></td></tr></table></figure>

<h2 id="页签页md文档中插入图片"><a href="#页签页md文档中插入图片" class="headerlink" title="页签页md文档中插入图片"></a>页签页md文档中插入图片</h2><p>上面的方法可以在普通文章使用，但是页签页内容插入图片会多出: .html后缀</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://xxx/musicPage/index.html</span><br></pre></td></tr></table></figure>
<p>打开_config.yml ，修改如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="1-trailing-index"><a href="#1-trailing-index" class="headerlink" title="1. trailing_index"></a>1. trailing_index</h3><p>这个选项控制是否在 URL 末尾自动添加 index。例如：</p>
<p>如果 trailing_index: true，那么像 <a href="https://example.com/posts/">https://example.com/posts/</a> 这样的 URL 会变成 <a href="https://example.com/posts/index.html%E3%80%82">https://example.com/posts/index.html。</a><br>如果 trailing_index: false，URL 末尾就不会自动添加 index，它会保持 <a href="https://example.com/posts/">https://example.com/posts/</a> 的形式。</p>
<h3 id="2-trailing-html"><a href="#2-trailing-html" class="headerlink" title="2. trailing_html"></a>2. trailing_html</h3><p>这个选项控制是否在 URL 末尾添加 .html 后缀。例如：</p>
<p>如果 trailing_html: true，像 <a href="https://example.com/posts/">https://example.com/posts/</a> 会变成 <a href="https://example.com/posts/index.html%E3%80%82">https://example.com/posts/index.html。</a><br>如果 trailing_html: false，URL 会去掉 .html 后缀，直接使用像 <a href="https://example.com/posts/">https://example.com/posts/</a> 这样的格式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>这个方式的好处在于：</p>
<ul>
<li>支持vscode中正常预览</li>
<li>无需修改Ctrl+V粘贴的路径</li>
<li>本地构建的网站和正式部署的网站都能正常显示</li>
</ul>
<h1 id="html-脚本中添加图片"><a href="#html-脚本中添加图片" class="headerlink" title="html 脚本中添加图片"></a>html 脚本中添加图片</h1><p>我们直接复制粘贴的路径：<br>将路径</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">![<span class="string">alt text</span>](<span class="link">index/image.png</span>)</span><br></pre></td></tr></table></figure>
<p>粘贴到scr中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;index/image.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;捡贝&quot;</span> <span class="attr">class</span>=<span class="string">&quot;project-image w-full h-64 object-cover&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们会发现 html 最终生成的路径中少了 index 这一层：</p>
<p>src : index&#x2F;image.png</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update link as:--&gt;https://xxxx/About/   image.png</span><br></pre></td></tr></table></figure>
<p>我们需要在hexo-asset-image\index.js文件中处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(srcArray.<span class="property">length</span> &gt; <span class="number">1</span> &amp;&amp; srcArray[<span class="number">0</span>]!=<span class="string">&quot;index&quot;</span>)<span class="comment">//添加判断防止使用html 加载图片时会抹去index层级</span></span><br><span class="line">   srcArray.<span class="title function_">shift</span>();</span><br></pre></td></tr></table></figure>
<p>这段代码原本是要移出src中第一层目录，应为md格式会自动补充根目录，会出现重复目录，但是html 格式不涉及自动补充根目录，所以不需要这一步，因此要添加判断。</p>
<p>node_modules\hexo-asset-image\index.js需要修改部分的完整的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;img&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> ($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">       <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">       <span class="keyword">var</span> src = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">       <span class="comment">//console.info&amp;&amp;console.info(&quot;.... &quot;+src);</span></span><br><span class="line">       <span class="keyword">if</span>(!(<span class="regexp">/http[s]*.*|\/\/.*/</span>.<span class="title function_">test</span>(src)</span><br><span class="line">         || <span class="regexp">/^\s+\//</span>.<span class="title function_">test</span>(src)</span><br><span class="line">         || <span class="regexp">/^\s*\/uploads|images\//</span>.<span class="title function_">test</span>(src))) &#123;</span><br><span class="line">         <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">         <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">         <span class="keyword">var</span> linkArray = link.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">         &#125;);</span><br><span class="line">         <span class="keyword">var</span> srcArray = src.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">         &#125;);</span><br><span class="line">         <span class="comment">// if(srcArray.length &gt; 1 &amp;&amp; srcArray[0]!=&quot;index&quot;)//添加判断防止使用html 加载图片时会抹去index层级</span></span><br><span class="line">         <span class="comment">// srcArray.shift();</span></span><br><span class="line">         src = srcArray.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">         <span class="comment">// console.info&amp;&amp;console.info(&quot;____&quot; +src);</span></span><br><span class="line">         </span><br><span class="line">         <span class="keyword">var</span> baseUrl = data.<span class="property">permalink</span>;</span><br><span class="line">         <span class="comment">// 判断当前页面是否为文章</span></span><br><span class="line">         <span class="keyword">if</span> (data.<span class="property">layout</span> === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">           baseUrl = data.<span class="property">permalink</span>.<span class="title function_">replace</span>(<span class="regexp">/\/[^\/]+\/$/</span>, <span class="string">&#x27;/&#x27;</span>); <span class="comment">// 匹配最后两个斜杠间的内容和最后的斜杠，并替换为单个斜杠</span></span><br><span class="line">         &#125;</span><br><span class="line">         $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, baseUrl +src);</span><br><span class="line">         <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;update link as:--&gt;&quot;</span>+baseUrl+ <span class="string">&quot;   &quot;</span>  +src);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>($(<span class="variable language_">this</span>));</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo添加标签样式</title>
    <url>/2024/12/15/hexo%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p>在 <strong>Hexo Butterfly</strong>  主题中，由于 Markdown 文件中的代码会经过 Hexo 的解析后转换为 HTML，而 HTML 的样式需要依赖主题中的 CSS 文件，直接嵌入的 TailwindCSS 或自定义 CSS 可能无法生效。如果你希望在 Hexo 中生效样式，可以尝试以下方法：</p>
<h2 id="解决方法-1：使用行内样式-style-属性"><a href="#解决方法-1：使用行内样式-style-属性" class="headerlink" title="解决方法 1：使用行内样式 (style 属性)"></a>解决方法 1：使用行内样式 (style 属性)</h2><p>在 Hexo Markdown 中，直接使用 HTML 的 <code>style</code> 属性为每个标签设置样式。这种方法不依赖外部 CSS 文件，可以确保样式生效。<br>示例： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;skill-tags&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #e0f7fa; color: #006064; padding: 4px 12px; border-radius: 999px; display: inline-block; text-align: center;&quot;</span>&gt;</span>Next<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #e0f7fa; color: #006064; padding: 4px 12px; border-radius: 999px; display: inline-block; text-align: center;&quot;</span>&gt;</span>Plasmo<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #e0f7fa; color: #006064; padding: 4px 12px; border-radius: 999px; display: inline-block; text-align: center;&quot;</span>&gt;</span>Typescript<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #e0f7fa; color: #006064; padding: 4px 12px; border-radius: 999px; display: inline-block; text-align: center;&quot;</span>&gt;</span>Supabase<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #e0f7fa; color: #006064; padding: 4px 12px; border-radius: 999px; display: inline-block; text-align: center;&quot;</span>&gt;</span>TailwindCSS<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="解决方法-2：在主题配置中添加自定义-CSS"><a href="#解决方法-2：在主题配置中添加自定义-CSS" class="headerlink" title="解决方法 2：在主题配置中添加自定义 CSS"></a>解决方法 2：在主题配置中添加自定义 CSS</h2><p>步骤：</p>
<ol>
<li><p><strong>找到 Butterfly 主题的 CSS 文件：</strong><br>通常在 <code>source/css/_custom.css</code> 或 <code>source/_data/styles.styl</code> 中可以添加自定义样式。</p>
</li>
<li><p><strong>添加样式：</strong></p>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.skill-tags</span> <span class="selector-class">.tag</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e0f7fa</span>; <span class="comment">/* 浅蓝色背景 */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#006064</span>; <span class="comment">/* 深蓝色文字 */</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.875rem</span>; <span class="comment">/* 文字大小 */</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">4px</span> <span class="number">12px</span>; <span class="comment">/* 内边距 */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">999px</span>; <span class="comment">/* 圆角背景 */</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>在 Markdown 文件中使用：</strong></li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;skill-tags&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;tag&quot;</span>&gt;</span>Next<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;tag&quot;</span>&gt;</span>Plasmo<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;tag&quot;</span>&gt;</span>Typescript<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;tag&quot;</span>&gt;</span>Supabase<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;tag&quot;</span>&gt;</span>TailwindCSS<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="解决方法-3：使用-Hexo-的-标签"><a href="#解决方法-3：使用-Hexo-的-标签" class="headerlink" title="解决方法 3：使用 Hexo 的 &lt;style&gt; 标签"></a>解决方法 3：使用 Hexo 的 <code>&lt;style&gt;</code> 标签</h2><p>如果不想全局修改，只想在某一篇文章中生效样式，可以直接在 Markdown 文件中添加 <code>&lt;style&gt;</code> 标签。<br>示例： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.skill-tags</span> <span class="selector-class">.tag</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#e0f7fa</span>; <span class="comment">/* 浅蓝色背景 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: <span class="number">#006064</span>; <span class="comment">/* 深蓝色文字 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">0.875rem</span>; <span class="comment">/* 文字大小 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">4px</span> <span class="number">12px</span>; <span class="comment">/* 内边距 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">999px</span>; <span class="comment">/* 圆角背景 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;skill-tags&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;tag&quot;</span>&gt;</span>Next<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;tag&quot;</span>&gt;</span>Plasmo<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;tag&quot;</span>&gt;</span>Typescript<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;tag&quot;</span>&gt;</span>Supabase<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;tag&quot;</span>&gt;</span>TailwindCSS<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：<br><code>&lt;style&gt;</code> 标签必须写在文章的 HTML 部分中，不能直接用在纯 Markdown 语法中。</p>
<h2 id="解决方法-4：通过-Butterfly-的自定义组件功能"><a href="#解决方法-4：通过-Butterfly-的自定义组件功能" class="headerlink" title="解决方法 4：通过 Butterfly 的自定义组件功能"></a>解决方法 4：通过 Butterfly 的自定义组件功能</h2><p> Butterfly 主题支持自定义 <code>shortcode</code> 或 <strong>Nunjucks 模板</strong> ，可以在配置中添加一个通用组件。<br>步骤：</p>
<ol>
<li><p><strong>在 Butterfly 的 <code>source/_data</code> 中创建 <code>custom.swig</code> 文件（如果不存在）。</strong></p>
</li>
<li><p><strong>定义一个标签模板：</strong></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% for skill in skills %&#125;</span><br><span class="line">    &lt;span class=&quot;tag&quot; style=&quot;background-color: #e0f7fa; color: #006064; padding: 4px 12px; border-radius: 999px; display: inline-block; text-align: center;&quot;&gt;&#123;&#123; skill &#125;&#125;&lt;/span&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>在 Markdown 文件中使用：</strong></li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% custom skills=[&quot;Next&quot;, &quot;Plasmo&quot;, &quot;Typescript&quot;, &quot;Supabase&quot;, &quot;TailwindCSS&quot;] %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong> </p>
<hr>
<p>如果样式完全无法生效，建议先检查以下内容：</p>
<ol>
<li><p>Markdown 文件是否启用了 HTML 渲染（Hexo 默认支持）。</p>
</li>
<li><p>自定义样式是否被主题的全局样式覆盖，可以用浏览器调试工具检查。</p>
</li>
<li><p>如果是 TailwindCSS，确保它已集成到 Butterfly 主题中。优先推荐 <strong>方法 2</strong>（主题配置中添加 CSS）或 <strong>方法 3</strong>（文章中嵌入 <code>&lt;style&gt;</code> 标签），这些方法既灵活又能避免重复代码。</p>
</li>
</ol>
<blockquote>
<p>样式效果</p>
</blockquote>
<div class="skill-tags">
    <span style="background-color: #e0f7fa; color: #006064; padding: 4px 12px; border-radius: 999px; display: inline-block; text-align: center;">效果一</span>
    <span style="background-color: #e0f7fa; color: #006064; padding: 4px 12px; border-radius: 999px; display: inline-block; text-align: center;">Plasmo</span>
    <span style="background-color: #e0f7fa; color: #006064; padding: 4px 12px; border-radius: 999px; display: inline-block; text-align: center;">Typescript</span>
    <span style="background-color: #e0f7fa; color: #006064; padding: 4px 12px; border-radius: 999px; display: inline-block; text-align: center;">Supabase</span>
    <span style="background-color: #e0f7fa; color: #006064; padding: 4px 12px; border-radius: 999px; display: inline-block; text-align: center;">TailwindCSS</span>
</div>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 疑难杂症</title>
    <url>/2024/12/28/hexo%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/</url>
    <content><![CDATA[<h2 id="butterfly通过样式隐藏页脚"><a href="#butterfly通过样式隐藏页脚" class="headerlink" title="butterfly通过样式隐藏页脚"></a>butterfly通过样式隐藏页脚</h2><p>如果配置文件没有提供选项，可以通过 CSS 隐藏页脚区域。<br>打开或创建 source&#x2F;css&#x2F;_layout&#x2F;footer.styl 文件。</p>
<p>添加以下内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">复制代码</span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hexo-页面跳转时，界面未完全加载"><a href="#hexo-页面跳转时，界面未完全加载" class="headerlink" title="hexo 页面跳转时，界面未完全加载"></a>hexo 页面跳转时，界面未完全加载</h2><p>页面刷新时正常的，但是从其他页面跳转过来时，js代码加载的内容都没加载出来</p>
<p>我的做法是采用延时执行js的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title class_">Render</span>(); &#125;, <span class="number">100</span>); <span class="comment">// 延迟渲染，确保布局已完成</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法不行</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="title class_">Render</span>();&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="hexo-butterfly-主题的布局修改"><a href="#hexo-butterfly-主题的布局修改" class="headerlink" title="hexo butterfly 主题的布局修改"></a>hexo butterfly 主题的布局修改</h2><h3 id="隐藏侧边栏：Front-matter中添加"><a href="#隐藏侧边栏：Front-matter中添加" class="headerlink" title="隐藏侧边栏：Front-matter中添加"></a>隐藏侧边栏：Front-matter中添加</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aside: false</span><br></pre></td></tr></table></figure>

<p>如果要今后添加的的page或者post都隐藏侧边栏可以在模版Front-matter中添加上面的代码就行。但是已有的界面是需要自己手动添加从而实现隐藏效果。<br>scaffolds\page.md<br>scaffolds\post.md</p>
<p>若是要完全隐藏或者在特殊的page隐藏可以在butterfly.config中修改配置实现：这里好像不能添加自定义的page，不然将会省事很多。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Show the button to hide the aside in bottom right button</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Position: left / right</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">archive:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tag:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">category:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="拓宽页面内容div"><a href="#拓宽页面内容div" class="headerlink" title="拓宽页面内容div"></a>拓宽页面内容div</h3><ul>
<li>方法一：直接在md&#x2F;html&#x2F;js文件中添加js代码<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内容扩宽</span></span><br><span class="line"><span class="keyword">const</span> page = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">page.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&quot;100%&quot;</span>; <span class="comment">// 撑满屏幕</span></span><br><span class="line"><span class="comment">// page.style.setProperty(&quot;padding&quot;, &quot;160px&quot;, &quot;important&quot;);</span></span><br><span class="line">page.<span class="property">style</span>.<span class="property">padding</span> = <span class="string">&quot;86px&quot;</span>; <span class="comment">// 撑满屏幕 不加单位视为百分百</span></span><br><span class="line"><span class="keyword">const</span> content = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;content-inner&quot;</span>);</span><br><span class="line">content.<span class="property">style</span>.<span class="property">maxWidth</span> = <span class="string">&quot;100%&quot;</span>; <span class="comment">// 撑满屏幕</span></span><br><span class="line">content.<span class="property">style</span>.<span class="property">margin</span> = <span class="string">&quot;0&quot;</span>; <span class="comment">// 撑满屏幕</span></span><br><span class="line">content.<span class="property">style</span>.<span class="property">padding</span> = <span class="string">&quot;0&quot;</span>; <span class="comment">// 撑满屏幕</span></span><br></pre></td></tr></table></figure></li>
<li>方法二：直接在themes\butterfly\source\js\main.js文件中添加js代码<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内容扩宽</span></span><br><span class="line"><span class="keyword">const</span> page = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (page &amp;&amp; saveStatus == <span class="string">&#x27;hide&#x27;</span>) &#123;</span><br><span class="line">page.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&quot;100%&quot;</span>; <span class="comment">// 撑满屏幕</span></span><br><span class="line">page.<span class="property">style</span>.<span class="property">padding</span> = <span class="string">&quot;86px&quot;</span>; <span class="comment">// 撑满屏幕 不加单位视为百分百</span></span><br><span class="line"><span class="keyword">const</span> content = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;content-inner&quot;</span>);</span><br><span class="line">content.<span class="property">style</span>.<span class="property">maxWidth</span> = <span class="string">&quot;100%&quot;</span>; <span class="comment">// 撑满屏幕</span></span><br><span class="line">content.<span class="property">style</span>.<span class="property">margin</span> = <span class="string">&quot;0&quot;</span>; <span class="comment">// 撑满屏幕</span></span><br><span class="line">content.<span class="property">style</span>.<span class="property">padding</span> = <span class="string">&quot;0&quot;</span>; <span class="comment">// 撑满屏幕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>强调：<br>样式中尺寸有两种表现：百分百、具体像素值（12px）。<br>自带的标签可能会有默认样式信息，例如<code>&lt;Img&gt;</code>,若是要修改，需要使用 !important 提高当前样式的优先级</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;$&#123;project.image&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;project-cover&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.project-cover</span> &#123;</span></span><br><span class="line"><span class="language-css">     <span class="attribute">max-width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">     <span class="comment">/* 图片宽度不会超出容器宽度 */</span></span></span><br><span class="line"><span class="language-css">     <span class="attribute">max-height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">     <span class="comment">/* 图片高度不会超出容器高度 */</span></span></span><br><span class="line"><span class="language-css">     <span class="attribute">object-fit</span>: contain;</span></span><br><span class="line"><span class="language-css">     <span class="comment">/* 保持图片比例，完全显示图片 */</span></span></span><br><span class="line"><span class="language-css">     <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">     <span class="comment">/* 防止图片默认的 inline 行为 */</span></span></span><br><span class="line"><span class="language-css">     <span class="attribute">margin</span>: <span class="number">0</span> <span class="meta">!important</span>;<span class="comment">/* 防止img默认的样式覆盖，提高当前样式的优先级*/</span></span></span><br><span class="line"><span class="language-css">     <span class="comment">/* 设置外边距为零 */</span></span></span><br><span class="line"><span class="language-css">     <span class="attribute">border</span>: none;</span></span><br><span class="line"><span class="language-css">     <span class="comment">/* 移除边框 */</span></span></span><br><span class="line"><span class="language-css">   &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">page.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&quot;padding&quot;</span>, <span class="string">&quot;160px&quot;</span>, <span class="string">&quot;important&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="div中的图片居中"><a href="#div中的图片居中" class="headerlink" title="div中的图片居中"></a>div中的图片居中</h2><p>display: flex;<br>flex-direction: column;<br>align-items: center;</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.project-card</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#505050</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="comment">/* 设置为弹性布局 */</span></span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="comment">/* 子元素纵向排列 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="comment">/* 子元素水平居中 */</span></span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">4px</span> <span class="number">8px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="格子布局"><a href="#格子布局" class="headerlink" title="格子布局"></a>格子布局</h2><p><strong>总结对比</strong> </p>
<table>
<thead>
<tr>
<th>用法</th>
<th>列数</th>
<th>列宽度计算</th>
<th>剩余空间行为</th>
</tr>
</thead>
<tbody><tr>
<td>repeat(4, 1fr)</td>
<td>固定为 4 列</td>
<td>按容器宽度动态调整</td>
<td>每列均分剩余空间</td>
</tr>
<tr>
<td>repeat(auto-fit, 250px)</td>
<td>动态调整</td>
<td>固定为 250px</td>
<td>剩余空间为空白（列不会超出内容）</td>
</tr>
<tr>
<td>repeat(auto-fit, minmax(250px, 1fr))</td>
<td>动态调整</td>
<td>最小 250px，最大均分剩余空间</td>
<td>剩余空间被列均分,空列也会被均分掉</td>
</tr>
<tr>
<td>repeat(auto-fill, minmax(250px, 1fr))</td>
<td>动态调整</td>
<td>最小 250px，最大均分剩余空间</td>
<td>剩余空间被列均分，但空列会保留</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.projects</span> &#123;</span><br><span class="line">     <span class="attribute">display</span>: grid;</span><br><span class="line">     <span class="comment">/* 指定4列，每列等分容器宽度 */</span></span><br><span class="line">     <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">4</span>, <span class="number">1</span>fr); </span><br><span class="line">     <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fit, <span class="number">250px</span>);</span><br><span class="line">     <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fit, <span class="built_in">minmax</span>(<span class="number">250px</span>, <span class="number">1</span>fr));</span><br><span class="line">     <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="built_in">minmax</span>(<span class="number">250px</span>, <span class="number">1</span>fr));</span><br><span class="line">     <span class="comment">/* grid-auto-rows: 150px; */</span></span><br><span class="line">     <span class="comment">/* 每行高度固定为 150px */</span></span><br><span class="line">     <span class="attribute">gap</span>: <span class="number">20px</span>;</span><br><span class="line">     <span class="comment">/* 格子间距 20px*/</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<br>


<h2 id="auto-fit-与-auto-fill-的主要区别"><a href="#auto-fit-与-auto-fill-的主要区别" class="headerlink" title="auto-fit 与 auto-fill 的主要区别"></a><code>auto-fit</code> 与 <code>auto-fill</code> 的主要区别</h2><ul>
<li><p><strong><code>auto-fit</code></strong> : 将列压缩以适应容器宽度，仅保留有内容的列，列之间的多余空间会重新分配。</p>
</li>
<li><p><strong><code>auto-fill</code></strong> : 尽可能填满容器，即使某些列是“空的”，也会在容器内保留这些占位列。</p>
</li>
</ul>
<p><code>repeat(auto-fit, minmax(250px, 1fr))</code> </p>
<hr>
<ul>
<li>重点是“<strong>压缩列数</strong> ”：如果列宽足够，未使用的列会被移除，只有实际需要的列保留。</li>
<li>剩余空间会被现有列均分。</li>
<li>只生成实际需要的列，不创建空列。</li>
<li>列总数 &#x3D; <strong>实际内容列数</strong> 。</li>
</ul>
<br>

<p><code>repeat(auto-fill, minmax(250px, 1fr))</code> </p>
<hr>
<ul>
<li>重点是“<strong>填满容器</strong> ”：尝试创建更多列，即使其中部分列没有内容（生成“空列”作为占位）。</li>
<li>剩余空间会均分到所有列（包括空列）。</li>
<li>列总数 &#x3D; <strong>容器能容纳的最大列数</strong> 。</li>
</ul>
<br>

<p><strong>详细比较表</strong> </p>
<table>
<thead>
<tr>
<th>特性</th>
<th>auto-fit</th>
<th>auto-fill</th>
</tr>
</thead>
<tbody><tr>
<td>列数</td>
<td>根据实际内容调整列数</td>
<td>根据容器宽度填满列数</td>
</tr>
<tr>
<td>剩余空间分配</td>
<td>均分到现有列</td>
<td>均分到所有列（包括空列）</td>
</tr>
<tr>
<td>未使用的列</td>
<td>移除</td>
<td>保留为占位列</td>
</tr>
<tr>
<td>空列是否创建</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>优势</td>
<td>精简布局，适合动态内容数量，仅有实际内容需要显示时 ,移除无用列，避免产生空白列</td>
<td>容器填满，适合固定布局，需要固定网格布局（占位列）时 ,空列提供一致的布局效果</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>butterfly</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>lua 应用</title>
    <url>/2025/02/19/lua-%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>文档：</p>
<ul>
<li><a href="https://wiki.luatos.com/index.html">Luatos</a></li>
<li><a href="https://wiki.luatos.com/_static/lua53doc/contents.html">参考手册</a></li>
</ul>
<p>在 Unity 开发中，使用 Lua 进行代码热更新和补丁的方式主要有以下两种：  </p>
<h3 id="方式-1：使用-Lua-修复-C-代码中的-Bug"><a href="#方式-1：使用-Lua-修复-C-代码中的-Bug" class="headerlink" title="方式 1：使用 Lua 修复 C# 代码中的 Bug"></a><strong>方式 1：使用 Lua 修复 C# 代码中的 Bug</strong></h3><p>这种方式的核心思想是：<strong>让 C# 代码调用 Lua 代码，在 Lua 层修复 Bug，而不需要重新打包整个应用</strong>。</p>
<h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a><strong>实现流程</strong></h4><ol>
<li><p><strong>在 C# 代码中预留 Lua 调用入口</strong></p>
<ul>
<li>通过 <code>xlua</code> 或 <code>tolua</code> 框架，在 C# 中加载并执行 Lua 脚本。</li>
</ul>
</li>
<li><p><strong>在 Lua 中定义修复逻辑</strong></p>
<ul>
<li>通过 <code>xlua.hotfix</code> 或 <code>xlua.override</code> 直接修改 C# 类中的方法（xlua 方式）。</li>
<li>或者让 C# 调用 Lua 中新的修复逻辑，替换原有逻辑（tolua 方式）。</li>
</ul>
</li>
<li><p><strong>通过服务器下发新的 Lua 脚本</strong></p>
<ul>
<li>服务器发布新的修复脚本，并在客户端下载后替换老的 Lua 代码。</li>
</ul>
</li>
<li><p><strong>应用补丁</strong></p>
<ul>
<li>重新加载 Lua 代码，让修复逻辑生效，无需重新编译 C# 代码。</li>
</ul>
</li>
</ol>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h4><p><strong>C# 代码（原始代码存在 Bug）</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetDamage</span>(<span class="params"><span class="built_in">int</span> baseDamage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里的 Bug 是没有乘以攻击力系数</span></span><br><span class="line">        <span class="keyword">return</span> baseDamage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lua 代码（修复 Bug，使用 xlua.hotfix）</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">xlua.hotfix(CS.Player, <span class="string">&quot;GetDamage&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">(self, baseDamage)</span></span></span><br><span class="line">    <span class="keyword">local</span> attackMultiplier = <span class="number">1.5</span>  <span class="comment">-- 假设攻击力系数是 1.5</span></span><br><span class="line">    <span class="keyword">return</span> baseDamage * attackMultiplier</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>这样，当 <code>Player:GetDamage(100)</code> 被调用时，它会返回 <code>150</code> 而不是 <code>100</code>。</p>
<hr>
<h3 id="方式-2：直接使用-Lua-编写业务逻辑"><a href="#方式-2：直接使用-Lua-编写业务逻辑" class="headerlink" title="方式 2：直接使用 Lua 编写业务逻辑"></a><strong>方式 2：直接使用 Lua 编写业务逻辑</strong></h3><p>这种方式的核心思想是：<strong>游戏的核心逻辑使用 Lua 编写，而 C# 仅作为底层封装，处理 Unity API 调用</strong>。</p>
<h4 id="实现流程-1"><a href="#实现流程-1" class="headerlink" title="实现流程"></a><strong>实现流程</strong></h4><ol>
<li><p><strong>C# 代码提供 Lua 执行环境</strong></p>
<ul>
<li>使用 <code>xlua</code> 或 <code>tolua</code> 加载 Lua 代码。</li>
<li>C# 提供 Lua 需要调用的 API，比如物理、渲染、UI 操作等。</li>
</ul>
</li>
<li><p><strong>Lua 代码编写业务逻辑</strong></p>
<ul>
<li>主要编写游戏核心逻辑，比如角色行为、战斗计算、剧情脚本等。</li>
</ul>
</li>
<li><p><strong>通过服务器下发 Lua 更新</strong></p>
<ul>
<li>服务器发布新的 Lua 逻辑，客户端下载后直接执行。</li>
</ul>
</li>
<li><p><strong>热更新逻辑</strong></p>
<ul>
<li>通过重新加载 Lua 代码，动态修改游戏行为。</li>
</ul>
</li>
</ol>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h4><p><strong>C# 代码（加载 Lua 脚本）</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> XLua;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LuaManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> LuaEnv luaEnv = <span class="keyword">new</span> LuaEnv();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        luaEnv.DoString(<span class="string">&quot;require &#x27;GameLogic&#x27;&quot;</span>); <span class="comment">// 加载 Lua 业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        luaEnv.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lua 代码（完整的业务逻辑）</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- GameLogic.lua</span></span><br><span class="line">Player = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player:new</span><span class="params">(o, name, hp)</span></span></span><br><span class="line">    o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    <span class="built_in">setmetatable</span>(o, <span class="built_in">self</span>)</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="built_in">self</span>.name = name <span class="keyword">or</span> <span class="string">&quot;Hero&quot;</span></span><br><span class="line">    <span class="built_in">self</span>.hp = hp <span class="keyword">or</span> <span class="number">100</span></span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player:TakeDamage</span><span class="params">(damage)</span></span></span><br><span class="line">    <span class="built_in">self</span>.hp = <span class="built_in">self</span>.hp - damage</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.name .. <span class="string">&quot; takes &quot;</span> .. damage .. <span class="string">&quot; damage, HP: &quot;</span> .. <span class="built_in">self</span>.hp)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建角色</span></span><br><span class="line">hero = Player:new(<span class="literal">nil</span>, <span class="string">&quot;Knight&quot;</span>, <span class="number">200</span>)</span><br><span class="line">hero:TakeDamage(<span class="number">30</span>) <span class="comment">-- &quot;Knight takes 30 damage, HP: 170&quot;</span></span><br></pre></td></tr></table></figure>

<p>这样，如果后续需要修改 <code>TakeDamage</code> 计算规则，只需要热更新 <code>GameLogic.lua</code> 文件。</p>
<hr>
<h3 id="方式-1-和-方式-2-的区别分析"><a href="#方式-1-和-方式-2-的区别分析" class="headerlink" title="方式 1 和 方式 2 的区别分析"></a><strong>方式 1 和 方式 2 的区别分析</strong></h3><table>
<thead>
<tr>
<th></th>
<th><strong>方式 1（修复 C# Bug）</strong></th>
<th><strong>方式 2（Lua 业务逻辑）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>用途</strong></td>
<td>修复 C# 代码中的 Bug</td>
<td>直接用 Lua 编写游戏逻辑</td>
</tr>
<tr>
<td><strong>修改的灵活性</strong></td>
<td>只能修改已有 C# 代码中的 Bug</td>
<td>可以随时修改游戏玩法</td>
</tr>
<tr>
<td><strong>对 C# 依赖</strong></td>
<td>依赖原有 C# 代码</td>
<td>业务逻辑完全用 Lua 实现</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>影响较小，只修复 Bug</td>
<td>可能影响性能，Lua 运行比 C# 慢</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>小规模 Hotfix，不影响架构</td>
<td>需要长期维护、频繁调整的游戏逻辑</td>
</tr>
<tr>
<td><strong>难度</strong></td>
<td>简单，使用 <code>xlua.hotfix</code> 直接替换</td>
<td>复杂，需要设计 Lua 和 C# 交互机制</td>
</tr>
</tbody></table>
<h3 id="优劣分析"><a href="#优劣分析" class="headerlink" title="优劣分析"></a><strong>优劣分析</strong></h3><ul>
<li><p><strong>方式 1（修复 C# Bug）</strong></p>
<ul>
<li>✅ <strong>优点</strong>：改动小，不影响现有架构，热修复成本低。</li>
<li>❌ <strong>缺点</strong>：只能修补 C# 代码，不能改变大的业务逻辑。</li>
</ul>
</li>
<li><p><strong>方式 2（Lua 业务逻辑）</strong></p>
<ul>
<li>✅ <strong>优点</strong>：更新灵活，逻辑改动无需重新编译 C#，适合长周期运营的游戏。</li>
<li>❌ <strong>缺点</strong>：Lua 运行效率低于 C#，涉及大量 C# API 时可能有性能问题。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li>如果游戏已经完成开发，只是想修复 Bug，而不影响架构，<strong>方式 1（修复 C# Bug）</strong> 是更好的选择。</li>
<li>如果游戏逻辑需要频繁调整，比如策划希望快速修改数值、技能逻辑、关卡规则等，<strong>方式 2（Lua 业务逻辑）</strong> 更合适。</li>
<li>一些成熟的游戏通常<strong>结合使用</strong>：<ul>
<li><strong>C# 处理底层、性能关键的逻辑</strong>。</li>
<li><strong>Lua 负责高层业务逻辑和热更新</strong>。</li>
</ul>
</li>
</ul>
<p>你更倾向于哪种方式，或者你当前的项目有什么具体需求？</p>
<h3 id="如何在-Lua-中调用-Unity-API"><a href="#如何在-Lua-中调用-Unity-API" class="headerlink" title="如何在 Lua 中调用 Unity API"></a><strong>如何在 Lua 中调用 Unity API</strong></h3><p>在 Unity 中，Lua 不能直接调用 Unity API，而是需要 C# 提供桥接代码，把 Unity 提供的功能注册到 Lua 环境中。常见的方法有：  </p>
<ol>
<li><strong>直接映射 C# 类到 Lua（使用 <code>XLua</code> 或 <code>ToLua</code>）</strong></li>
<li><strong>通过 C# 提供 Lua 可调用的封装 API</strong></li>
<li><strong>Lua 调用 C# 事件、协程等功能</strong></li>
</ol>
<hr>
<h2 id="方法-1：直接映射-C-类到-Lua"><a href="#方法-1：直接映射-C-类到-Lua" class="headerlink" title="方法 1：直接映射 C# 类到 Lua"></a><strong>方法 1：直接映射 C# 类到 Lua</strong></h2><p><code>XLua</code> 和 <code>ToLua</code> 允许 Lua 直接调用 C# 类，无需手动绑定。例如：  </p>
<h3 id="示例：在-Lua-中使用-Unity-API-控制-GameObject"><a href="#示例：在-Lua-中使用-Unity-API-控制-GameObject" class="headerlink" title="示例：在 Lua 中使用 Unity API 控制 GameObject"></a><strong>示例：在 Lua 中使用 Unity API 控制 GameObject</strong></h3><p><strong>C# 代码（初始化 Lua 环境）</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> XLua;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LuaScriptRunner</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> LuaEnv luaEnv = <span class="keyword">new</span> LuaEnv();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        luaEnv.DoString(<span class="string">@&quot;</span></span><br><span class="line"><span class="string">            local obj = CS.UnityEngine.GameObject(&#x27;LuaCreatedObject&#x27;)</span></span><br><span class="line"><span class="string">            obj.transform.position = CS.UnityEngine.Vector3(1, 2, 3)</span></span><br><span class="line"><span class="string">            print(&#x27;GameObject created at:&#x27;, obj.transform.position)</span></span><br><span class="line"><span class="string">        &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        luaEnv.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Lua 代码（直接调用 Unity API）</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> obj = CS.UnityEngine.GameObject(<span class="string">&quot;MyObject&quot;</span>)</span><br><span class="line">obj.transform.position = CS.UnityEngine.Vector3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>✅ 这里 <code>CS.UnityEngine.GameObject</code> 让 Lua 直接访问 Unity 的 <code>GameObject</code> API。</p>
<hr>
<h2 id="方法-2：通过-C-提供-Lua-可调用的封装-API"><a href="#方法-2：通过-C-提供-Lua-可调用的封装-API" class="headerlink" title="方法 2：通过 C# 提供 Lua 可调用的封装 API"></a><strong>方法 2：通过 C# 提供 Lua 可调用的封装 API</strong></h2><p>有时，我们不想让 Lua 直接访问 Unity API，而是通过 C# 提供更安全的接口。例如：</p>
<h3 id="示例：Lua-控制角色移动"><a href="#示例：Lua-控制角色移动" class="headerlink" title="示例：Lua 控制角色移动"></a><strong>示例：Lua 控制角色移动</strong></h3><p><strong>C# 代码（提供 Lua 可调用的 API）</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> XLua;</span><br><span class="line"></span><br><span class="line">[<span class="meta">LuaCallCSharp</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params">Vector3 direction</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.position += direction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Lua 代码（通过封装 API 控制角色）</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> player = CS.UnityEngine.GameObject.Find(<span class="string">&quot;Player&quot;</span>):GetComponent(<span class="string">&quot;PlayerController&quot;</span>)</span><br><span class="line">player:Move(CS.UnityEngine.Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)) <span class="comment">-- 让角色向上移动 1 单位</span></span><br></pre></td></tr></table></figure>
<p>✅ 这样可以控制哪些 Unity 功能暴露给 Lua，增强安全性。</p>
<hr>
<h2 id="方法-3：Lua-调用-C-事件、协程等"><a href="#方法-3：Lua-调用-C-事件、协程等" class="headerlink" title="方法 3：Lua 调用 C# 事件、协程等"></a><strong>方法 3：Lua 调用 C# 事件、协程等</strong></h2><p><strong>示例：在 Lua 中等待 2 秒后执行代码</strong><br><strong>C# 代码（封装协程供 Lua 使用）</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> XLua;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line">[<span class="meta">LuaCallCSharp</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CoroutineHelper</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartLuaCoroutine</span>(<span class="params">LuaFunction luaFunc</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(RunLuaCoroutine(luaFunc));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">RunLuaCoroutine</span>(<span class="params">LuaFunction luaFunc</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">2</span></span>)</span>;</span><br><span class="line">        luaFunc.Call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Lua 代码（使用 C# 协程等待 2 秒）</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> coroutineHelper = CS.UnityEngine.GameObject.Find(<span class="string">&quot;CoroutineHelper&quot;</span>):GetComponent(<span class="string">&quot;CoroutineHelper&quot;</span>)</span><br><span class="line"></span><br><span class="line">coroutineHelper:StartLuaCoroutine(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Waited 2 seconds!&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>✅ 让 Lua 使用 Unity 的协程系统，避免性能问题。</p>
<hr>
<h2 id="Lua-在-Unity-中的应用场景"><a href="#Lua-在-Unity-中的应用场景" class="headerlink" title="Lua 在 Unity 中的应用场景"></a><strong>Lua 在 Unity 中的应用场景</strong></h2><h3 id="1-游戏逻辑热更新"><a href="#1-游戏逻辑热更新" class="headerlink" title="1. 游戏逻辑热更新"></a>1. <strong>游戏逻辑热更新</strong></h3><ul>
<li>业务逻辑（如技能计算、AI 逻辑）用 Lua 编写，随时热更新，无需重新打包。</li>
<li>C# 提供 Lua 执行环境，保障性能关键部分运行稳定。</li>
</ul>
<h3 id="2-策划配置驱动"><a href="#2-策划配置驱动" class="headerlink" title="2. 策划配置驱动"></a>2. <strong>策划配置驱动</strong></h3><ul>
<li>策划用 Lua 编写关卡、技能、任务逻辑。</li>
<li>例如，<code>QuestSystem.lua</code> 定义任务逻辑，修改 Lua 文件即可调整任务规则。</li>
</ul>
<h3 id="3-UI-逻辑"><a href="#3-UI-逻辑" class="headerlink" title="3. UI 逻辑"></a>3. <strong>UI 逻辑</strong></h3><ul>
<li>C# 处理 UI 渲染，Lua 负责 UI 交互逻辑。</li>
<li>例如：<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> button = CS.UnityEngine.GameObject.Find(<span class="string">&quot;StartButton&quot;</span>):GetComponent(<span class="string">&quot;Button&quot;</span>)</span><br><span class="line">button.onClick:AddListener(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&quot;Game Start!&quot;</span>) <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-AI-行为树"><a href="#4-AI-行为树" class="headerlink" title="4. AI 行为树"></a>4. <strong>AI 行为树</strong></h3><ul>
<li>Lua 负责 AI 逻辑，C# 提供行为接口。</li>
<li>例如：<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Enemy:Update</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">self</span>.hp &lt; <span class="number">50</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">self</span>:Retreat()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">self</span>:Attack()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-战斗系统"><a href="#5-战斗系统" class="headerlink" title="5. 战斗系统"></a>5. <strong>战斗系统</strong></h3><ul>
<li>服务器下发新的 Lua 脚本，实现技能调整，而不用修改 C# 代码。</li>
</ul>
<h1 id="学习笔记-点号-和冒号-的主要区别"><a href="#学习笔记-点号-和冒号-的主要区别" class="headerlink" title="学习笔记- 点号 (.) 和冒号 (:) 的主要区别"></a>学习笔记- <strong>点号 (<code>.</code>) 和冒号 (<code>:</code>)</strong> 的主要区别</h1><p>在 Lua 里，<strong>点号 (<code>.</code>) 和冒号 (<code>:</code>)</strong> 的主要区别在于**方法调用时是否隐式传递 <code>self</code>**。它们的使用方式如下：</p>
<hr>
<h2 id="1-（点号）——-直接访问表中的字段或函数"><a href="#1-（点号）——-直接访问表中的字段或函数" class="headerlink" title="1. .（点号）—— 直接访问表中的字段或函数"></a><strong>1. <code>.</code>（点号）—— 直接访问表中的字段或函数</strong></h2><ul>
<li>适用于<strong>普通函数</strong>，调用时需要<strong>手动传递 <code>self</code>（如果需要）</strong></li>
<li>直接访问表中的属性或函数，不自动传递 <code>self</code></li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> MyClass = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass.sayHello</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> .. <span class="built_in">self</span>.name)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建对象</span></span><br><span class="line"><span class="keyword">local</span> obj = &#123; name = <span class="string">&quot;Lua&quot;</span> &#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(obj, &#123; <span class="built_in">__index</span> = MyClass &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 `.` 访问方法时，需要手动传递 `self`</span></span><br><span class="line">MyClass.sayHello(obj)  <span class="comment">-- ✅ 输出: Hello, Lua</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong></p>
<ul>
<li><code>MyClass.sayHello(obj)</code> 需要<strong>手动传递 <code>obj</code></strong> 作为 <code>self</code>。</li>
</ul>
<hr>
<h2 id="2-（冒号）——-语法糖，自动传递-self"><a href="#2-（冒号）——-语法糖，自动传递-self" class="headerlink" title="2. :（冒号）—— 语法糖，自动传递 self"></a><strong>2. <code>:</code>（冒号）—— 语法糖，自动传递 <code>self</code></strong></h2><ul>
<li><strong>方法调用</strong>专用</li>
<li><code>obj:method(...)</code> 等价于 <code>obj.method(obj, ...)</code></li>
<li><strong>自动传递 <code>self</code> 参数</strong></li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> MyClass = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass:sayHello</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> .. <span class="built_in">self</span>.name)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建对象</span></span><br><span class="line"><span class="keyword">local</span> obj = &#123; name = <span class="string">&quot;Lua&quot;</span> &#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(obj, &#123; <span class="built_in">__index</span> = MyClass &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 `:` 访问方法，会自动传递 `self`</span></span><br><span class="line">obj:sayHello()  <span class="comment">-- ✅ 输出: Hello, Lua</span></span><br></pre></td></tr></table></figure>
<p><strong>等价于</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">obj.sayHello(obj)</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong></p>
<ul>
<li><code>obj:sayHello()</code> 自动将 <code>obj</code> 作为 <code>self</code> 传入，无需手动传递。</li>
</ul>
<hr>
<h2 id="3-点号-vs-冒号-的区别总结"><a href="#3-点号-vs-冒号-的区别总结" class="headerlink" title="3. 点号 . vs. 冒号 : 的区别总结"></a><strong>3. 点号 <code>.</code> vs. 冒号 <code>:</code> 的区别总结</strong></h2><table>
<thead>
<tr>
<th></th>
<th><strong>点号 <code>.</code></strong></th>
<th><strong>冒号 <code>:</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>访问表的字段或函数</td>
<td>调用方法，并自动传 <code>self</code></td>
</tr>
<tr>
<td><strong>是否传 <code>self</code></strong></td>
<td>需要手动传递</td>
<td>自动传递</td>
</tr>
<tr>
<td><strong>常见错误</strong></td>
<td>忘记传 <code>self</code>，导致 <code>nil</code> 错误</td>
<td>不适用于非方法的情况</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td><code>obj.func(obj, ...)</code></td>
<td><code>obj:func(...)</code> (等价于 <code>obj.func(obj, ...)</code>)</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-常见错误"><a href="#4-常见错误" class="headerlink" title="4. 常见错误"></a><strong>4. 常见错误</strong></h2><h3 id="❌-使用-调用方法但忘记-self"><a href="#❌-使用-调用方法但忘记-self" class="headerlink" title="❌ 使用 . 调用方法但忘记 self"></a><strong>❌ 使用 <code>.</code> 调用方法但忘记 <code>self</code></strong></h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">obj.sayHello()  <span class="comment">-- ❌ 报错: attempt to concatenate a nil value</span></span><br></pre></td></tr></table></figure>
<p><strong>正确做法</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">obj.sayHello(obj)  <span class="comment">-- ✅ 手动传递 self</span></span><br><span class="line">obj:sayHello()  <span class="comment">-- ✅ 推荐：用 `:` 语法糖</span></span><br></pre></td></tr></table></figure>

<h3 id="❌-使用-调用普通函数"><a href="#❌-使用-调用普通函数" class="headerlink" title="❌ 使用 : 调用普通函数"></a><strong>❌ 使用 <code>:</code> 调用普通函数</strong></h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span><span class="params">(name)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> .. name)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">greet:(<span class="string">&quot;Lua&quot;</span>)  <span class="comment">-- ❌ 报错: attempt to index a function value</span></span><br></pre></td></tr></table></figure>
<p><strong>正确做法</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">greet(<span class="string">&quot;Lua&quot;</span>)  <span class="comment">-- ✅</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a><strong>5. 结论</strong></h2><ul>
<li><strong>点号 <code>.</code></strong> 用于<strong>普通函数调用</strong>，需要手动传 <code>self</code></li>
<li><strong>冒号 <code>:</code></strong> 用于<strong>方法调用</strong>，会自动传 <code>self</code>，推荐使用</li>
<li><strong>推荐：方法定义时使用 <code>:</code>，调用时也使用 <code>:</code>，避免 <code>self</code> 传递错误</strong></li>
</ul>
<p><strong>✅ 推荐写法</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass:sayHello</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> .. <span class="built_in">self</span>.name)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">obj:sayHello()  <span class="comment">-- 自动传递 self</span></span><br></pre></td></tr></table></figure>

<p>希望这个解释清楚了 <code>.</code> 和 <code>:</code> 的区别！😃</p>
<h1 id="lua-与-C-差异"><a href="#lua-与-C-差异" class="headerlink" title="lua 与 C#差异"></a>lua 与 C#差异</h1><p>Lua 和 C# 在语法上的主要区别体现在<strong>变量声明、数据类型、控制流、函数定义、面向对象编程（OOP）、错误处理</strong>等方面。以下是它们的主要差异分析：</p>
<hr>
<h2 id="1-变量与数据类型"><a href="#1-变量与数据类型" class="headerlink" title="1. 变量与数据类型"></a><strong>1. 变量与数据类型</strong></h2><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a><strong>Lua</strong></h3><ul>
<li><strong>动态类型</strong>（变量的类型由赋值决定）</li>
<li><strong>变量不需要声明类型</strong></li>
<li><strong><code>nil</code> 代表未初始化的变量</strong></li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span>        <span class="comment">-- 自动推断为 number</span></span><br><span class="line">y = <span class="string">&quot;hello&quot;</span>   <span class="comment">-- 自动推断为 string</span></span><br><span class="line">z = <span class="literal">nil</span>       <span class="comment">-- nil 表示变量未赋值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(x))  <span class="comment">-- 输出: number</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(y))  <span class="comment">-- 输出: string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(z))  <span class="comment">-- 输出: nil</span></span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C#"></a><strong>C#</strong></h3><ul>
<li><strong>静态类型</strong>（变量类型必须明确）</li>
<li><strong>变量必须声明类型</strong></li>
<li><strong><code>null</code> 代表引用类型未初始化</strong></li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">10</span>;         <span class="comment">// 明确类型</span></span><br><span class="line"><span class="built_in">string</span> y = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 明确类型</span></span><br><span class="line"><span class="built_in">object</span> z = <span class="literal">null</span>;    <span class="comment">// null 表示引用为空</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(x.GetType());  <span class="comment">// 输出: System.Int32</span></span><br><span class="line">Console.WriteLine(y.GetType());  <span class="comment">// 输出: System.String</span></span><br><span class="line">Console.WriteLine(z == <span class="literal">null</span>);    <span class="comment">// 输出: True</span></span><br></pre></td></tr></table></figure>

<p>✅ <strong>区别</strong>：</p>
<ul>
<li>Lua <strong>不需要声明变量类型</strong>，C# 需要。</li>
<li>Lua <strong>变量默认是全局的</strong>（除非加 <code>local</code>），C# 变量有作用域控制。</li>
</ul>
<hr>
<h2 id="2-变量作用域"><a href="#2-变量作用域" class="headerlink" title="2. 变量作用域"></a><strong>2. 变量作用域</strong></h2><h3 id="Lua-1"><a href="#Lua-1" class="headerlink" title="Lua"></a><strong>Lua</strong></h3><ul>
<li>默认变量是<strong>全局变量</strong></li>
<li><strong>局部变量</strong>需要 <code>local</code> 关键字</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span>      <span class="comment">-- 全局变量</span></span><br><span class="line"><span class="keyword">local</span> y = <span class="number">20</span>  <span class="comment">-- 局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> z = <span class="number">30</span>  <span class="comment">-- 局部变量</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a><strong>C#</strong></h3><ul>
<li>变量<strong>默认是局部变量</strong></li>
<li>作用域由 <code>&#123;&#125;</code> 控制</li>
<li><code>public</code>、<code>private</code> 控制访问权限</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">10</span>;  <span class="comment">// 局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> y = <span class="number">20</span>;  <span class="comment">// 类的私有变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅ <strong>区别</strong>：</p>
<ul>
<li>Lua 默认是<strong>全局变量</strong>，C# 默认是<strong>局部变量</strong>。</li>
<li>Lua 需要 <code>local</code> 声明局部变量，而 C# 直接在方法&#x2F;类内定义即可。</li>
</ul>
<hr>
<h2 id="3-控制流"><a href="#3-控制流" class="headerlink" title="3. 控制流"></a><strong>3. 控制流</strong></h2><h3 id="Lua-2"><a href="#Lua-2" class="headerlink" title="Lua"></a><strong>Lua</strong></h3><ul>
<li><code>if</code> 语句中<strong>必须显式写 <code>then</code> 和 <code>end</code></strong></li>
<li><code>elseif</code> <strong>是一个单词</strong></li>
<li><code>for</code> 语句有<strong>数值 <code>for</code> 和泛型 <code>for</code></strong></li>
<li><code>repeat...until</code> 类似 <code>do...while</code></li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">5</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x 大于 5&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> x == <span class="number">5</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x 等于 5&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x 小于 5&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="C-2"><a href="#C-2" class="headerlink" title="C#"></a><strong>C#</strong></h3><ul>
<li><code>if</code> 语句<strong>不需要 <code>then</code> 和 <code>end</code></strong></li>
<li><code>else if</code> 是<strong>两个单词</strong></li>
<li><code>for</code> 语句只能使用索引计数或 <code>foreach</code></li>
<li><code>do...while</code> 语法与 <code>while</code> 类似</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;x 大于 5&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">5</span>) &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;x 等于 5&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;x 小于 5&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅ <strong>区别</strong>：</p>
<ul>
<li>Lua 需要 <code>then</code> 和 <code>end</code>，C# 需要 <code>&#123;&#125;</code>。</li>
<li>Lua 用 <code>elseif</code>，C# 用 <code>else if</code>。</li>
</ul>
<hr>
<h2 id="4-循环"><a href="#4-循环" class="headerlink" title="4. 循环"></a><strong>4. 循环</strong></h2><h3 id="Lua-3"><a href="#Lua-3" class="headerlink" title="Lua"></a><strong>Lua</strong></h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 泛型 for 遍历表</span></span><br><span class="line">t = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> &#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k, v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="C-3"><a href="#C-3" class="headerlink" title="C#"></a><strong>C#</strong></h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    Console.WriteLine(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="built_in">string</span>[] t = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> t) &#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅ <strong>区别</strong>：</p>
<ul>
<li>Lua <code>for</code> 语句用 <code>do...end</code>，C# 用 <code>&#123;&#125;</code>。</li>
<li>Lua <code>for</code> 可以直接遍历表，C# 使用 <code>foreach</code>。</li>
</ul>
<hr>
<h2 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a><strong>5. 函数</strong></h2><h3 id="Lua-4"><a href="#Lua-4" class="headerlink" title="Lua"></a><strong>Lua</strong></h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">5</span>))  <span class="comment">-- 输出: 8</span></span><br></pre></td></tr></table></figure>

<h3 id="C-4"><a href="#C-4" class="headerlink" title="C#"></a><strong>C#</strong></h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(Add(<span class="number">3</span>, <span class="number">5</span>));  <span class="comment">// 输出: 8</span></span><br></pre></td></tr></table></figure>

<p>✅ <strong>区别</strong>：</p>
<ul>
<li>Lua <strong>不需要声明返回值类型</strong>，C# 需要。</li>
<li>C# <strong>必须写 <code>return</code> 类型</strong>，Lua 没有强制要求。</li>
</ul>
<hr>
<h2 id="6-面向对象"><a href="#6-面向对象" class="headerlink" title="6. 面向对象"></a><strong>6. 面向对象</strong></h2><h3 id="Lua-5"><a href="#Lua-5" class="headerlink" title="Lua"></a><strong>Lua</strong></h3><ul>
<li>没有类和对象的原生概念，但可以用 <code>table</code> + <code>metatable</code> 实现<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Person = &#123;&#125;</span><br><span class="line">Person.<span class="built_in">__index</span> = Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person:new</span><span class="params">(name)</span></span></span><br><span class="line">    <span class="keyword">local</span> obj = <span class="built_in">setmetatable</span>(&#123;&#125;, <span class="built_in">self</span>)</span><br><span class="line">    obj.name = name</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person:sayHello</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, my name is &quot;</span> .. <span class="built_in">self</span>.name)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> p = Person:new(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">p:sayHello()  <span class="comment">-- 输出: Hello, my name is Alice</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="C-5"><a href="#C-5" class="headerlink" title="C#"></a><strong>C#</strong></h3><ul>
<li>直接支持类和对象<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span> &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello, my name is &quot;</span> + Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">p.SayHello();  <span class="comment">// 输出: Hello, my name is Alice</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>✅ <strong>区别</strong>：</p>
<ul>
<li>Lua <strong>没有类</strong>，但可以用 <code>table</code> + <code>metatable</code> 实现。</li>
<li>C# 直接支持类，语法更清晰。</li>
</ul>
<hr>
<h2 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a><strong>7. 错误处理</strong></h2><h3 id="Lua-6"><a href="#Lua-6" class="headerlink" title="Lua"></a><strong>Lua</strong></h3><ul>
<li>使用 <code>pcall</code> 或 <code>xpcall</code> 捕获错误<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorFunc</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&quot;发生错误！&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">status</span>, err = <span class="built_in">pcall</span>(errorFunc)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">status</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;捕获错误：&quot;</span> .. err)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="C-6"><a href="#C-6" class="headerlink" title="C#"></a><strong>C#</strong></h3><ul>
<li>使用 <code>try-catch</code> 处理异常<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;发生错误！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;捕获错误：&quot;</span> + ex.Message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>✅ <strong>区别</strong>：</p>
<ul>
<li>Lua 用 <code>pcall</code> 进行错误捕获，C# 用 <code>try-catch</code>。</li>
<li>C# 的异常系统更强大，支持不同类型的异常。</li>
</ul>
<hr>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Lua</strong></th>
<th><strong>C#</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型</strong></td>
<td>动态类型</td>
<td>静态类型</td>
</tr>
<tr>
<td><strong>变量作用域</strong></td>
<td>默认全局，需 <code>local</code></td>
<td>默认局部</td>
</tr>
<tr>
<td><strong>控制流</strong></td>
<td><code>then...end</code> 语法</td>
<td><code>&#123;&#125;</code> 语法</td>
</tr>
<tr>
<td><strong>循环</strong></td>
<td><code>for i = 1, 10 do</code></td>
<td><code>for (int i = 1; i &lt;= 10; i++)</code></td>
</tr>
<tr>
<td><strong>函数</strong></td>
<td><code>function f()</code></td>
<td><code>int Func()</code></td>
</tr>
<tr>
<td><strong>OOP</strong></td>
<td><code>table</code> + <code>metatable</code></td>
<td>直接支持 <code>class</code></td>
</tr>
<tr>
<td><strong>错误处理</strong></td>
<td><code>pcall(x)</code></td>
<td><code>try-catch</code></td>
</tr>
</tbody></table>
<p>总的来说，<strong>Lua 更轻量、灵活，C# 更强大、结构化</strong>。</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>Lua 使用 <code>string.gsub</code>、<code>string.find</code>、<code>string.match</code> 等函数支持<strong>模式匹配（Pattern Matching）</strong>，这类似于正则表达式，但 Lua 使用的是<strong>独特的模式匹配规则</strong>，并不完全兼容标准正则表达式。  </p>
<hr>
<h2 id="1-基本字符匹配规则"><a href="#1-基本字符匹配规则" class="headerlink" title="1. 基本字符匹配规则"></a><strong>1. 基本字符匹配规则</strong></h2><p>Lua 的模式匹配支持以下特殊字符：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>匹配任意单个字符（换行符 <code>\n</code> 除外）</td>
</tr>
<tr>
<td><code>%a</code></td>
<td>匹配任意字母（A-Z, a-z）</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>匹配任意数字（0-9）</td>
</tr>
<tr>
<td><code>%l</code></td>
<td>匹配小写字母（a-z）</td>
</tr>
<tr>
<td><code>%u</code></td>
<td>匹配大写字母（A-Z）</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>匹配空白字符（空格、制表符、换行）</td>
</tr>
<tr>
<td><code>%w</code></td>
<td>匹配字母+数字（A-Z, a-z, 0-9）</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>匹配十六进制字符（0-9, A-F, a-f）</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>匹配控制字符（如 <code>\n</code>、<code>\t</code>）</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>匹配标点符号（如 <code>.,!?</code>）</td>
</tr>
<tr>
<td><code>%z</code></td>
<td>匹配 <code>\0</code>（null 字符）</td>
</tr>
<tr>
<td><code>%f[set]</code></td>
<td>匹配 <code>set</code> 定义的<strong>边界</strong></td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&quot;hello 123&quot;</span>, <span class="string">&quot;%a+&quot;</span>))  <span class="comment">--&gt; hello</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&quot;hello 123&quot;</span>, <span class="string">&quot;%d+&quot;</span>))  <span class="comment">--&gt; 123</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-转义特殊字符"><a href="#2-转义特殊字符" class="headerlink" title="2. 转义特殊字符"></a><strong>2. 转义特殊字符</strong></h2><p>Lua 使用 <code>%</code> 作为转义符，而不是 <code>\</code>：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>%.</code></td>
<td>匹配 <code>.</code></td>
</tr>
<tr>
<td><code>%+</code></td>
<td>匹配 <code>+</code></td>
</tr>
<tr>
<td><code>%*</code></td>
<td>匹配 <code>*</code></td>
</tr>
<tr>
<td><code>%?</code></td>
<td>匹配 <code>?</code></td>
</tr>
<tr>
<td><code>%(</code>, <code>%)</code></td>
<td>匹配 <code>()</code></td>
</tr>
<tr>
<td><code>%[</code> , <code>%]</code></td>
<td>匹配 <code>[]</code></td>
</tr>
<tr>
<td><code>%^</code></td>
<td>匹配 <code>^</code></td>
</tr>
<tr>
<td><code>%$</code></td>
<td>匹配 <code>$</code></td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&quot;3+2=5&quot;</span>, <span class="string">&quot;%d+%+%d+&quot;</span>))  <span class="comment">--&gt; 3+2</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-量词匹配"><a href="#3-量词匹配" class="headerlink" title="3. 量词匹配"></a><strong>3. 量词匹配</strong></h2><table>
<thead>
<tr>
<th>量词</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td><strong>匹配 1 次或多次</strong></td>
</tr>
<tr>
<td><code>*</code></td>
<td><strong>匹配 0 次或多次</strong></td>
</tr>
<tr>
<td><code>?</code></td>
<td><strong>匹配 0 次或 1 次</strong></td>
</tr>
<tr>
<td><code>&#123;n,m&#125;</code></td>
<td><strong>匹配 n 到 m 次（Lua 不支持）</strong></td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&quot;abc123xyz&quot;</span>, <span class="string">&quot;%a+&quot;</span>))  <span class="comment">--&gt; abc</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&quot;abc123xyz&quot;</span>, <span class="string">&quot;%d*&quot;</span>))  <span class="comment">--&gt; （空字符串）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&quot;abc123xyz&quot;</span>, <span class="string">&quot;%d+&quot;</span>))  <span class="comment">--&gt; 123</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-定义字符集"><a href="#4-定义字符集" class="headerlink" title="4. 定义字符集"></a><strong>4. 定义字符集</strong></h2><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>[xyz]</code></td>
<td>匹配 <code>x</code>、<code>y</code> 或 <code>z</code></td>
</tr>
<tr>
<td><code>[^xyz]</code></td>
<td><strong>匹配非</strong> <code>x</code>、<code>y</code>、<code>z</code> 的字符</td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td><strong>匹配 a-z 之间的字符</strong></td>
</tr>
<tr>
<td><code>[A-Z0-9]</code></td>
<td><strong>匹配大写字母或数字</strong></td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&quot;Lua 5.4&quot;</span>, <span class="string">&quot;[0-9]+&quot;</span>))  <span class="comment">--&gt; 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&quot;Hello!&quot;</span>, <span class="string">&quot;[^aeiou]+&quot;</span>))  <span class="comment">--&gt; H</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-捕获（提取匹配部分）"><a href="#5-捕获（提取匹配部分）" class="headerlink" title="5. 捕获（提取匹配部分）"></a><strong>5. 捕获（提取匹配部分）</strong></h2><table>
<thead>
<tr>
<th>规则</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>(pattern)</code></td>
<td><strong>捕获</strong>匹配的内容</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> word, number = <span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&quot;abc123&quot;</span>, <span class="string">&quot;(%a+)(%d+)&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(word, number)  <span class="comment">--&gt; abc 123</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-搜索与替换"><a href="#6-搜索与替换" class="headerlink" title="6. 搜索与替换"></a><strong>6. 搜索与替换</strong></h2><p>Lua 提供 <code>string.gsub</code> 进行替换：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> s = <span class="string">&quot;Hello 123 Lua 456&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">gsub</span>(s, <span class="string">&quot;%d+&quot;</span>, <span class="string">&quot;#&quot;</span>))  <span class="comment">--&gt; Hello # Lua #</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-锚点匹配"><a href="#7-锚点匹配" class="headerlink" title="7. 锚点匹配"></a><strong>7. 锚点匹配</strong></h2><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td><strong>匹配字符串开头</strong></td>
</tr>
<tr>
<td><code>$</code></td>
<td><strong>匹配字符串结尾</strong></td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;^Hello&quot;</span>))  <span class="comment">--&gt; Hello</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;World$&quot;</span>))  <span class="comment">--&gt; World</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-string-find、string-match、string-gsub-区别"><a href="#8-string-find、string-match、string-gsub-区别" class="headerlink" title="8. string.find、string.match、string.gsub 区别"></a><strong>8. <code>string.find</code>、<code>string.match</code>、<code>string.gsub</code> 区别</strong></h2><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>string.find(s, pattern)</code></td>
<td><strong>查找匹配的位置</strong></td>
</tr>
<tr>
<td><code>string.match(s, pattern)</code></td>
<td><strong>提取第一个匹配</strong></td>
</tr>
<tr>
<td><code>string.gsub(s, pattern, replace)</code></td>
<td><strong>替换</strong></td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> s = <span class="string">&quot;Hello Lua 123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(s, <span class="string">&quot;%a+&quot;</span>))  <span class="comment">--&gt; 1 5 （返回匹配位置）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">match</span>(s, <span class="string">&quot;%a+&quot;</span>))  <span class="comment">--&gt; Hello （返回匹配文本）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">gsub</span>(s, <span class="string">&quot;%a+&quot;</span>, <span class="string">&quot;#&quot;</span>))  <span class="comment">--&gt; # # 123</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul>
<li><strong>Lua 的模式匹配类似正则表达式，但不是标准正则</strong>，常用于字符串查找、替换等操作。</li>
<li><strong>不支持 <code>&#123;n,m&#125;</code> 这样的精确匹配</strong>，但可以用 <code>string.rep</code> 变通实现。</li>
<li><strong>使用 <code>()</code> 进行捕获，用 <code>string.gsub</code> 进行替换</strong>，效率较高。</li>
<li><strong>不支持 <code>\d</code> 这样的正则格式，而是 <code>%d</code> 代替</strong>。</li>
</ul>
<p>如果需要更强的正则功能，可以结合 <strong>PCRE（Lua 正则库）</strong> 进行扩展。</p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><ul>
<li>默认变量是全局变量<ul>
<li>local 本地变量</li>
</ul>
</li>
<li>未赋值的为 <strong>nil</strong></li>
<li>可以同时赋值a,v&#x3D;1,2</li>
<li>只有一种类型number：支持16进制、科学计数法2e10、次方</li>
<li>单引号 (‘) 和双引号 (“) 本质上是等价的，都用于表示字符串。</li>
<li>可以同时打印多个变量</li>
<li>多行文本[[   ]]</li>
<li>单行注释–<ul>
<li><p>多行注释推荐使用 –[&#x3D;[注释内容]&#x3D;]，这样可以避免遇到table[table[idx]]时就将多行注释结束了。</p>
</li>
<li><p>多行注释加 - 取消注释中间代码可以继续运行，单行注释没有此功能。</p>
<p>—[[<br>print(‘取消多行注释’)<br>–]]</p>
</li>
<li><p>多行<br>–[[</p>
</li>
</ul>
</li>
</ul>
<p> 多行注释<br> 多行注释<br> –]]</p>
<ul>
<li><p>字符串连接符..</p>
<ul>
<li><p>如果有大量字符串拼接，建议使用 table.concat，性能更优：</p>
<p>local words &#x3D; { “Hello”, “ “, “World”, “!” }</p>
<p>local result &#x3D; table.concat(words)</p>
</li>
</ul>
</li>
<li><p>Lua 函数不需要声明返回值类型和参数类型</p>
</li>
<li><p>没有类和对象的原生概念，但可以用 table + metatable 实现</p>
</li>
<li><p>最好不要使用下划线加大写字母的标识符，因为Lua的保留字也是这样的。</p>
</li>
<li><p>表：标识符可以使用<code>.</code>或<code>[&quot;&quot;]</code>访问，如果标识符包含特殊字符（如空格），必须用 <code>[&quot;&quot;]</code> 访问。整数作为下标、字符串作为下标</p>
<p>  local person &#x3D; {<br>  name &#x3D; “Alice”,<br>  age as &#x3D; 25<br>  }</p>
<p>  print(person.name)  – Alice</p>
<p>  print(person[“age as”])  – 25</p>
</li>
<li><p>在面向对象（OOP）编程时，self 代表当前对象。</p>
</li>
<li><p>标识符：</p>
<ul>
<li>and or not	逻辑运算</li>
<li>if elseif else then end	条件判断</li>
<li>for while repeat until	循环结构</li>
<li>function return	定义函数、返回值</li>
<li>local	变量作用域  用于代码块中</li>
<li>nil true false	变量值</li>
<li>do end	代码块</li>
<li>goto	代码跳转</li>
</ul>
</li>
<li><p>数组</p>
<ol>
<li>nil会中断数组下标和长度吗？</li>
<li>for循环不能遍历小于等于零的索引</li>
<li>不能遍历到不连续索引</li>
<li>数组下标开始值为1</li>
<li>#获取数组长度</li>
</ol>
</li>
<li><p>for循环中 index值不能修改</p>
<p>  for i&#x3D;10,1,-1 do </p>
<p>  print(i)</p>
<p>  end</p>
</li>
<li><p>_G全局表：存放全局变量</p>
</li>
<li><p>0为ture</p>
</li>
<li><p>只有nil 和false 为假</p>
</li>
<li><p>不支持自增自减操作</p>
</li>
<li><p>不等于：~&#x3D;     等于：&#x3D;&#x3D;</p>
</li>
<li><p>交换  a,b&#x3D;b,a</p>
</li>
<li><p>函数：</p>
<ol>
<li>不支持重载,支持重写</li>
<li>函数变长参数…需要内部用表接收｛…｝才能使用</li>
<li>闭包 函数嵌套 外层函数的参数被嵌套的函数使用时,延长生命周期  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a=<span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--等价</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Showa</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>  实际lua游戏项目中，绑定监听事件需要使用闭包捕获完整信息</p>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">一、（直接内联）：</span><br><span class="line">✅ 优点：快速实现功能 ❌ 缺点：如果逻辑变复杂，代码会臃肿，难以调试或扩展</span><br><span class="line">    UIEvent.AddDropdownValueChange(<span class="built_in">self</span>.Dropdown.transform,</span><br><span class="line">            <span class="function"><span class="keyword">function</span><span class="params">(index)</span></span></span><br><span class="line">                <span class="built_in">log</span>(<span class="string">&quot;OnToggleValueChange_&quot;</span> .. index)</span><br><span class="line">            <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二、建议写法（封装成独立方法）：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SetUpSoundView:OnDropdownValueChanged</span><span class="params">(index)</span></span></span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;OnToggleValueChange_&quot;</span> .. index)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">✅ 优点：</span><br><span class="line">逻辑分离，便于调试</span><br><span class="line">可以在多个地方复用 OnDropdownValueChanged</span><br><span class="line">更清晰地表达意图（命名函数）</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 绑定时：</span></span><br><span class="line">UIEvent.AddDropdownValueChange(<span class="built_in">self</span>.Dropdown.transform, <span class="function"><span class="keyword">function</span><span class="params">(index)</span></span></span><br><span class="line">    <span class="built_in">self</span>:OnDropdownValueChanged(index)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">三、❌而不是采用：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SetUpSoundView:OnDropdownValueChanged</span><span class="params">(k)</span></span></span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;OnToggleValueChange_&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">UIEvent.AddDropdownValueChange(<span class="built_in">self</span>.Dropdown.transform, <span class="built_in">self</span>.OnDropdownValueChanged)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>return  可以返回多个值用逗号隔开</p>
</li>
<li><p>Lua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table。</p>
<ul>
<li>userdata	表示任意存储在变量中的C数据结构</li>
<li>number	表示双精度类型的实浮点数</li>
</ul>
</li>
<li><p>文件调用：require(“路径.文件名”)</p>
<ul>
<li>不带拓展名  </li>
<li>只会调用一次，<strong>即使多次调用都是返回的第一次调用的值</strong></li>
<li>从package.path中查找，我们可以提前使用字符串拼接，将新路径加载到该字段中，调用时就不用指定路径了</li>
<li>Package.loaded(xx)判断require加载的文件是否被夹在.  Package.loaded(xx)&#x3D;nil卸载资源</li>
</ul>
</li>
<li><p>loadstring &#x2F; load 只是编译代码，不会立即执行。<strong>需要显式调用返回的函数才能执行代码</strong>。</p>
<ul>
<li>每次调用 load，都会创建新的函数对象，<strong>即便代码相同，返回的函数也是不同的</strong>。</li>
</ul>
</li>
<li><p>dofile 直接加载并执行一个 Lua 文件，<strong>相当于 loadfile + 调用</strong>。</p>
<ul>
<li>代码运行在全局作用域，所以 dofile 执行的脚本可以定义全局变量和函数。</li>
<li>dofile 每次都会执行文件，不会缓存结果。</li>
<li><strong>如果 执行的 Lua 文件定义了全局变量参与计算返回值，会影响后续 dofile 调用返回值</strong>。</li>
</ul>
</li>
<li><p>字符串</p>
<ul>
<li>第一个从1开始，倒数 第一个是-1</li>
<li>语法糖调用方法： 可以是用字符串变量：字符串函数（）</li>
</ul>
</li>
<li><p>正则表达式</p>
<ul>
<li>Lua 使用 % 作为转义符，而不是 \</li>
<li><strong>+</strong>	匹配 1 次或多次</li>
<li><code>*</code>	匹配 0 次或多次</li>
<li>?	匹配 0 次或 1 次</li>
<li>{n,m}	匹配 n 到 m 次（Lua 不支持）</li>
<li>.	匹配任意单个字符（换行符 \n 除外）</li>
<li>%a	匹配任意字母（A-Z, a-z）</li>
<li>%d	匹配任意数字（0-9）</li>
<li>%l	匹配小写字母（a-z）</li>
<li>%u	匹配大写字母（A-Z）</li>
<li>%s	匹配空白字符（空格、制表符、换行）</li>
<li>%w	匹配字母+数字（A-Z, a-z, 0-9）</li>
<li>%x	匹配十六进制字符（0-9, A-F, a-f）</li>
<li>%c	匹配控制字符（如 \n、\t）</li>
<li>%p	匹配标点符号（如 .,!?）</li>
<li>%z	匹配 \0（null 字符）</li>
<li>%f[set]	匹配 set 定义的边界</li>
<li>(pattern)	捕获匹配的内容</li>
<li>^	匹配字符串开头</li>
<li>$	匹配字符串结尾</li>
</ul>
</li>
<li><h2 id="元表（表的爸爸）-当我们子表中进行一些特定操作时会执行元表中的内容-表默认没有继承、没有元行为，但可以使用元表（metatable）扩展它的功能。-元表本身也是一个普通的表，但它的作用是“控制”另一个表的行为。-通过-setmetatable-t-mt-将元表-mt-绑定到表-t-上。-元表可以定义特殊的元方法（metamethod），比如-index、-newindex、-add、-tostring-等。-特定操作-call-让表可以被当作函数调用。当子表被当做一个函数来使用时-会默认调用这个-ca11中的内容，当希望传参数时-一定要记住-默认第一个参数-是调用者自己-index-允许一个表在访问不存在的字段时，从元表中查找。-Index存在于？-1-作为函数，传递的索引经过函数筛选判断返回一个值-2-作为表，返回表种元素-newindex-控制给表中不存在的字段赋值时的行为。-tostring-子表要被当做字符串使用时-会默认调用这个元表中的tostring方法"><a href="#元表（表的爸爸）-当我们子表中进行一些特定操作时会执行元表中的内容-表默认没有继承、没有元行为，但可以使用元表（metatable）扩展它的功能。-元表本身也是一个普通的表，但它的作用是“控制”另一个表的行为。-通过-setmetatable-t-mt-将元表-mt-绑定到表-t-上。-元表可以定义特殊的元方法（metamethod），比如-index、-newindex、-add、-tostring-等。-特定操作-call-让表可以被当作函数调用。当子表被当做一个函数来使用时-会默认调用这个-ca11中的内容，当希望传参数时-一定要记住-默认第一个参数-是调用者自己-index-允许一个表在访问不存在的字段时，从元表中查找。-Index存在于？-1-作为函数，传递的索引经过函数筛选判断返回一个值-2-作为表，返回表种元素-newindex-控制给表中不存在的字段赋值时的行为。-tostring-子表要被当做字符串使用时-会默认调用这个元表中的tostring方法" class="headerlink" title="元表（表的爸爸）   当我们子表中进行一些特定操作时会执行元表中的内容- 表默认没有继承、没有元行为，但可以使用元表（metatable）扩展它的功能。- 元表本身也是一个普通的表，但它的作用是“控制”另一个表的行为。- 通过 setmetatable(t, mt) 将元表 mt 绑定到表 t 上。- 元表可以定义特殊的元方法（metamethod），比如 __index、__newindex、__add、__tostring 等。- 特定操作  - __call 让表可以被当作函数调用。当子表被当做一个函数来使用时 会默认调用这个 ca11中的内容，当希望传参数时 一定要记住 默认第一个参数 是调用者自己  - __index 允许一个表在访问不存在的字段时，从元表中查找。    - _Index存在于？      1. 作为函数，传递的索引经过函数筛选判断返回一个值      2. 作为表，返回表种元素  - __newindex 控制给表中不存在的字段赋值时的行为。  - __tostring 子表要被当做字符串使用时 会默认调用这个元表中的tostring方法"></a>元表（表的爸爸）   当我们子表中进行一些<code>特定操作</code>时会执行元表中的内容<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">meta=&#123;&#125;</span><br><span class="line">myTable=&#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable,meta)  第一个参数：子表   第二个参数：原表（爸爸）</span><br></pre></td></tr></table></figure><br>- 表默认没有继承、没有元行为，但可以使用<strong>元表（metatable）</strong>扩展它的功能。<br>- 元表本身也是一个普通的表，但它的作用是“控制”另一个表的行为。<br>- 通过 setmetatable(t, mt) 将元表 mt 绑定到表 t 上。<br>- 元表可以定义特殊的元方法（metamethod），比如 __index、__newindex、__add、__tostring 等。<br>- <code>特定操作</code><br>  - __call 让表可以被当作函数调用。当子表被当做一个函数来使用时 会默认调用这个 ca11中的内容，当希望传参数时 一定要记住 默认第一个参数 是调用者自己<br>  - __index 允许一个表在访问不存在的字段时，从元表中查找。<br>    - _Index存在于？<br>      1. 作为函数，传递的索引经过函数筛选判断返回一个值<br>      2. 作为表，返回表种元素<br>  - __newindex 控制给表中不存在的字段赋值时的行为。<br>  - __tostring 子表要被当做字符串使用时 会默认调用这个元表中的tostring方法</h2><ul>
<li>面向对象<ul>
<li>使用 table 作为对象，函数 作为方法，并通过 self 访问成员变量。</li>
<li>有构造函数</li>
<li>继承机制</li>
<li>没有 override 关键字，但可以手动重写方法实现多态</li>
<li>类<ol>
<li>用表来实现，获取方式更像是c#中的静态类</li>
<li>可以在表内声明和表外声明成员</li>
<li>函数在表 外部声明<ol>
<li>class.fucname &#x3D; function ()</li>
<li>function class.fucname ()</li>
</ol>
</li>
<li>在表内部函数中调用表本身属性或方法<ol>
<li>前缀一定要指明是谁的属性或方法，指定拥有者，不能直接写变量名，直接写的变量名代表的是全局变量与表中的变量是没有任何关系的</li>
<li>在函数内部调用自己属性或者方法，需要把自己作为一个参数传进来在内部访问，lua 没有参数类型,所以可以看成是范型<ol>
<li>class.fucname(class)</li>
<li>class:fucname() ：调用方法会默认把调用者作为第一个参数传入方法中</li>
</ol>
</li>
</ol>
</li>
<li>:使用<ol>
<li>函数外部调用，表示默认传入一个参数是自己</li>
<li>函数外部声明，表示默认有一个参数是自己，函数内部获取这个参数需要用self表示默认传入的第一个参数</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>垃圾回收(置空nil)-主动回收释放内存-切换场景&#x2F;内存达到瓶颈</p>
<ol>
<li>collectgarbage(“count”)lua 占用内存</li>
<li>collectgarbage(“collect”)回收垃圾</li>
</ol>
</li>
<li><p>os.time()时间s 系统时间</p>
<ol>
<li>os.date()获取时间的表，年月日时分秒</li>
</ol>
</li>
<li><p>math.abs()<br> 1.math.randomseed(os.time)<br> math.random</p>
</li>
<li><p>迭代器</p>
<ol>
<li>小于等于零的所有找不到</li>
<li>pairs比impairs强大，可以遍历所有成员包括小于等于零的索引(不规则的表)</li>
<li>可以只遍历key</li>
<li>ipairs 数字下标不连续会中断，pairs 所有通用（使用next函数实现）</li>
<li>next函数可以用于判断表是否为空</li>
</ol>
</li>
<li><p>字典</p>
<ol>
<li>访问方式a[“key”]or a.key </li>
<li>遍历好像字典一定要用pairs</li>
</ol>
</li>
<li><p>表</p>
<ul>
<li>Insert </li>
<li>Remove </li>
<li>Sort </li>
<li>Concat</li>
</ul>
</li>
<li><p>短路运算 </p>
<ol>
<li>and有真则真 </li>
<li>or有假则假</li>
<li>可以使用 and or  构成三元运算符，返回结果对应的值或者bool值，短路求值：<ul>
<li><p>and 在 第一个值为 false 或 nil 时，直接返回第一个值；否则，返回第二个值。</p>
</li>
<li><p>or 在 第一个值为 false 或 nil 时，返回第二个值；否则，直接返回第一个值。</p>
<pre><code>  print(10&gt;11 and &quot;yes&quot; or &quot;no&quot;)
</code></pre>
</li>
</ul>
</li>
</ol>
</li>
<li><p>协程 coroutine</p>
<ol>
<li>创建<ol>
<li>co&#x3D;coroutine.create(fuc) 返回的是协程（线程）<ol>
<li>调用：coroutine.resume(co)   该函数返回值第一个为协程执行成功的与否</li>
</ol>
</li>
<li>cor&#x3D;coroutine.wrap(fuc)  返回的是函数<ol>
<li>调用：cor()</li>
</ol>
</li>
</ol>
</li>
<li>挂起 coroutine.yield()  每次调用执行都会继续协程  ，yield(yieldReturn)，coroutine.resume的第二个返回值就是它  <code>isSucc ，yieldReturn = coroutine.wrap(fuc)</code></li>
<li>状态 coroutine.status<ol>
<li>dead  没有挂起的协程</li>
<li>suspended 暂停  挂起的协程</li>
<li>running   只能在协程内获取该状态    coroutine.running()可以得到当前正在运行的协程的编号</li>
</ol>
</li>
</ol>
</li>
<li><p>Person.sayHello() ≈ 静态函数   p1:sayHello() ≈ 成员函数</p>
</li>
<li><p>在 Lua 中，函数参数的传递方式可以这样理解：</p>
<ul>
<li>对于基本类型（number, string, boolean, nil等）：<ul>
<li>是值传递（pass by value），函数内修改不会影响外部变量</li>
</ul>
</li>
<li>对于 table、function、userdata 等复合类型：<ul>
<li>是引用传递（pass by reference），但更准确说是”共享传递”（pass by sharing）</li>
<li>你会得到原始对象的引用（指针），而不是副本</li>
<li>如果直接修改table的内容（如添加&#x2F;修改字段），会影响原始table</li>
<li>但如果给参数赋新值（改变引用本身），不会影响外部变量</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>unity tmp中文显示</title>
    <url>/2024/12/13/unity-tmp%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="创建tmp中文字体资源"><a href="#创建tmp中文字体资源" class="headerlink" title="创建tmp中文字体资源"></a>创建tmp中文字体资源</h1><p>1.<strong>选择Window&#x2F;TextMeshPro&#x2F;Font Asset Creator</strong></p>
<p>2.<strong>Font Asset Creator设置界面如图</strong><br><img src="/.io//image-1.png" alt="alt text"><br>Source Font File：拖入需要使用的字体</p>
<ul>
<li>Sampling Point Size：设置用于生成字体纹理的字体大小（以磅为单位）</li>
<li>Auto Sizeing：自动设置大小</li>
<li>Custom Size：自定义大小，在文本框中输入所需的大小</li>
</ul>
<p>Padding：字间距，填充越大，过渡越平滑，从而允许更高质量的渲染和更大的效果，如粗轮廓。</p>
<p>Packing Method：指定如何使字符适合字体纹理。</p>
<ul>
<li>Optimum：查找仍然适合纹理中所有字符的最大可能自动字体大小。</li>
<li>Fast：更快地计算字符打包，但可能使用比优化模式更小的字体大小。</li>
</ul>
<p>Atlas Resolution：设置字体纹理的大小宽度和高度，以像素为单位</p>
<p>Character Set：选择预定义的字符集。</p>
<ul>
<li>ASCII：包括 ASCII 字符集中的可见字符。</li>
<li>Extended ASCII：包括扩展 ASCII 字符集中的可见字符。</li>
<li>ASCII Lowercase：仅包含 ASCII 字符集中可见的小写字符。</li>
<li>ASCII Uppercase：仅包含 ASCII 字符集中可见的大写字符</li>
<li>Numbers+Sysbols：仅包括来自 ASCII 字符集的可见数字和符号。</li>
<li>Custom Range：输入一系列十进制值或值范围，以指定要包括的字符。</li>
<li>Unicode Range(Hex)：输入一系列 unicode 十六进制值或值范围，以指定要包含的字符。</li>
<li>Custom Characters：输入字符序列以指定要包含的字符。</li>
<li>Characters from File：指定的文本资源</li>
</ul>
<p>Render Mode：指定输出字体图集时要使用的渲染模式。</p>
<ul>
<li>SMOOTH_HINTED：将图集渲染为抗锯齿位图，并将字符像素与纹理像素对齐以获得更清晰的结果。</li>
<li>SMOOTH：将图集渲染为抗锯齿位图。</li>
<li>RASTER_HINTED：将图集渲染为非抗锯齿位图，并将字符像素与纹理像素对齐以获得更清晰的结果。</li>
<li>RASTER：将图集渲染为非抗锯齿位图。</li>
<li>SDF：使用较慢但更准确的 SDF 生成模式渲染图集，并且没有过采样。</li>
<li>SDF8：使用较慢但更准确的 SDF 生成模式和 8 倍过采样渲染图集。</li>
<li>SDF16：使用更慢但更准确的 SDF 生成模式和 16 倍过采样渲染图集。</li>
<li>SDF32：使用较慢但更准确的 SDF 生成模式和 32 倍过采样渲染图集。将此设置用于具有复杂或小字符的字体。</li>
<li>SDFAA_HINTED：使用更快但不太准确的 SDF 生成模式渲染图集，并将字符像素与纹理像素对齐以获得更清晰的结果，它生成的字体图集足以满足大多数情况。</li>
<li>SDFAA：使用更快但不太准确的 SDF 生成模式渲染图集，它生成的字体图集足以满足大多数情况。</li>
</ul>
<p>Get Kerning Pairs：启用此选项可从字体复制字距调整数据。</p>
<p>Generate Font Atlas：我们把包含中文字体的文件拖入Characters from File中，然后点击此按钮开始生成</p>
<p>3.生成后，如上面效果图<br>注意：字体越多，生成的时间越长…Packing Method还是选Fast吧，Optimum太慢了</p>
<p>4.点击Save按钮保存</p>
<p>5.现在就可以正常使用这个字体了</p>
<h1 id="tmp创建字体报错"><a href="#tmp创建字体报错" class="headerlink" title="tmp创建字体报错:"></a>tmp创建字体报错:</h1><p><img src="/.io//image.png" alt="alt text"></p>
<p>问题原因:</p>
<ul>
<li>字体贴图空间不足</li>
</ul>
<p>字体贴图的分辨率（Font Atlas Resolution）不够大，无法容纳所有字符。</p>
<p>生成 3000 字符所需的贴图分辨率和时间较低，一般<code>1024x1024</code> 或<code>2048x2048</code> 即可完成。</p>
<p>生成 7000 字符可能需要<code>4096x4096</code> 或更高分辨率，耗时更长。</p>
<ul>
<li>字符范围太大</li>
</ul>
<p>您可能尝试一次性添加过多的字符，例如一个完整的 Unicode 中文字符集。</p>
<ul>
<li>字体文件不支持这些字符</li>
</ul>
<p>使用的字体文件可能并未包含这些特定的字符。</p>
<ul>
<li>渲染模式设置不当</li>
</ul>
<p>当前的 Render Mode 设置可能导致字体生成失败。</p>
<hr>
<ul>
<li><strong>选择 3000 汉字：</strong><ul>
<li>如果项目是游戏、日常应用或现代场景，3000 字足够使用。</li>
<li>性能优先的项目，如 WebGL、移动端、嵌入式系统。</li>
</ul>
</li>
<li><strong>选择 7000 汉字：</strong><ul>
<li>如果项目需要显示古文、法律文书或覆盖专业领域的特殊字符。</li>
<li>针对高性能设备或专业场景，如 PC 端应用、大型屏幕展示。</li>
</ul>
</li>
</ul>
<p>汉字集下载：</p>
<p><a href="https://github.com/wy-luke/Unity-TextMeshPro-Chinese-Characters-Set">https://github.com/wy-luke/Unity-TextMeshPro-Chinese-Characters-Set</a></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>tmp</tag>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity webGL 移动端 输入框无法弹出虚拟键盘</title>
    <url>/2024/12/13/unity-webGL-%E7%A7%BB%E5%8A%A8%E7%AB%AF-%E8%BE%93%E5%85%A5%E6%A1%86%E6%97%A0%E6%B3%95%E5%BC%B9%E5%87%BA%E8%99%9A%E6%8B%9F%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<ol>
<li><p>去这个网站下载工程：</p>
<p><a href="https://github.com/kou-yeung/WebGLInput">https://github.com/kou-yeung/WebGLInput</a></p>
</li>
<li><p>将下载工程中的WebGLSupport文件夹拷贝到自己的工程中</p>
<p><img src="/.io//20241213_141006_image.png"></p>
</li>
<li><p>将WebGLInput.cs组件添加到InputField组件挂载的对象上</p>
</li>
<li><p>勾选show html element 不然输入后不显示。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
        <category>webGL</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>webGL</tag>
      </tags>
  </entry>
  <entry>
    <title>unity 打AB包流程</title>
    <url>/2025/01/23/unity-%E6%89%93AB%E5%8C%85%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>下面是详细的打包流程、代码示例，以及生成版本文件的完整实现过程。此内容适用于 Unity 项目中使用 AssetBundles 打包并支持版本文件生成与热更新的场景。</p>
<hr>
<h3 id="1-打包流程概述"><a href="#1-打包流程概述" class="headerlink" title="1. 打包流程概述"></a><strong>1. 打包流程概述</strong></h3><ol>
<li><p><strong>配置资源文件</strong>：</p>
<ul>
<li>将需要打包的资源组织到指定目录中。</li>
<li>设置每个资源的 AssetBundle 名称。</li>
</ul>
</li>
<li><p><strong>打包 AssetBundles</strong>：</p>
<ul>
<li>使用 Unity 提供的 <code>BuildPipeline.BuildAssetBundles</code> 方法，将资源打包成 <code>.ab</code> 文件。</li>
</ul>
</li>
<li><p><strong>生成版本文件</strong>：</p>
<ul>
<li>记录所有打包生成的 <code>.ab</code> 文件及其校验值（MD5 或 SHA256）。</li>
<li>生成一个 JSON 格式的版本文件，包含版本号、资源文件名及校验值。</li>
</ul>
</li>
<li><p><strong>上传资源和版本文件</strong>：</p>
<ul>
<li>将打包好的 <code>.ab</code> 文件和版本文件上传到服务器。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2. 实现步骤"></a><strong>2. 实现步骤</strong></h3><h4 id="Step-1-配置资源文件"><a href="#Step-1-配置资源文件" class="headerlink" title="Step 1: 配置资源文件"></a><strong>Step 1: 配置资源文件</strong></h4><p>在 Unity 中为资源设置 AssetBundle 名称：</p>
<ol>
<li>选中需要打包的资源（例如：Prefab、Texture）。</li>
<li>在 <strong>Inspector</strong> 面板中，设置 <code>AssetBundle</code> 字段为指定的名称。例如：<ul>
<li><code>character_assets</code></li>
<li><code>environment_assets</code></li>
</ul>
</li>
</ol>
<hr>
<h4 id="Step-2-编写打包脚本"><a href="#Step-2-编写打包脚本" class="headerlink" title="Step 2: 编写打包脚本"></a><strong>Step 2: 编写打包脚本</strong></h4><p>使用 Unity 提供的 API 打包资源。</p>
<p><strong>示例代码：打包 AssetBundles</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Security.Cryptography;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssetBundleBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="string">&quot;Tools/Build AssetBundles&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildAllAssetBundles</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打包输出路径</span></span><br><span class="line">        <span class="built_in">string</span> outputPath = Path.Combine(Application.dataPath, <span class="string">&quot;../AssetBundles&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!Directory.Exists(outputPath))</span><br><span class="line">            Directory.CreateDirectory(outputPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打包所有 AssetBundle</span></span><br><span class="line">        BuildPipeline.BuildAssetBundles(outputPath, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成版本文件</span></span><br><span class="line">        GenerateVersionFile(outputPath);</span><br><span class="line">        Debug.Log(<span class="string">&quot;AssetBundles and version file generated successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GenerateVersionFile</span>(<span class="params"><span class="built_in">string</span> assetBundlePath</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取所有打包文件</span></span><br><span class="line">        <span class="built_in">string</span>[] files = Directory.GetFiles(assetBundlePath, <span class="string">&quot;*&quot;</span>, SearchOption.AllDirectories);</span><br><span class="line">        <span class="keyword">var</span> versionData = <span class="keyword">new</span> VersionData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> file <span class="keyword">in</span> files)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.EndsWith(<span class="string">&quot;.manifest&quot;</span>) || file.EndsWith(<span class="string">&quot;.meta&quot;</span>)) <span class="keyword">continue</span>; <span class="comment">// 跳过无用文件</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> fileName = Path.GetFileName(file);</span><br><span class="line">            <span class="built_in">string</span> hash = CalculateMD5(file); <span class="comment">// 计算 MD5</span></span><br><span class="line"></span><br><span class="line">            versionData.assetBundles[fileName] = hash;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存版本文件</span></span><br><span class="line">        versionData.version = System.DateTime.Now.ToString(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>); <span class="comment">// 使用时间戳作为版本号</span></span><br><span class="line">        <span class="built_in">string</span> versionFilePath = Path.Combine(assetBundlePath, <span class="string">&quot;version.json&quot;</span>);</span><br><span class="line">        File.WriteAllText(versionFilePath, JsonUtility.ToJson(versionData, <span class="literal">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">CalculateMD5</span>(<span class="params"><span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> md5 = MD5.Create())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> stream = File.OpenRead(filePath))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> hash = md5.ComputeHash(stream);</span><br><span class="line">                <span class="keyword">return</span> BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLowerInvariant();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VersionData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> version;</span><br><span class="line">    <span class="keyword">public</span> System.Collections.Generic.Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; assetBundles = <span class="keyword">new</span> System.Collections.Generic.Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Step-3-上传资源到服务器"><a href="#Step-3-上传资源到服务器" class="headerlink" title="Step 3: 上传资源到服务器"></a><strong>Step 3: 上传资源到服务器</strong></h4><p>将以下内容上传到服务器：</p>
<ul>
<li>所有打包生成的 <code>.ab</code> 文件。</li>
<li><code>version.json</code> 文件。</li>
</ul>
<p><strong>常见的上传方式：</strong></p>
<ul>
<li>使用 FTP 工具（如 FileZilla）手动上传。</li>
<li>配合自动化脚本将文件上传到服务器或存储服务（如 AWS S3、GitHub Releases）。</li>
</ul>
<hr>
<h3 id="3-版本文件的结构和内容"><a href="#3-版本文件的结构和内容" class="headerlink" title="3. 版本文件的结构和内容"></a><strong>3. 版本文件的结构和内容</strong></h3><h4 id="版本文件（version-json）示例："><a href="#版本文件（version-json）示例：" class="headerlink" title="版本文件（version.json）示例："></a><strong>版本文件（<code>version.json</code>）示例：</strong></h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20250123090000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;assetBundles&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;character_assets&quot;</span><span class="punctuation">:</span> <span class="string">&quot;f2a29d0c08f2c4a3d1d7ec5b6e8b8a34&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;environment_assets&quot;</span><span class="punctuation">:</span> <span class="string">&quot;e1d4f7600c1f7b4a9e5f9e2b123f9a8d&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>version</code> 表示版本号，用时间戳生成（如 <code>yyyyMMddHHmmss</code> 格式）。</li>
<li><code>assetBundles</code> 是一个字典，存储每个资源文件名及其对应的 MD5 校验值。</li>
</ul>
<hr>
<h3 id="4-客户端检查版本和热更新流程"><a href="#4-客户端检查版本和热更新流程" class="headerlink" title="4. 客户端检查版本和热更新流程"></a><strong>4. 客户端检查版本和热更新流程</strong></h3><p>在客户端，以下是资源检查和下载的基本逻辑：</p>
<ol>
<li><p><strong>获取版本文件</strong>：</p>
<ul>
<li>客户端启动时，下载服务器的 <code>version.json</code>。</li>
<li>如果客户端不存在本地版本文件，则直接下载所有资源。</li>
</ul>
</li>
<li><p><strong>比较版本号</strong>：</p>
<ul>
<li>如果服务器版本号高于本地版本号，开始检查资源文件。</li>
</ul>
</li>
<li><p><strong>校验资源文件</strong>：</p>
<ul>
<li>根据服务器的版本文件中的校验值，逐一检查本地资源文件是否完整。</li>
<li>如果文件丢失或校验值不匹配，则下载该文件。</li>
</ul>
</li>
<li><p><strong>下载更新资源</strong>：</p>
<ul>
<li>将需要更新的 <code>.ab</code> 文件从服务器下载到本地。</li>
<li>更新本地的版本文件。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-示例代码：客户端版本检查与更新"><a href="#5-示例代码：客户端版本检查与更新" class="headerlink" title="5. 示例代码：客户端版本检查与更新"></a><strong>5. 示例代码：客户端版本检查与更新</strong></h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Networking;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HotUpdateManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> serverVersionUrl = <span class="string">&quot;https://example.com/version.json&quot;</span>; <span class="comment">// 服务器版本文件 URL</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> localVersionPath = Application.persistentDataPath + <span class="string">&quot;/version.json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> serverAssetBaseUrl = <span class="string">&quot;https://example.com/&quot;</span>; <span class="comment">// 资源下载根目录</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(CheckForUpdates());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">CheckForUpdates</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取服务器版本文件</span></span><br><span class="line">        UnityWebRequest versionRequest = UnityWebRequest.Get(serverVersionUrl);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> versionRequest.SendWebRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (versionRequest.result != UnityWebRequest.Result.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;Failed to fetch version.json: &quot;</span> + versionRequest.error);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> serverVersionContent = versionRequest.downloadHandler.text;</span><br><span class="line">        <span class="keyword">var</span> serverVersionData = JsonUtility.FromJson&lt;VersionData&gt;(serverVersionContent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查本地版本文件</span></span><br><span class="line">        VersionData localVersionData = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (File.Exists(localVersionPath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> localVersionContent = File.ReadAllText(localVersionPath);</span><br><span class="line">            localVersionData = JsonUtility.FromJson&lt;VersionData&gt;(localVersionContent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查版本号和资源</span></span><br><span class="line">        <span class="keyword">if</span> (localVersionData == <span class="literal">null</span> || serverVersionData.version != localVersionData.version)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;New version detected, updating assets...&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> asset <span class="keyword">in</span> serverVersionData.assetBundles)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> localFilePath = Path.Combine(Application.persistentDataPath, asset.Key);</span><br><span class="line">                <span class="keyword">if</span> (!File.Exists(localFilePath) || GetMD5(localFilePath) != asset.Value)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">DownloadAsset(asset.Key</span>))</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新本地版本文件</span></span><br><span class="line">            File.WriteAllText(localVersionPath, serverVersionContent);</span><br><span class="line">            Debug.Log(<span class="string">&quot;Assets updated successfully!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Assets are up-to-date.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">DownloadAsset</span>(<span class="params"><span class="built_in">string</span> assetName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> url = serverAssetBaseUrl + assetName;</span><br><span class="line">        UnityWebRequest request = UnityWebRequest.Get(url);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> request.SendWebRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.result == UnityWebRequest.Result.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> localPath = Path.Combine(Application.persistentDataPath, assetName);</span><br><span class="line">            File.WriteAllBytes(localPath, request.downloadHandler.data);</span><br><span class="line">            Debug.Log(<span class="string">$&quot;Downloaded: <span class="subst">&#123;assetName&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">$&quot;Failed to download <span class="subst">&#123;assetName&#125;</span>: <span class="subst">&#123;request.error&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GetMD5</span>(<span class="params"><span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> md5 = System.Security.Cryptography.MD5.Create())</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> stream = File.OpenRead(filePath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> hash = md5.ComputeHash(stream);</span><br><span class="line">            <span class="keyword">return</span> System.BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLowerInvariant();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>通过以上流程，你可以实现完整的热更新功能，包括打包资源、生成版本文件、检查和下载更新资源。</p>
<h2 id="HybridCLR-程序集打包成ab并加载"><a href="#HybridCLR-程序集打包成ab并加载" class="headerlink" title="HybridCLR 程序集打包成ab并加载"></a>HybridCLR 程序集打包成ab并加载</h2><h3 id="Unity-HybridCLR-热更新程序集打包与加载流程"><a href="#Unity-HybridCLR-热更新程序集打包与加载流程" class="headerlink" title="Unity HybridCLR 热更新程序集打包与加载流程"></a><strong>Unity HybridCLR 热更新程序集打包与加载流程</strong></h3><p>HybridCLR 是 Unity 的一种轻量级跨平台解决方案，支持加载 AOT（Ahead Of Time）和解释执行的程序集，适用于游戏热更新。以下是完整的 <strong>打包流程</strong> 和 <strong>加载流程</strong>。</p>
<hr>
<h2 id="1-热更新程序集打包流程"><a href="#1-热更新程序集打包流程" class="headerlink" title="1. 热更新程序集打包流程"></a><strong>1. 热更新程序集打包流程</strong></h2><h3 id="1-1-配置热更新程序集工程"><a href="#1-1-配置热更新程序集工程" class="headerlink" title="1.1 配置热更新程序集工程"></a><strong>1.1 配置热更新程序集工程</strong></h3><h4 id="步骤-1-创建独立的热更新工程"><a href="#步骤-1-创建独立的热更新工程" class="headerlink" title="步骤 1: 创建独立的热更新工程"></a><strong>步骤 1: 创建独立的热更新工程</strong></h4><ul>
<li>在 Unity 项目中，创建一个独立的 C# 项目用于存放热更新代码。</li>
<li>确保该工程编译为 <code>.dll</code> 文件（Class Library 项目）。</li>
<li>使用 <code>.NET Framework 4.x</code> 或 <code>.NET Standard 2.1</code>（与 Unity 项目一致）。</li>
</ul>
<h4 id="步骤-2-添加必要引用"><a href="#步骤-2-添加必要引用" class="headerlink" title="步骤 2: 添加必要引用"></a><strong>步骤 2: 添加必要引用</strong></h4><ul>
<li>引用 Unity 的程序集文件：<ul>
<li><code>UnityEngine.dll</code></li>
<li><code>UnityEngine.CoreModule.dll</code></li>
<li>这些文件可在 Unity 安装目录的 <code>Editor/Data/Managed</code> 或 <code>Library/ScriptAssemblies</code> 下找到。</li>
</ul>
</li>
</ul>
<h4 id="步骤-3-编写热更新代码"><a href="#步骤-3-编写热更新代码" class="headerlink" title="步骤 3: 编写热更新代码"></a><strong>步骤 3: 编写热更新代码</strong></h4><ul>
<li>将需要动态更新的逻辑代码放入热更新工程。</li>
<li>避免引用 UnityEditor 命名空间。</li>
<li><strong>特别注意</strong>：在 HybridCLR 中，一部分代码会运行在 AOT 模式，因此需要合理规划哪些代码进入热更新工程，哪些留在主工程中。</li>
</ul>
<hr>
<h3 id="1-2-编译与输出程序集"><a href="#1-2-编译与输出程序集" class="headerlink" title="1.2 编译与输出程序集"></a><strong>1.2 编译与输出程序集</strong></h3><h4 id="步骤-1-编译热更新程序集"><a href="#步骤-1-编译热更新程序集" class="headerlink" title="步骤 1: 编译热更新程序集"></a><strong>步骤 1: 编译热更新程序集</strong></h4><ul>
<li>使用 Visual Studio 或 Rider 将热更新工程编译为 <code>.dll</code> 文件。</li>
<li>输出文件如：<ul>
<li><code>HotUpdate.dll</code>（主程序集）</li>
<li><code>HotUpdate.pdb</code>（符号文件，用于调试）。</li>
</ul>
</li>
</ul>
<h4 id="步骤-2-标记为热更新程序集"><a href="#步骤-2-标记为热更新程序集" class="headerlink" title="步骤 2: 标记为热更新程序集"></a><strong>步骤 2: 标记为热更新程序集</strong></h4><ul>
<li>在 Unity 的主工程中，创建一个文件夹（如 <code>Assets/HotUpdateAssemblies</code>），将编译好的 <code>.dll</code> 文件放入该目录。</li>
</ul>
<h4 id="步骤-3-使用-AssetBundle-打包"><a href="#步骤-3-使用-AssetBundle-打包" class="headerlink" title="步骤 3: 使用 AssetBundle 打包"></a><strong>步骤 3: 使用 AssetBundle 打包</strong></h4><ul>
<li>在 Unity 中创建一个脚本，用于将这些 <code>.dll</code> 文件打包成 AssetBundle：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssetBundleBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="string">&quot;Tools/Build AssetBundles&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildHotUpdateAssemblies</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> outputPath = <span class="string">&quot;Assets/StreamingAssets/HotUpdateBundles&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!System.IO.Directory.Exists(outputPath))</span><br><span class="line">            System.IO.Directory.CreateDirectory(outputPath);</span><br><span class="line"></span><br><span class="line">        AssetBundleBuild[] buildMap = <span class="keyword">new</span> AssetBundleBuild[<span class="number">1</span>];</span><br><span class="line">        buildMap[<span class="number">0</span>] = <span class="keyword">new</span> AssetBundleBuild</span><br><span class="line">        &#123;</span><br><span class="line">            assetBundleName = <span class="string">&quot;hotupdateassemblies&quot;</span>,</span><br><span class="line">            assetNames = <span class="keyword">new</span>[] &#123; <span class="string">&quot;Assets/HotUpdateAssemblies/HotUpdate.dll&quot;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        BuildPipeline.BuildAssetBundles(outputPath, buildMap, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64);</span><br><span class="line">        Debug.Log(<span class="string">&quot;Hot update AssetBundle built successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这会将 <code>HotUpdate.dll</code> 打包到一个名为 <code>hotupdateassemblies</code> 的 AssetBundle 中。</li>
</ul>
<h4 id="步骤-4-上传到资源服务器"><a href="#步骤-4-上传到资源服务器" class="headerlink" title="步骤 4: 上传到资源服务器"></a><strong>步骤 4: 上传到资源服务器</strong></h4><ul>
<li>将打包生成的 AssetBundle（如 <code>hotupdateassemblies</code>) 上传到远程服务器（如 GitHub Releases、CDN、阿里云 OSS 等），以便运行时下载。</li>
</ul>
<hr>
<h2 id="2-热更新程序集加载流程"><a href="#2-热更新程序集加载流程" class="headerlink" title="2. 热更新程序集加载流程"></a><strong>2. 热更新程序集加载流程</strong></h2><h3 id="2-1-配置-HybridCLR"><a href="#2-1-配置-HybridCLR" class="headerlink" title="2.1 配置 HybridCLR"></a><strong>2.1 配置 HybridCLR</strong></h3><h4 id="步骤-1-安装-HybridCLR"><a href="#步骤-1-安装-HybridCLR" class="headerlink" title="步骤 1: 安装 HybridCLR"></a><strong>步骤 1: 安装 HybridCLR</strong></h4><ul>
<li>在 Unity 项目中，按照 HybridCLR 的官方文档安装 HybridCLR 插件。</li>
<li>安装后会生成以下文件和配置：<ul>
<li><code>HybridCLR/HotUpdateAssemblies</code> 文件夹（存放热更新程序集）。</li>
<li><code>HybridCLR</code> 配置文件（设置热更新相关参数）。</li>
</ul>
</li>
</ul>
<h4 id="步骤-2-配置-AOT-元数据"><a href="#步骤-2-配置-AOT-元数据" class="headerlink" title="步骤 2: 配置 AOT 元数据"></a><strong>步骤 2: 配置 AOT 元数据</strong></h4><ul>
<li>AOT 模式需要将部分元数据文件（<code>.dll</code>）打包到游戏中。</li>
<li>在 <code>HybridCLR/HotUpdateAssemblies</code> 文件夹中，放入所有热更新相关的 <code>.dll</code> 文件。</li>
</ul>
<hr>
<h3 id="2-2-加载热更新程序集"><a href="#2-2-加载热更新程序集" class="headerlink" title="2.2 加载热更新程序集"></a><strong>2.2 加载热更新程序集</strong></h3><h4 id="步骤-1-下载-AssetBundle"><a href="#步骤-1-下载-AssetBundle" class="headerlink" title="步骤 1: 下载 AssetBundle"></a><strong>步骤 1: 下载 AssetBundle</strong></h4><ul>
<li>游戏启动时，从远程服务器下载最新的 AssetBundle 文件。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HotUpdateManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> AssetBundleURL = <span class="string">&quot;https://your-server.com/hotupdateassemblies&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 下载 AssetBundle</span></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> www = UnityEngine.Networking.UnityWebRequestAssetBundle.GetAssetBundle(AssetBundleURL);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> www.SendWebRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (www.result != UnityEngine.Networking.UnityWebRequest.Result.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;Failed to download AssetBundle: &quot;</span> + www.error);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载 AssetBundle</span></span><br><span class="line">        <span class="keyword">var</span> assetBundle = UnityEngine.Networking.DownloadHandlerAssetBundle.GetContent(www);</span><br><span class="line">        <span class="keyword">if</span> (assetBundle == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;Failed to load AssetBundle.&quot;</span>);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提取 .dll 文件</span></span><br><span class="line">        TextAsset dllAsset = assetBundle.LoadAsset&lt;TextAsset&gt;(<span class="string">&quot;HotUpdate.dll&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (dllAsset == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;Failed to load HotUpdate.dll from AssetBundle.&quot;</span>);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LoadHotUpdateAssembly(dllAsset.bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadHotUpdateAssembly</span>(<span class="params"><span class="built_in">byte</span>[] dllBytes</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> assembly = System.Reflection.Assembly.Load(dllBytes);</span><br><span class="line">        <span class="keyword">var</span> type = assembly.GetType(<span class="string">&quot;HotUpdate.Program&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> method = type.GetMethod(<span class="string">&quot;Main&quot;</span>);</span><br><span class="line">        method?.Invoke(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="步骤-2-加载热更新程序集"><a href="#步骤-2-加载热更新程序集" class="headerlink" title="步骤 2: 加载热更新程序集"></a><strong>步骤 2: 加载热更新程序集</strong></h4><ul>
<li>使用 <code>System.Reflection.Assembly.Load</code> 加载 <code>HotUpdate.dll</code>，并调用其中的入口方法（如 <code>Main()</code>）。</li>
</ul>
<h4 id="步骤-3-切换逻辑到热更新代码"><a href="#步骤-3-切换逻辑到热更新代码" class="headerlink" title="步骤 3: 切换逻辑到热更新代码"></a><strong>步骤 3: 切换逻辑到热更新代码</strong></h4><ul>
<li>在热更新程序集（如 <code>HotUpdate.dll</code>）中，处理游戏的逻辑更新。例如：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">HotUpdate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;HotUpdate assembly loaded successfully!&quot;</span>);</span><br><span class="line">            <span class="comment">// 热更新逻辑处理...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a><strong>3. 总结</strong></h2><h3 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a><strong>打包流程</strong></h3><ol>
<li>在独立的 C# 项目中编写热更新代码，编译为 <code>.dll</code> 文件。</li>
<li>将 <code>.dll</code> 文件放入 Unity 项目中并打包为 AssetBundle。</li>
<li>将打包的 AssetBundle 上传到远程服务器。</li>
</ol>
<h3 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a><strong>加载流程</strong></h3><ol>
<li>游戏启动时，下载远程的 AssetBundle 文件。</li>
<li>解压并加载 <code>.dll</code> 文件到内存。</li>
<li>使用 <code>Assembly.Load</code> 加载程序集，并调用热更新代码入口（如 <code>Main()</code> 方法）。</li>
<li>切换游戏逻辑到热更新代码。</li>
</ol>
<p>通过 HybridCLR，这种热更新流程实现了代码与资源的分离更新，提升了项目的维护性和灵活性。</p>
<h2 id="热更程序集打包成"><a href="#热更程序集打包成" class="headerlink" title="热更程序集打包成"></a>热更程序集打包成</h2>]]></content>
  </entry>
  <entry>
    <title>unity 插件工具</title>
    <url>/2025/01/06/unity-%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/weixin_43705303/article/details/126761956">Unity常见插件汇总 csdn</a><br><a href="https://zhuanlan.zhihu.com/p/62471100">知乎</a><br><a href="https://blog.csdn.net/u014361280/article/details/122806834">详细</a><br><a href="https://www.gcores.com/articles/191584#nopop_e204c">cato 使用的20个插件</a></p>
<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><ol>
<li><strong>Amplify Shader Editor</strong>：图形化着色器编辑器，提供直观的界面和强大的自定义功能，帮助开发者轻松创建复杂的着色器。  </li>
<li><strong>Asset Hunter PRO</strong>：优化Unity项目资源的工具，帮助检测和删除未使用的资产，提升项目性能和减少包体积。  </li>
<li><strong>AssetBundleManager</strong>：用于高效管理和加载Unity AssetBundle的工具，简化资源打包与加载的流程。  </li>
<li><strong>Build Manager + Version</strong>：一体化构建管理工具，支持版本控制、构建配置和自动化构建流程，提升开发效率。  </li>
<li><strong>Build Report Tool</strong>：生成Unity构建报告，提供详细的构建过程分析，帮助优化构建时间和资源使用。  </li>
<li><strong>DOTween</strong>：高效的动画和时间控制库，支持平滑的UI和物体动画，适用于各种2D&#x2F;3D动画。  </li>
<li><strong>DOTween Pro</strong>：DOTween的增强版，提供更多高级动画功能，如路径动画和复杂的事件管理。  </li>
<li><strong>Editor Console Pro</strong>：改进Unity控制台工具，增强日志查看、错误过滤和调试功能，提升开发体验。  </li>
<li><strong>Easy Editor</strong>：简化Unity编辑器界面的插件，提供自定义的编辑器窗口、属性面板和快捷操作。  </li>
<li><strong>Easy Save 3</strong>：用于Unity中保存和加载数据的工具，支持序列化、加密和云存储功能。  </li>
<li><strong>Easy Touch Controls</strong>：提供易于实现的触摸控制系统，适合移动平台游戏的开发。  </li>
<li><strong>EasyJoystick</strong>：简化虚拟摇杆控制系统，支持自定义输入和响应式设计，适合手机游戏。  </li>
<li><strong>FX Maker</strong>：为Unity提供强大且易用的特效创建工具，支持粒子系统、光影效果和自定义动画。  </li>
<li><strong>GameFlow</strong>：无代码游戏编程工具，提供可视化流程图，方便设计师和程序员创建游戏逻辑。  </li>
<li><strong>Graphy</strong>：可视化图表工具，支持创建动态图表、数据分析和UI设计，适合数据驱动的游戏。  </li>
<li><strong>Graph And Chart</strong>：强大的图表库，支持多种类型的图表和数据展示，适用于分析类游戏。  </li>
<li><strong>InGame Debug Console</strong>：游戏内调试控制台，允许开发者在运行时查看日志、执行命令和调试数据。  </li>
<li><strong>LeanTouch</strong>：简化触摸输入处理的工具，支持多点触控、拖动、缩放等操作，适用于移动设备游戏。  </li>
<li><strong>LeanTween</strong>：轻量级动画库，专注于高效的时间控制与UI动画，适用于各种类型的游戏。  </li>
<li><strong>Odin Inspector</strong>：强大的Unity编辑器扩展，提升Inspector窗口功能，支持自定义属性面板和增强的可视化工具。  </li>
<li><strong>Playmaker</strong>：可视化编程工具，使用状态机设计游戏逻辑，无需编写代码即可实现复杂功能。  </li>
<li><strong>PoolManager</strong>：对象池管理工具，优化游戏中对象的实例化与回收，减少性能开销。  </li>
<li><strong>ProBuilder</strong>：Unity内建的3D建模工具，支持快速创建和编辑3D模型，适用于关卡设计和原型制作。  </li>
<li><strong>Pro Camera 2D</strong>：2D相机插件，提供视差滚动、镜头特效和摄像机控制，适用于2D游戏项目。  </li>
<li><strong>QHierarchy</strong>：增强Unity层次面板的工具，提供快捷操作和自定义视图，提升开发效率。  </li>
<li><strong>SRDebugger</strong>：实时调试工具，支持游戏内调试、实时修改游戏参数，适合实时监控和调试游戏状态。  </li>
<li><strong>Stan’s Assets</strong>：提供多个Unity工具集，包括优化、UI、特效和其他增强功能，支持多种游戏开发需求。  </li>
<li><strong>Toolbar Extender</strong>：自定义Unity工具栏的插件，允许开发者自定义快捷按钮和操作，提高工作效率。  </li>
<li><strong>UnIDE</strong>：一款集成开发环境，支持C#代码编写、调试、版本控制等功能，适合Unity开发者。  </li>
<li><strong>UniTask</strong>：异步编程工具，基于C# Task的优化版本，提升Unity项目的异步执行效率。  </li>
<li><strong>UniWebView</strong>：轻量级WebView插件，支持Unity中嵌入网页，适用于集成Web内容和互动。  </li>
<li><strong>UVS</strong>：用于生成和管理纹理UV映射的工具，简化3D模型的UV操作和纹理映射过程。</li>
</ol>
<h1 id="UI-交互"><a href="#UI-交互" class="headerlink" title="UI &amp; 交互"></a>UI &amp; 交互</h1><ol>
<li><strong>2D Toolkit</strong>：强大的2D游戏开发工具包，提供精灵管理、网格生成、物理支持和动态字体渲染功能，适合高效创建2D游戏内容。  </li>
<li><strong>Curved UI</strong>：UI曲面插件，用于将Unity的UI组件贴合到弧形、球形或其他曲面上，适合VR、AR和特殊UI需求项目。  </li>
<li><strong>Doozy UI Manager</strong>：UI管理框架，支持动画控制、导航逻辑和事件系统，可快速创建复杂的用户界面。  </li>
<li><strong>Dialogue System for Unity</strong>：对话系统插件，支持分支对话、任务管理和多语言功能，适合RPG、冒险或叙事类游戏。  </li>
<li><strong>FairyGUI</strong>：跨平台UI开发框架，支持动态UI设计、动画和与外部工具的无缝集成，适合复杂的UI项目。  </li>
<li><strong>Highlighting System</strong>：物体高亮插件，提供动态边缘描边和高光效果，用于突出选中或交互对象。  </li>
<li><strong>I2 Localization</strong>：本地化管理工具，支持多语言文本、语音和资源切换，简化全球化开发过程。  </li>
<li><strong>Inventory Pro</strong>：全面的库存管理系统，支持物品分类、装备、交易和任务物品管理，适合RPG和冒险类游戏。  </li>
<li><strong>UGUI MiniMap</strong>：迷你地图插件，支持实时更新、标记和动态缩放功能，提升游戏导航体验。  </li>
<li><strong>Text Animator for Unity</strong>：文本动画插件，提供类型机效果、渐显和抖动等动态文字展示，增强UI互动性和视觉效果。</li>
</ol>
<h1 id="渲染-特效"><a href="#渲染-特效" class="headerlink" title="渲染 &amp; 特效"></a>渲染 &amp; 特效</h1><ol>
<li><strong>All In 1 Vfx Toolkit</strong>：多功能视觉特效工具包，涵盖粒子、爆炸、烟雾等特效，适合多种类型游戏的VFX需求，支持高性能和可定制化。  </li>
<li><strong>Amplify Shader Pack</strong>：高性能的着色器集合，支持复杂材质效果，包括PBR、水体、光照和自定义Shader，适合视觉增强和图形优化。  </li>
<li><strong>Best HTTP&#x2F;2</strong>：强大的HTTP和WebSocket库，支持HTTP&#x2F;2协议，提供快速、稳定的网络连接，适合多人在线游戏或实时服务。  </li>
<li><strong>BIG Environment Pack Vol.2</strong>：环境美术资源包，包括地形、树木、岩石等自然元素，适合开放世界、RPG或生存类游戏的场景设计。  </li>
<li><strong>Card Effect Shader</strong>：用于卡牌游戏的着色器，支持动态光效、渐变和发光等效果，提升卡牌外观和视觉表现力。  </li>
<li><strong>Cartoon FX 2 Remaster</strong>：卡通风格的粒子特效包，包括爆炸、火焰、魔法等特效，适合风格化游戏项目。  </li>
<li><strong>Colorful FX</strong>：后处理特效工具，提供色彩校正、饱和度调整和滤镜效果，提升画面质量和视觉风格。  </li>
<li><strong>Combu 3</strong>：多人游戏后端解决方案，支持玩家管理、存档、排行榜和云存储功能，方便创建联网游戏。  </li>
<li><strong>Final IK</strong>：强大的反向动力学插件，用于实现角色的自然动作和动态动画调整，支持全身和局部IK。  </li>
<li><strong>Fingers - Touch Gestures for Unity</strong>：触控手势插件，支持拖动、缩放和旋转等常见手势，适合移动设备交互开发。  </li>
<li><strong>Mobile Fast Shadow</strong>：专为移动设备优化的快速阴影插件，提供高性能的实时阴影渲染，适合移动游戏场景。  </li>
<li><strong>Next-Gen Soft-Shadows</strong>：高级软阴影插件，支持动态光照和逼真的阴影模糊效果，提升画面真实感。  </li>
<li><strong>Stylized Water Shader</strong>：高性能风格化水体着色器，提供实时波纹、反射和颜色渐变效果，适合卡通或低多边形风格游戏。  </li>
<li><strong>Toon Shader</strong>：卡通渲染着色器，支持边缘描边、高光和渐变效果，用于风格化渲染项目。  </li>
<li><strong>Volumetric Fog &amp; Mist</strong>：体积雾和烟雾效果插件，提供动态光照、深度感和雾气模拟，增强环境氛围表现。  </li>
<li><strong>Water 2D Tool</strong>：二维水体模拟工具，支持波纹、流动和物理互动效果，适合2D游戏的水体表现。  </li>
<li><strong>Fast Shadows</strong>：轻量级阴影解决方案，适用于低性能设备的快速渲染，提供基础阴影支持而不影响性能。</li>
</ol>
<h1 id="动画-物理"><a href="#动画-物理" class="headerlink" title="动画 &amp; 物理"></a>动画 &amp; 物理</h1><ol>
<li><strong>Dynamic Bone</strong>：为角色模型的骨骼创建逼真的物理效果插件，可用于实现头发、衣物和尾巴等部位的动态运动，支持实时调整和高效计算。  </li>
<li><strong>Edy’s Vehicle Physics</strong>：专业级车辆物理引擎，支持真实车辆操控、碰撞和悬挂模拟，适合赛车、模拟驾驶和开放世界项目开发。  </li>
<li><strong>Emerald AI</strong>：多功能AI系统，支持敌人和NPC的智能行为，提供状态机、导航、战斗和动态反应功能，易于集成到各种游戏中。  </li>
<li><strong>Final IK</strong>：强大的反向动力学（IK）插件，支持全身IK、手部IK和LookAt等多种功能，用于实现角色的自然动作和动态动画调整。  </li>
<li><strong>Fingers - Touch Gestures for Unity</strong>：多点触控手势识别插件，支持捏合、拖拽、旋转等常见手势，适合移动端开发，易于集成和扩展。  </li>
<li><strong>PuppetMaster</strong>：高级角色布娃娃物理插件，通过动态模拟角色受力和碰撞行为，提供真实的互动效果，可与Final IK配合使用。  </li>
<li><strong>Tail Animator</strong>：为角色的尾巴、触角和其他附属部分提供动态动画效果的工具，支持物理模拟和自动运动，适合增加生物角色的表现力。  </li>
<li><strong>UMotion Pro - Animation Editor</strong>：强大的动画编辑器，支持直接在Unity中创建和修改动画，提供时间轴编辑、关键帧设置和骨骼调整功能。  </li>
<li><strong>Smooth Sync</strong>：高效的网络同步工具，减少多人游戏中位置和旋转的同步延迟，提供平滑的物理和动画效果，提升网络性能。  </li>
<li><strong>Spine Animator</strong>：为骨骼动画创建逼真的动态效果，支持自动摆动、柔性移动和物理模拟，增强角色动画的表现力。</li>
</ol>
<h1 id="路径规划-AI"><a href="#路径规划-AI" class="headerlink" title="路径规划 &amp; AI"></a>路径规划 &amp; AI</h1><ol>
<li><em><em>A</em> Pathfinding Project Pro</em><em>：功能强大的路径寻路工具，基于A</em>算法，支持网格、点和导航网等多种寻路模式，适用于复杂场景的AI移动路径规划。  </li>
<li><strong>Behavior Designer - Behavior Trees for Everyone</strong>：行为树设计工具，帮助开发者为AI角色设计复杂的行为逻辑，支持直观的可视化编辑和灵活的扩展。  </li>
<li><strong>Behavior Designer - Movement Pack</strong>：Behavior Designer的扩展包，提供多种预定义的AI运动行为，例如跟随、逃避、巡逻等，便于快速实现AI控制。  </li>
<li><strong>Corgi Engine</strong>：高性能2D&#x2F;2.5D游戏引擎，提供丰富的功能和模板，适合开发平台跳跃、动作冒险和射击游戏，支持物理交互和动画。  </li>
<li><strong>Emerald AI</strong>：先进的AI解决方案，支持敌人、动物和NPC的行为设计，具有状态机、动态导航、战斗系统等功能，易于集成到任何游戏中。  </li>
<li><strong>Rex Engine: Classic 2D Platformer Engine</strong>：经典的2D平台游戏引擎，提供物理控制、角色动画和关卡编辑功能，适合快速创建复古风格的游戏项目。  </li>
<li><strong>GameFlow</strong>：通用的可视化逻辑编辑工具，无需编程即可实现复杂的游戏逻辑和交互，适用于快速原型设计和小型项目开发。</li>
</ol>
<h1 id="网络-多人游戏"><a href="#网络-多人游戏" class="headerlink" title="网络 &amp; 多人游戏"></a>网络 &amp; 多人游戏</h1><ol>
<li><strong>Agora Video SDK for Unity</strong>：用于在Unity项目中实现高质量视频通话与实时直播的开发工具，支持跨平台低延迟通信，适合多人互动和视频协作应用。  </li>
<li><strong>Blockchain SDK by Enjin</strong>：区块链集成工具，支持创建和管理NFT、数字资产交易等，适用于游戏资产的区块链化和玩家经济生态系统建设。  </li>
<li><strong>CodeGuard</strong>：代码保护工具，通过混淆、加密和其他安全措施防止逆向工程和代码泄露，增强Unity项目的安全性。  </li>
<li><strong>Photon PUN+ Classic</strong>：经典的多人联网解决方案，提供可靠的同步和实时通信功能，适用于快速构建中小型在线多人游戏。  </li>
<li><strong>PUN 2 - FREE</strong>：Photon Unity Networking 2免费版，支持高效的实时同步，易于上手，适用于开发在线多人游戏和实时互动应用。  </li>
<li><strong>Rewired</strong>：高级输入系统，支持多种控制设备与平台，提供精确的输入映射和自定义选项，是Unity游戏开发的高效输入解决方案。  </li>
<li><strong>WebRTC Video Chat</strong>：基于WebRTC协议的实时视频聊天插件，支持点对点音视频通信，适用于社交应用、虚拟会议和在线教育项目。</li>
</ol>
<h1 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h1><ol>
<li><strong>Koreographer Professional Edition</strong>：高级音乐同步工具，通过精准的节奏事件触发游戏行为，实现音频与游戏场景的深度互动，适用于音乐游戏和节奏驱动项目。  </li>
<li><strong>Master Audio</strong>：强大的音频管理系统，支持多通道混音、音效动态管理和3D音频，适合构建复杂的游戏音效环境和优化音频性能。  </li>
<li><strong>RT-Voice PRO</strong>：实时文本转语音插件，支持多种语言和语音合成选项，适用于动态内容生成的游戏、教育软件和虚拟助手开发。  </li>
<li><strong>SALSA LipSync Suite</strong>：高效的实时嘴型同步工具，支持语音音频或文本输入，实现角色嘴部动画与音频的精确匹配，适用于对话驱动的游戏和动画项目。</li>
</ol>
<h1 id="AR-VR"><a href="#AR-VR" class="headerlink" title="AR&#x2F;VR"></a>AR&#x2F;VR</h1><ol>
<li><strong>AR + GPS Location</strong>：提供基于GPS位置的增强现实功能，支持地理标记和实时场景交互，适用于位置驱动的AR应用和游戏开发。  </li>
<li><strong>AR Camera Lite — AR Engine — Gyroscope &amp; Accelerometer — Augmented Reality</strong>：轻量级AR引擎，利用陀螺仪和加速度计实现设备追踪和增强现实效果，适合快速开发基础AR功能的应用。  </li>
<li><strong>AR Foundation Remote</strong>：为AR Foundation项目提供远程调试功能，可以实时查看AR场景在不同设备上的效果，加快开发和测试过程。  </li>
<li><strong>Vuforia Core Samples</strong>：Vuforia增强现实引擎的示例项目，展示了物体追踪、图像识别和空间映射等核心功能，适合学习和快速实现AR项目。  </li>
<li><strong>VR Easy</strong>：简化VR开发流程的插件，提供直观的交互工具和组件，帮助开发者快速构建沉浸式虚拟现实体验。  </li>
<li><strong>VR Interaction Framework</strong>：全面的VR交互框架，支持抓取、投掷和按钮交互等常见功能，适用于开发高交互性的VR应用。  </li>
<li><strong>VR Panorama 360 PRO Renderer</strong>：用于生成高质量360度全景图像和视频的工具，适合VR电影、场景展示和虚拟旅游项目。  </li>
<li><strong>VR UIKit</strong>：VR界面构建工具，提供预制组件和样式模板，帮助开发者快速设计和实现直观的VR用户界面。</li>
</ol>
<h1 id="场景-地图"><a href="#场景-地图" class="headerlink" title="场景 &amp; 地图"></a>场景 &amp; 地图</h1><ol>
<li><strong>Gaia Pro 2021</strong>：功能强大的地形生成工具，支持程序化生成、实时编辑和场景优化，适用于快速创建高质量的游戏世界与环境场景。  </li>
<li><strong>MapMagic World Generator</strong>：动态地形生成工具，支持程序化地形、无限世界扩展和实时编辑，适合开放世界和动态加载场景的游戏开发。  </li>
<li><strong>Terrain Composer</strong>：地形生成和编辑插件，提供多层级地形控制和批量操作功能，可快速生成复杂地形，优化大规模场景的制作流程。  </li>
<li><strong>The Vegetation Engine</strong>：植被着色系统，支持动态风力效果、季节变化和材质优化，适用于创建高性能且美观的自然环境。  </li>
<li><strong>GO Map - 3D Map for AR Gaming</strong>：一款适用于AR游戏的3D地图生成插件，支持与地理信息数据的集成，适合开发基于真实地理位置的AR场景。  </li>
<li><strong>Fantasy Environment</strong>：提供奇幻风格环境的资源包，包括植被、地形材质和建筑模型，适用于构建魔幻主题的游戏场景。  </li>
<li><strong>Cemetery Starter Pack</strong>：墓地主题的环境资源包，包含墓碑、雕像和植被等，适合制作恐怖、哥特风格或黑暗主题的游戏场景。  </li>
<li><strong>Polyquest Worlds Full Pack Vol.1</strong>：低多边形风格的环境资源包，包含地形、植被和建筑素材，适合开发轻量化和卡通风格的游戏项目。</li>
</ol>
<h1 id="模型-材质处理"><a href="#模型-材质处理" class="headerlink" title="模型 &amp; 材质处理"></a>模型 &amp; 材质处理</h1><ol>
<li><strong>AnyPortrait</strong>：一款2D角色动画制作工具，支持骨骼动画、网格变形和物理模拟，适用于快速创建高质量的2D游戏角色动画。  </li>
<li><strong>FBX Utilities</strong>：提供强大的FBX文件导入、导出和优化工具，支持模型格式转换和自动调整，适用于处理外部3D资产的项目需求。  </li>
<li><strong>Mega-Fiers</strong>：模型变形插件，支持网格扭曲、变形动画和骨骼绑定优化，适用于创建独特的3D效果和动态变形场景。  </li>
<li><strong>Mesh Baker</strong>：高效的网格和纹理合并工具，可减少绘制调用和优化性能，适合处理复杂场景中的多个模型和贴图。  </li>
<li><strong>Paint in 3D</strong>：支持在3D模型表面直接绘画的工具，提供多种笔刷效果和实时预览功能，适用于创建贴图和手绘风格的材质。  </li>
<li><strong>UModeler - Model your World</strong>：集建模和关卡设计于一体的插件，支持在Unity内创建和编辑3D模型，适合快速迭代场景与原型设计。  </li>
<li><strong>Surforge</strong>：高效的PBR材质制作工具，支持在3D模型上直接绘制和调整材质细节，适用于快速生成游戏所需的高质量贴图。  </li>
<li><strong>Stylized Water Shader</strong>：水体特效材质插件，支持卡通风格的动态水流、反射和折射效果，适用于增强游戏场景的视觉表现力。  </li>
<li><strong>Shape</strong>：UI设计和动画工具，支持创建复杂的矢量图形、几何动画和路径效果，适用于2D游戏中的UI界面和动态效果设计。</li>
</ol>
<h1 id="杂项功能"><a href="#杂项功能" class="headerlink" title="杂项功能"></a>杂项功能</h1><ol>
<li><strong>Anti-Cheat Toolkit</strong>：提供全面的防作弊工具集，检测并防止各种游戏作弊行为，包括速度修改、内存篡改和无敌模式等，适合保障多人在线游戏的公平性。  </li>
<li><strong>Asset Hunter PRO</strong>：扫描并清理未使用的资源，帮助开发者减少项目体积，提高构建效率，同时避免不必要的资源浪费，适用于优化大型Unity项目。  </li>
<li><strong>CodeGuard</strong>：为Unity项目提供代码保护功能，通过加密和混淆技术防止代码反编译和逆向工程，保护知识产权和项目安全性。  </li>
<li><strong>Obfuscator</strong>：代码混淆工具，通过打乱代码结构和变量命名，增加反编译的难度，适用于保护Unity C#代码免受未经授权的修改和泄露。  </li>
<li><strong>SG Patcher - Update your game easily</strong>：提供内置更新功能，支持热更新和增量更新，方便玩家无需重新下载整个游戏即可获得最新内容。  </li>
<li><strong>Simple LOD</strong>：自动生成简化模型的工具，支持多边形优化和动态LOD切换，适合提升大规模场景渲染性能并减少内存占用。  </li>
<li><strong>Smart Library</strong>：资源管理插件，提供快速搜索、分类和组织功能，帮助开发者更高效地管理和使用项目资源库中的内容。  </li>
<li><strong>Stratis Unity SDK</strong>：为Unity集成区块链技术的开发工具，支持智能合约交互、加密货币支付和去中心化应用开发，适用于区块链游戏项目。  </li>
<li><strong>UEvent</strong>：轻量级事件管理系统，支持松耦合的事件订阅与发布，简化项目逻辑并提高代码的可维护性和可扩展性。  </li>
<li><strong>UFPS: Ultimate FPS</strong>：第一人称射击游戏开发工具，包含角色控制、武器系统和物理模拟，提供快速创建高品质FPS游戏的解决方案。  </li>
<li><strong>UMMORPG</strong>：多功能MMORPG框架，提供角色管理、任务系统、技能树和多人网络功能，适合快速开发大型多人在线角色扮演游戏。  </li>
<li><strong>UMOBA</strong>：多人在线战斗竞技游戏框架，支持角色控制、技能释放和服务器管理，帮助开发者快速搭建MOBA游戏的核心功能。  </li>
<li><strong>Voxel Master</strong>：体素建模与场景生成工具，支持体素化地形编辑、动态破坏和实时渲染，适用于沙盒类游戏和体素艺术创作。</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li><strong>3D WebView</strong>：在Unity中嵌入3D场景中的网页浏览器插件，支持多平台使用，包括VR和移动设备，适用于展示网页内容、流媒体播放及Web功能交互，集成简单且高性能。  </li>
<li><strong>Adventure Creator</strong>：强大的无代码冒险游戏开发工具，适合创建2D、3D冒险游戏，提供场景管理、对话设计、角色控制等功能，支持快速开发和跨平台发布。  </li>
<li><strong>ChainSafe Gaming SDK</strong>：提供Web3区块链功能集成，包括NFT、智能合约和加密货币交易支持，专为区块链游戏开发者设计，助力创建创新的去中心化游戏体验。  </li>
<li><strong>Cross Platform Replay Kit</strong>：录制和分享游戏回放的工具，支持iOS和Android平台，包含视频剪辑和存储功能，增强社交传播能力并提升用户黏性。  </li>
<li><strong>DOOZY UI Manager</strong>：专业UI管理解决方案，支持复杂动画、状态机逻辑和UI组件的快速开发，提升游戏和应用界面的动态表现力与用户体验。  </li>
<li><strong>Dynamic Bone</strong>：为角色的头发、衣物等附加动态物理效果，模拟逼真的动作反馈，适用于增强角色动画的真实感和细腻表现。  </li>
<li><strong>Enviro - Sky and Weather</strong>：一款环境系统插件，提供真实的天气模拟、昼夜循环及环境光效，适合构建沉浸式开放世界和动态环境变化的场景。  </li>
<li><strong>EPO</strong>：粒子效果优化工具，提供高效渲染、复杂视觉效果增强及性能提升功能，适用于需要高质量粒子特效的游戏项目。  </li>
<li><strong>Explosion Sound Effects</strong>：高质量的爆炸音效资源包，适合动作、战争和科幻类游戏场景，包含多种音效组合，为游戏提供强烈的听觉冲击力。  </li>
<li><strong>Feel</strong>：为游戏添加震动、动画和反馈效果的工具，提供预设效果和自定义支持，显著提升游戏互动的精致度和用户沉浸体验。  </li>
<li><strong>Fps Graph Analyzer</strong>：帧率监测与性能分析工具，可实时显示游戏帧率波动、资源消耗数据，帮助开发者定位性能瓶颈并优化流畅性。  </li>
<li><strong>Fullscreen Editor</strong>：提供Unity编辑器全屏模式，减少界面干扰，提升开发专注度和效率，适合在大屏幕或多显示器环境下开发项目。  </li>
<li><strong>Highlighting System</strong>：为游戏对象添加高亮效果，支持动态和静态对象处理，增强交互提示的视觉表现，适用于各种类型的游戏交互设计。  </li>
<li><strong>Hierarchy 2</strong>：增强Unity层级视图管理的插件，支持对象分组、颜色标记和快捷导航，显著提升复杂项目中对象管理和组织效率。  </li>
<li><strong>Lean Touch</strong>：多点触控和手势交互解决方案，支持移动设备缩放、旋转等操作，适用于增强用户体验的移动游戏和AR&#x2F;VR项目。  </li>
<li><strong>Loxodon Framework Bundle</strong>：提供数据绑定、资源管理、UI框架等模块化开发工具，简化Unity项目架构设计，适用于跨平台游戏开发。  </li>
<li><strong>Lua Framework</strong>：为Unity集成Lua脚本支持，提供动态逻辑实现与热更新功能，适合快速开发、更新频繁或需要扩展性的游戏项目。  </li>
<li><strong>Mega-Fiers</strong>：强大的模型变形工具，支持复杂的几何变换、动画和顶点编辑，适用于制作特效、动画和独特的视觉效果。  </li>
<li><strong>Mobile Fast Shadow</strong>：针对移动设备优化的实时阴影工具，提供低性能消耗的光影效果，适合需要高性能运行的移动端游戏。  </li>
<li><strong>Nice Vibration</strong>：添加触觉反馈功能的插件，支持Android和iOS设备，增强玩家与设备的交互感受，适合休闲游戏和应用开发。  </li>
<li><strong>Octave3D-Level Design</strong>：快速搭建3D场景工具，支持模块化场景设计和精确布局编辑，加速关卡和场景的开发过程。  </li>
<li><strong>Platformer PRO 2</strong>：2D平台游戏开发工具，提供物理、角色控制和敌人AI系统，适合快速开发具有复杂关卡的横版动作游戏。  </li>
<li><strong>Rainbow Folders 2</strong>：为Unity项目文件夹添加颜色和图标标记功能，改善可视化管理，提高项目文件夹的可读性与组织效率。  </li>
<li><strong>Rainbow Hierarchy 2</strong>：增强Unity层级视图的管理工具，支持自定义颜色标记和图标，提升复杂项目中对象的分类管理效率。  </li>
<li><strong>Race Track Generator</strong>：赛道生成工具，支持曲线定制和地形编辑，快速创建竞速游戏场景并优化玩家驾驶体验。  </li>
<li><strong>Rewired</strong>：专业的输入管理插件，支持多种设备输入配置和自定义，适用于需要复杂操作支持的游戏项目。  </li>
<li><strong>RPG Character Mecanim Animation Pack</strong>：丰富的角色动画资源包，涵盖战斗、休息、互动动作，适合RPG和冒险类游戏的角色设计。  </li>
<li><strong>RPG Map Editor</strong>：RPG地图编辑器，提供地形创建、物体放置和路径规划功能，适合快速生成RPG游戏场景地图。  </li>
<li><strong>Shape</strong>：支持几何形状创建和动画编辑，适合制作独特视觉效果的游戏开发者和艺术创作者。  </li>
<li><strong>Smooth Sync</strong>：网络位置同步插件，提供高效的多人游戏物体同步，确保联机游戏中的位置和旋转平滑更新。  </li>
<li><strong>Spine Animator</strong>：为Spine骨骼动画添加动态物理效果的插件，提升角色动作表现的自然性和生动感。  </li>
<li><strong>Stan’s Assets</strong>：移动开发工具集，整合广告、插件和本地化服务，适合跨平台移动游戏开发项目。  </li>
<li><strong>Surforge</strong>：高效PBR纹理生成工具，支持实时纹理绘制、材质生成和模型贴图，适合高质量美术资源制作。  </li>
<li><strong>Terrain Composer</strong>：地形生成工具，支持多层次编辑、噪声控制和场景优化，适用于快速设计大型开放世界地形。  </li>
<li><strong>Text Animator for Unity</strong>：为文本添加动画效果的工具，支持多种字体和特效，显著提升UI的动态视觉表现力。  </li>
<li><strong>Toon Shader</strong>：卡通风格着色工具，支持非真实感渲染和动态阴影设置，适合制作动画、卡通类游戏或美术项目。</li>
</ol>
<h1 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h1><ol>
<li><p><a href="/2025/01/08/Lean-Cloud/">LeanCloud</a></p>
<p> LeanCloud 是一个 后端即服务（BaaS，Backend as a Service） 平台，主要为开发者提供一站式的后端服务，帮助开发者快速构建应用程序，无需自己搭建复杂的后端服务器。通过 LeanCloud，开发者可以专注于前端开发和业务逻辑，而后端服务（如数据存储、用户认证、实时消息等）由 LeanCloud 提供并维护。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity 面试总结</title>
    <url>/2025/02/20/unity-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="IT技术类岗位面试一般要问哪些问题？有哪几轮面试？会从哪些方面提问？招聘者想要得到什么信息或者答复？"><a href="#IT技术类岗位面试一般要问哪些问题？有哪几轮面试？会从哪些方面提问？招聘者想要得到什么信息或者答复？" class="headerlink" title="IT技术类岗位面试一般要问哪些问题？有哪几轮面试？会从哪些方面提问？招聘者想要得到什么信息或者答复？"></a>IT技术类岗位面试一般要问哪些问题？有哪几轮面试？会从哪些方面提问？招聘者想要得到什么信息或者答复？</h1><p>IT 技术类岗位的面试通常包括多个环节，具体的面试轮次、问题类型和考察重点取决于 <strong>公司规模、职位级别（初级&#x2F;中级&#x2F;高级）、技术方向（前端&#x2F;后端&#x2F;全栈&#x2F;算法&#x2F;架构&#x2F;游戏开发等）</strong>。以下是 <strong>一般 IT 技术岗面试流程、可能的问题类型、考察点以及面试官的期望</strong>。  </p>
<hr>
<h2 id="📌-IT-技术岗位的常见面试流程"><a href="#📌-IT-技术岗位的常见面试流程" class="headerlink" title="📌 IT 技术岗位的常见面试流程"></a><strong>📌 IT 技术岗位的常见面试流程</strong></h2><p>IT 技术岗的面试一般包括以下 <strong>3-5 轮</strong>：</p>
<ol>
<li><p><strong>简历筛选</strong></p>
<ul>
<li><strong>HR 或技术经理查看简历，筛选符合要求的候选人。</strong></li>
<li>重点关注：工作经验、项目经历、技术栈、教育背景。</li>
</ul>
</li>
<li><p><strong>技术面试（1~2 轮）</strong></p>
<ul>
<li><strong>编程能力、操作系统、网络、数据结构与算法</strong></li>
<li><strong>系统设计 &#x2F; 框架理解</strong></li>
<li><strong>项目经验、解决问题的思路和问题解决能力</strong></li>
<li><strong>代码质量、设计模式、架构理解</strong></li>
</ul>
</li>
<li><p><strong>综合面试（1 轮）</strong></p>
<ul>
<li>团队合作：考察与团队协作的能力。</li>
<li>问题解决：了解面对挑战时的应对方式。</li>
<li>学习能力：询问如何学习新技术，评估自我提升能力。</li>
<li>沟通能力：能否清晰表达技术概念，让非技术人员也能理解。是否具备倾听能力，能够理解他人需求。</li>
<li>抗压能力：强调你的时间管理和优先级排序能力。提到你如何通过团队协作或自我调节缓解压力。</li>
<li>职业规划：<ul>
<li>候选人是否有明确的短期和长期目标。</li>
<li>是否愿意在公司和行业内长期发展。</li>
<li>是否有持续学习和提升的意愿。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>HR 终面</strong></p>
<ul>
<li><strong>薪资、福利、职业规划</strong></li>
<li><strong>团队文化匹配度</strong></li>
<li><strong>背景调查</strong></li>
<li><strong>离职原因</strong></li>
</ul>
</li>
<li><p><strong>主管 &#x2F; 总监面试（部分公司有）</strong></p>
<ul>
<li>技术负责人或高层领导考察 <strong>宏观思维、团队协作、职业稳定性</strong>。</li>
<li>战略思维：针对高级职位，考察对公司业务的理解和战略思考。</li>
<li>领导能力：评估团队管理和领导潜力。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="🔍-技术面试的主要考察方向"><a href="#🔍-技术面试的主要考察方向" class="headerlink" title="🔍 技术面试的主要考察方向"></a><strong>🔍 技术面试的主要考察方向</strong></h2><p>技术面试一般从以下几个方面提问：</p>
<h3 id="1️⃣-计算机基础（必考）"><a href="#1️⃣-计算机基础（必考）" class="headerlink" title="1️⃣ 计算机基础（必考）"></a><strong>1️⃣ 计算机基础（必考）</strong></h3><p>主要考察 <strong>计算机科学核心知识</strong>，包括：</p>
<ul>
<li><p><strong>数据结构与算法</strong></p>
<ul>
<li>常见数据结构（数组、链表、栈、队列、哈希表、树、图等）。</li>
<li>算法：排序、查找、递归、动态规划、贪心算法、回溯等。</li>
<li>复杂度分析（时间复杂度 &amp; 空间复杂度）。</li>
</ul>
</li>
<li><p><strong>操作系统</strong></p>
<ul>
<li>进程 vs 线程、线程同步、死锁、内存管理（分页&#x2F;分段）、I&#x2F;O、多线程并发。</li>
</ul>
</li>
<li><p><strong>计算机网络</strong></p>
<ul>
<li>TCP vs UDP，三次握手 &amp; 四次挥手，HTTP&#x2F;HTTPS，DNS解析，Socket 编程。</li>
</ul>
</li>
<li><p><strong>数据库</strong></p>
<ul>
<li>SQL（增删改查、索引、事务、锁机制）。</li>
<li>NoSQL（MongoDB、Redis 等）。</li>
<li>数据库优化 &amp; 事务 ACID 原理。</li>
</ul>
</li>
</ul>
<p><strong>💡 面试官关注点：</strong></p>
<ul>
<li><strong>你的计算机基础是否扎实？</strong></li>
<li><strong>是否能合理优化代码，解决性能问题？</strong></li>
<li><strong>是否理解底层原理，而不是单纯调用 API？</strong></li>
</ul>
<hr>
<h3 id="2️⃣-编程能力-代码风格"><a href="#2️⃣-编程能力-代码风格" class="headerlink" title="2️⃣ 编程能力 &amp; 代码风格"></a><strong>2️⃣ 编程能力 &amp; 代码风格</strong></h3><p><strong>典型问题：</strong></p>
<ul>
<li><strong>手写算法题</strong>（如：二叉树遍历、链表反转、字符串处理）。</li>
<li><strong>写一个类，设计合适的数据结构，保证高效查询、插入、删除等操作</strong>。</li>
<li><strong>多线程编程：如何实现线程安全的单例模式？如何避免死锁？</strong></li>
</ul>
<p><strong>💡 面试官关注点：</strong></p>
<ul>
<li><strong>代码是否简洁、可读、可维护？</strong></li>
<li><strong>是否能用高效的方式解决问题？</strong></li>
<li><strong>是否具备良好的编码习惯？（命名规范、异常处理、边界情况等）</strong></li>
</ul>
<hr>
<h3 id="3️⃣-框架-语言特性"><a href="#3️⃣-框架-语言特性" class="headerlink" title="3️⃣ 框架 &#x2F; 语言特性"></a><strong>3️⃣ 框架 &#x2F; 语言特性</strong></h3><p>根据职位方向，考察对应的技术栈：</p>
<ul>
<li><p><strong>前端开发（React &#x2F; Vue &#x2F; TypeScript）</strong></p>
<ul>
<li>虚拟 DOM、Diff 算法、前端性能优化。</li>
<li>Webpack、Vite、组件化开发、前端工程化。</li>
<li>跨域问题、前端安全（XSS、CSRF）。</li>
</ul>
</li>
<li><p><strong>后端开发（Java &#x2F; C# &#x2F; Python &#x2F; Node.js）</strong></p>
<ul>
<li>线程 &amp; 进程、内存管理、垃圾回收机制。</li>
<li>高并发 &amp; 分布式架构（如：微服务、RPC）。</li>
<li>设计模式（单例、工厂、观察者、策略模式等）。</li>
</ul>
</li>
<li><p><strong>游戏开发（Unity &#x2F; Unreal &#x2F; C++）</strong></p>
<ul>
<li>游戏引擎架构、渲染管线、物理系统、动画系统。</li>
<li>ECS（实体组件系统）、Unity Shader &#x2F; UE 蓝图。</li>
<li>资源管理、性能优化、内存管理。</li>
</ul>
</li>
</ul>
<p><strong>💡 面试官关注点：</strong></p>
<ul>
<li><strong>你对框架&#x2F;工具是否熟练？能否写出高效代码？</strong></li>
<li><strong>是否理解底层原理，而不是只会使用？</strong></li>
<li><strong>是否有解决复杂问题的能力？</strong></li>
</ul>
<hr>
<h3 id="4️⃣-系统设计-架构"><a href="#4️⃣-系统设计-架构" class="headerlink" title="4️⃣ 系统设计 &amp; 架构"></a><strong>4️⃣ 系统设计 &amp; 架构</strong></h3><p>针对 <strong>中高级工程师</strong>，考察：</p>
<ul>
<li><strong>如何设计一个高可用的系统？</strong></li>
<li><strong>如何优化数据库查询，避免性能瓶颈？</strong></li>
<li><strong>微服务 vs 单体架构的优缺点？</strong></li>
<li><strong>如何设计一个缓存系统，防止缓存击穿？</strong></li>
</ul>
<p><strong>💡 面试官关注点：</strong></p>
<ul>
<li><strong>你是否有全局思维，能设计可扩展的架构？</strong></li>
<li><strong>能否平衡性能、稳定性和成本？</strong></li>
<li><strong>是否有大型项目经验？</strong></li>
</ul>
<hr>
<h3 id="5️⃣-项目经验-解决问题能力"><a href="#5️⃣-项目经验-解决问题能力" class="headerlink" title="5️⃣ 项目经验 &amp; 解决问题能力"></a><strong>5️⃣ 项目经验 &amp; 解决问题能力</strong></h3><p><strong>可能的问题：</strong></p>
<ul>
<li>介绍你做过的项目，遇到哪些挑战？如何解决？</li>
<li>你在项目中负责什么？团队如何协作？</li>
<li>你的代码优化思路是什么？</li>
</ul>
<p><strong>💡 面试官关注点：</strong></p>
<ul>
<li><strong>你是否能独立解决问题？</strong></li>
<li><strong>是否真正理解项目架构？</strong></li>
<li><strong>是否具备团队合作能力？</strong></li>
</ul>
<hr>
<h3 id="6️⃣-软技能-团队合作"><a href="#6️⃣-软技能-团队合作" class="headerlink" title="6️⃣ 软技能 &amp; 团队合作"></a><strong>6️⃣ 软技能 &amp; 团队合作</strong></h3><p><strong>常见问题</strong></p>
<ul>
<li>你遇到过最难的问题是什么？如何解决？</li>
<li>你如何处理团队冲突？</li>
<li>你的职业规划是什么？</li>
</ul>
<p><strong>💡 面试官关注点：</strong></p>
<ul>
<li><strong>你的沟通能力如何？</strong></li>
<li><strong>是否愿意学习新技术？</strong></li>
<li><strong>是否适合团队文化？</strong></li>
</ul>
<hr>
<h2 id="🎯-面试官希望得到的信息"><a href="#🎯-面试官希望得到的信息" class="headerlink" title="🎯 面试官希望得到的信息"></a><strong>🎯 面试官希望得到的信息</strong></h2><table>
<thead>
<tr>
<th>面试维度</th>
<th>期望信息</th>
</tr>
</thead>
<tbody><tr>
<td><strong>技术能力</strong></td>
<td>是否具备扎实的计算机基础和编程能力？</td>
</tr>
<tr>
<td><strong>解决问题能力</strong></td>
<td>是否能高效解决复杂问题？</td>
</tr>
<tr>
<td><strong>项目经验</strong></td>
<td>过去的项目经历是否和岗位匹配？</td>
</tr>
<tr>
<td><strong>团队合作</strong></td>
<td>是否善于沟通、协作？</td>
</tr>
<tr>
<td><strong>学习能力</strong></td>
<td>是否愿意学习新技术？是否具备成长潜力？</td>
</tr>
</tbody></table>
<hr>
<h2 id="📌-总结"><a href="#📌-总结" class="headerlink" title="📌 总结"></a><strong>📌 总结</strong></h2><ol>
<li><strong>面试一般有 3~5 轮</strong>（技术面 + 综合面 + HR 面）。</li>
<li><strong>核心考察点：计算机基础、编程能力、项目经验、架构设计、团队合作</strong>。</li>
<li><strong>面试官希望了解你的问题解决能力、代码质量、技术深度以及成长潜力</strong>。</li>
</ol>
<p>🎯 <strong>如果你能在技术 + 项目 + 软技能方面表现出色，就能顺利通过面试！</strong> 🚀</p>
<h2 id="HR问离职原因的初衷"><a href="#HR问离职原因的初衷" class="headerlink" title="HR问离职原因的初衷"></a>HR问离职原因的初衷</h2><p>HR在面试中询问<strong>离职原因</strong>，主要是为了从多个维度了解候选人，评估其是否适合公司和岗位。以下是HR提问离职原因的<strong>初衷</strong>和<strong>关注点</strong>：</p>
<hr>
<h3 id="1-了解候选人的职业动机"><a href="#1-了解候选人的职业动机" class="headerlink" title="1. 了解候选人的职业动机"></a>1. <strong>了解候选人的职业动机</strong></h3><ul>
<li><strong>初衷</strong>：HR希望通过离职原因了解候选人的职业追求和价值观。</li>
<li><strong>关注点</strong>：<ul>
<li>候选人是否因为缺乏成长机会而离职？</li>
<li>是否因为对工作内容或公司文化不满？</li>
<li>是否因为薪资、福利或职业发展受限？</li>
</ul>
</li>
<li><strong>目的</strong>：判断候选人的职业目标是否与公司提供的机会匹配。</li>
</ul>
<hr>
<h3 id="2-评估候选人的稳定性"><a href="#2-评估候选人的稳定性" class="headerlink" title="2. 评估候选人的稳定性"></a>2. <strong>评估候选人的稳定性</strong></h3><ul>
<li><strong>初衷</strong>：HR希望了解候选人的离职是否合理，是否存在频繁跳槽的倾向。</li>
<li><strong>关注点</strong>：<ul>
<li>候选人是否因为短期问题（如人际关系、压力）轻易离职？</li>
<li>是否因为对公司或岗位缺乏深入了解而频繁更换工作？</li>
</ul>
</li>
<li><strong>目的</strong>：判断候选人是否能在公司长期发展，降低招聘成本。</li>
</ul>
<hr>
<h3 id="3-了解候选人的工作态度"><a href="#3-了解候选人的工作态度" class="headerlink" title="3. 了解候选人的工作态度"></a>3. <strong>了解候选人的工作态度</strong></h3><ul>
<li><strong>初衷</strong>：HR希望通过离职原因了解候选人对工作的态度和责任感。</li>
<li><strong>关注点</strong>：<ul>
<li>候选人是否因为逃避问题（如压力、挑战）而离职？</li>
<li>是否因为与团队或上级关系不佳而离职？</li>
</ul>
</li>
<li><strong>目的</strong>：判断候选人是否具备积极的工作态度和团队合作精神。</li>
</ul>
<hr>
<h3 id="4-排除潜在风险"><a href="#4-排除潜在风险" class="headerlink" title="4. 排除潜在风险"></a>4. <strong>排除潜在风险</strong></h3><ul>
<li><strong>初衷</strong>：HR希望排除候选人可能带来的潜在风险。</li>
<li><strong>关注点</strong>：<ul>
<li>候选人是否因为绩效问题被辞退？</li>
<li>是否因为违反公司规定或职业道德而离职？</li>
</ul>
</li>
<li><strong>目的</strong>：确保候选人没有隐藏的不良记录或行为。</li>
</ul>
<hr>
<h3 id="5-判断候选人与公司文化的契合度"><a href="#5-判断候选人与公司文化的契合度" class="headerlink" title="5. 判断候选人与公司文化的契合度"></a>5. <strong>判断候选人与公司文化的契合度</strong></h3><ul>
<li><strong>初衷</strong>：HR希望通过离职原因了解候选人对公司文化的偏好。</li>
<li><strong>关注点</strong>：<ul>
<li>候选人是否因为不适应前公司的文化而离职？</li>
<li>是否因为希望寻找更符合自己价值观的工作环境？</li>
</ul>
</li>
<li><strong>目的</strong>：判断候选人是否适合当前公司的文化和团队氛围。</li>
</ul>
<hr>
<h3 id="6-为候选人提供更好的机会"><a href="#6-为候选人提供更好的机会" class="headerlink" title="6. 为候选人提供更好的机会"></a>6. <strong>为候选人提供更好的机会</strong></h3><ul>
<li><strong>初衷</strong>：HR希望通过了解离职原因，为候选人提供更适合的岗位或发展机会。</li>
<li><strong>关注点</strong>：<ul>
<li>候选人是否因为缺乏挑战或发展空间而离职？</li>
<li>是否因为对某些工作条件（如远程办公、弹性时间）有特殊需求？</li>
</ul>
</li>
<li><strong>目的</strong>：确保公司能够满足候选人的需求，提升招聘成功率。</li>
</ul>
<hr>
<h3 id="HR希望听到的回答："><a href="#HR希望听到的回答：" class="headerlink" title="HR希望听到的回答："></a>HR希望听到的回答：</h3><ol>
<li><strong>积极正面的原因</strong>：<ul>
<li>寻求更好的职业发展机会。</li>
<li>希望尝试新的领域或挑战。</li>
<li>前公司发展方向与个人职业规划不一致。</li>
</ul>
</li>
<li><strong>客观合理的原因</strong>：<ul>
<li>公司裁员或业务调整。</li>
<li>地理位置或家庭原因。</li>
<li>合同到期或项目结束。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="HR不希望听到的回答："><a href="#HR不希望听到的回答：" class="headerlink" title="HR不希望听到的回答："></a>HR不希望听到的回答：</h3><ol>
<li><strong>消极负面的原因</strong>：<ul>
<li>抱怨前公司或同事。</li>
<li>因为人际关系问题离职。</li>
<li>因为工作压力大或任务繁重而逃避。</li>
</ul>
</li>
<li><strong>模糊或不真实的原因</strong>：<ul>
<li>说不清离职原因。</li>
<li>隐瞒真实原因，显得不够坦诚。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何回答离职原因："><a href="#如何回答离职原因：" class="headerlink" title="如何回答离职原因："></a>如何回答离职原因：</h3><ol>
<li><strong>保持积极态度</strong>：避免批评前公司或同事，专注于个人成长和发展。</li>
<li><strong>突出职业规划</strong>：强调你希望寻找更好的发展机会，与新岗位的目标一致。</li>
<li><strong>简洁明了</strong>：不要过度解释，点到为止，保持真诚。</li>
</ol>
<p><strong>示例回答</strong>：</p>
<ul>
<li>“我在前公司学到了很多，但希望寻找一个更具挑战性的岗位，能够更好地发挥我的技术优势。”</li>
<li>“前公司因为业务调整，我的职业发展方向与公司规划不一致，所以选择寻找新的机会。”</li>
<li>“我希望在一个更注重创新和团队合作的环境中工作，这与贵公司的文化非常契合。”</li>
</ul>
<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>HR提问离职原因，主要是为了评估候选人的职业动机、稳定性、工作态度和与公司文化的契合度。通过积极、合理的回答，你可以展现自己的职业素养和发展潜力，增加面试成功率。</p>
]]></content>
  </entry>
  <entry>
    <title>unity插件导入方式</title>
    <url>/2025/02/05/unity%E6%8F%92%E4%BB%B6%E5%AF%BC%E5%85%A5%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Unity-UPM-形式导入-vs-传统-Package-形式导入：区别与优劣"><a href="#Unity-UPM-形式导入-vs-传统-Package-形式导入：区别与优劣" class="headerlink" title="Unity UPM 形式导入 vs. 传统 Package 形式导入：区别与优劣"></a><strong>Unity UPM 形式导入 vs. 传统 Package 形式导入：区别与优劣</strong></h1><p>在 Unity 中导入插件主要有两种方式：  </p>
<ol>
<li><strong>UPM（Unity Package Manager）形式导入</strong>  </li>
<li><strong>传统 Package 形式（直接拷贝到 <code>Assets/</code> 目录）</strong></li>
</ol>
<p>它们各有优势和适用场景，下面详细对比一下。  </p>
<hr>
<h2 id="🔹-UPM-形式导入（Unity-Package-Manager）"><a href="#🔹-UPM-形式导入（Unity-Package-Manager）" class="headerlink" title="🔹 UPM 形式导入（Unity Package Manager）"></a><strong>🔹 UPM 形式导入（Unity Package Manager）</strong></h2><h3 id="✅-优势："><a href="#✅-优势：" class="headerlink" title="✅ 优势："></a><strong>✅ 优势：</strong></h3><ul>
<li><strong>版本管理</strong>：可以通过 <code>Packages/manifest.json</code> 直接管理插件版本，方便回退和升级。  </li>
<li><strong>依赖管理</strong>：UPM 会自动解析插件的依赖项，避免手动安装额外的库或 DLL 文件。  </li>
<li><strong>项目更整洁</strong>：导入的插件存放在 <code>Packages/</code> 目录下，不会污染 <code>Assets/</code> 目录，使项目结构更清晰。  </li>
<li><strong>便捷更新</strong>：可以直接从 Unity Registry、Git 或本地路径安装和更新插件，不需要手动替换文件。  </li>
<li><strong>团队协作</strong>：Git 版本控制时，只需要提交 <code>manifest.json</code>，无需提交整个插件代码，减少代码库体积。</li>
</ul>
<h3 id="❌-缺点："><a href="#❌-缺点：" class="headerlink" title="❌ 缺点："></a><strong>❌ 缺点：</strong></h3><ul>
<li><strong>离线访问受限</strong>：如果插件是从 Unity Registry 或 Git 拉取的，可能需要联网才能安装。  </li>
<li><strong>本地修改麻烦</strong>：UPM 目录默认是“只读”的，想要修改插件代码需要额外步骤（可以通过 <code>Packages</code> 目录手动调整或克隆到 <code>Assets</code>）。</li>
</ul>
<hr>
<h2 id="🔹-传统-Package-形式导入（直接放入-Assets-）"><a href="#🔹-传统-Package-形式导入（直接放入-Assets-）" class="headerlink" title="🔹 传统 Package 形式导入（直接放入 Assets/）"></a><strong>🔹 传统 Package 形式导入（直接放入 <code>Assets/</code>）</strong></h2><h3 id="✅-优势：-1"><a href="#✅-优势：-1" class="headerlink" title="✅ 优势："></a><strong>✅ 优势：</strong></h3><ul>
<li><strong>即拿即用</strong>：直接拷贝到 <code>Assets/</code> 目录，无需依赖网络，适合不支持 UPM 的插件。  </li>
<li><strong>易于修改</strong>：插件源码就在项目里，可以直接修改、调试，适合二次开发。  </li>
<li><strong>适配旧版本</strong>：某些老旧插件或第三方工具可能没有 UPM 支持，传统方式更适合。</li>
</ul>
<h3 id="❌-缺点：-1"><a href="#❌-缺点：-1" class="headerlink" title="❌ 缺点："></a><strong>❌ 缺点：</strong></h3><ul>
<li><strong>难以管理版本</strong>：升级插件时可能需要手动删除旧版本并重新导入，容易导致版本混乱。  </li>
<li><strong>项目污染</strong>：所有插件代码和资源混在 <code>Assets/</code> 目录，项目一大就变得难以维护。  </li>
<li><strong>依赖问题</strong>：如果插件需要额外的 DLL 或依赖库，可能需要手动配置，增加维护成本。</li>
</ul>
<hr>
<h2 id="🔹-哪种方式更适合？"><a href="#🔹-哪种方式更适合？" class="headerlink" title="🔹 哪种方式更适合？"></a><strong>🔹 哪种方式更适合？</strong></h2><table>
<thead>
<tr>
<th>适用场景</th>
<th>UPM 形式导入</th>
<th>传统 Package 形式导入</th>
</tr>
</thead>
<tbody><tr>
<td><strong>插件版本管理</strong></td>
<td>✅ 自动管理版本，可回退</td>
<td>❌ 需要手动删除和更新</td>
</tr>
<tr>
<td><strong>依赖管理</strong></td>
<td>✅ 自动解析依赖项</td>
<td>❌ 可能需要手动配置</td>
</tr>
<tr>
<td><strong>项目结构整洁</strong></td>
<td>✅ 插件放 <code>Packages/</code> 目录</td>
<td>❌ 插件和代码混在 <code>Assets/</code></td>
</tr>
<tr>
<td><strong>网络依赖</strong></td>
<td>❌ 可能需要联网安装</td>
<td>✅ 完全离线使用</td>
</tr>
<tr>
<td><strong>源码修改</strong></td>
<td>❌ 需要手动克隆到 <code>Assets/</code></td>
<td>✅ 直接修改</td>
</tr>
<tr>
<td><strong>团队协作</strong></td>
<td>✅ Git 只需同步 <code>manifest.json</code></td>
<td>❌ 插件代码需要提交到 Git</td>
</tr>
</tbody></table>
<h3 id="📌-结论："><a href="#📌-结论：" class="headerlink" title="📌 结论："></a><strong>📌 结论：</strong></h3><ul>
<li><strong>如果插件支持 UPM，并且你不需要修改源码</strong>，建议使用 <strong>UPM</strong>，这样可以更好地管理版本和依赖，保持项目整洁。  </li>
<li><strong>如果插件不支持 UPM，或者你需要修改源码、进行二次开发</strong>，传统的 <code>Assets/</code> 方式更合适。</li>
</ul>
<h1 id="Git-本地-UPM（与游戏业务逻辑分开管理版本）"><a href="#Git-本地-UPM（与游戏业务逻辑分开管理版本）" class="headerlink" title="Git + 本地 UPM（与游戏业务逻辑分开管理版本）"></a>Git + 本地 UPM（与游戏业务逻辑分开管理版本）</h1><p>使用 <strong>Git + 本地 UPM</strong> 方式管理 <strong>UnityGameFramework 插件</strong> 是一个非常灵活且高效的方式，尤其适合你想要自定义框架或保持插件版本控制的情况。这样你既能通过 Git 管理插件版本，又能通过 <strong>Unity Package Manager (UPM)</strong> 管理项目依赖。</p>
<h3 id="如何实现-Git-本地-UPM-管理-UnityGameFramework-插件"><a href="#如何实现-Git-本地-UPM-管理-UnityGameFramework-插件" class="headerlink" title="如何实现 Git + 本地 UPM 管理 UnityGameFramework 插件"></a><strong>如何实现 Git + 本地 UPM 管理 UnityGameFramework 插件</strong></h3><h4 id="步骤-1：使用-Git-管理-UnityGameFramework-插件"><a href="#步骤-1：使用-Git-管理-UnityGameFramework-插件" class="headerlink" title="步骤 1：使用 Git 管理 UnityGameFramework 插件"></a><strong>步骤 1：使用 Git 管理 UnityGameFramework 插件</strong></h4><p>首先，假设你已经将 <strong>UnityGameFramework</strong> 插件仓库克隆到本地，并且想将其作为 <strong>UPM 本地包</strong> 引入你的 Unity 项目。</p>
<ol>
<li><p><strong>克隆 UnityGameFramework 插件仓库到本地：</strong><br>在你的工作目录下，克隆 UnityGameFramework 插件仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/UnityGameFramework/UnityGameFramework.git D:/UnityGameFramework</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始化和更新子模块</strong>（如果插件使用了 Git 子模块）：<br>如果插件仓库使用了子模块，确保你已经初始化并更新子模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="步骤-2：配置本地-UPM-包"><a href="#步骤-2：配置本地-UPM-包" class="headerlink" title="步骤 2：配置本地 UPM 包"></a><strong>步骤 2：配置本地 UPM 包</strong></h4><ol>
<li><p><strong>修改主项目的 <code>manifest.json</code> 文件</strong>：<br>你需要修改 Unity 项目的 <code>Packages/manifest.json</code> 文件，将本地 UnityGameFramework 插件作为依赖项添加到其中。打开 <code>manifest.json</code> 文件，在 <code>&quot;dependencies&quot;</code> 部分加入你的本地路径。</p>
<p>假设你已经将 UnityGameFramework 插件克隆到 <code>D:/UnityGameFramework</code>，那么可以这样添加：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;com.gameframework&quot;</span><span class="punctuation">:</span> <span class="string">&quot;file:D:/UnityGameFramework&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这会告诉 Unity 从你本地的 <code>D:/UnityGameFramework</code> 路径加载 UnityGameFramework 插件。</p>
</li>
<li><p><strong>检查文件夹结构</strong>：<br>确保本地的 UnityGameFramework 插件目录结构符合 UPM 的要求。插件根目录下应该包含 <code>package.json</code> 文件，这是 UPM 识别包的必要文件。如果没有，你可以参考其他 UPM 包的结构，手动添加或修改。</p>
<p>插件的基本结构应该类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UnityGameFramework/</span><br><span class="line">├── package.json</span><br><span class="line">├── Runtime/</span><br><span class="line">├── Editor/</span><br><span class="line">└── Documentation~</span><br></pre></td></tr></table></figure>

<p>在 <code>package.json</code> 文件中，你需要指定插件的版本号、名称和其他元数据，例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.gameframework&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;displayName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Unity Game Framework&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A lightweight game framework for Unity.&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;unity&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="步骤-3：同步本地插件更新"><a href="#步骤-3：同步本地插件更新" class="headerlink" title="步骤 3：同步本地插件更新"></a><strong>步骤 3：同步本地插件更新</strong></h4><ol>
<li><p><strong>从 Git 更新插件</strong>：<br>当你想要更新本地 UnityGameFramework 插件时，只需要在插件目录下拉取最新的代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:/UnityGameFramework</span><br><span class="line">git pull origin main</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提交更新到主项目</strong>：<br>如果更新了插件的代码，记得返回主项目目录并提交子模块的更新，确保每个团队成员都使用相同版本的插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/your/unity/project</span><br><span class="line">git add Packages/GameFramework</span><br><span class="line">git commit -m <span class="string">&quot;Update UnityGameFramework to the latest version&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查并确保本地插件的依赖正确</strong>：<br>每次更新插件时，确保你没有遗漏插件依赖的任何库或组件。如果插件有额外的资源，检查是否需要重新导入或更新。</p>
</li>
</ol>
<h4 id="步骤-4：团队协作和版本控制"><a href="#步骤-4：团队协作和版本控制" class="headerlink" title="步骤 4：团队协作和版本控制"></a><strong>步骤 4：团队协作和版本控制</strong></h4><ol>
<li><p><strong>共享插件版本</strong>：<br>团队成员需要确保他们的本地仓库和主项目仓库同步。如果你通过 Git 管理子模块，也可以通过 Git 子模块来同步插件的更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>推送主项目和插件更改</strong>：<br>更新完插件或修改完主项目后，推送主项目的更改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>克隆项目时使用本地 UPM 插件</strong>：<br>当团队成员克隆项目时，他们只需要确保从 Git 拉取子模块并更新本地插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点：</strong></h2><ol>
<li><p><strong>版本控制管理：</strong><br>通过 Git，你可以管理 UnityGameFramework 插件的所有版本，轻松回滚到以前的版本或者与主项目同步最新代码。</p>
</li>
<li><p><strong>本地开发和修改：</strong><br>如果需要对插件进行定制或修改，你可以在本地修改框架代码，并将其提交到 Git 仓库，不会影响主项目的其他代码。</p>
</li>
<li><p><strong>清晰的项目结构：</strong><br>使用 UPM 将插件管理与项目代码解耦，保持项目的清洁和组织性，同时支持本地路径方式，避免了直接将框架代码嵌入到 <code>Assets/</code> 目录中。</p>
</li>
<li><p><strong>支持多人协作：</strong><br>团队成员可以通过 Git 子模块或 <code>manifest.json</code> 文件统一插件版本，避免了因版本不一致而产生的错误。</p>
</li>
<li><p><strong>插件更新便捷：</strong><br>每次更新插件时，只需要在主项目中执行 <code>git submodule update --remote</code> 即可轻松更新到插件的最新版本。</p>
</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>使用 <strong>Git + 本地 UPM</strong> 管理 <strong>UnityGameFramework 插件</strong> 可以充分利用 Git 的版本控制和 UPM 的包管理功能。它让你能够灵活管理插件版本，同时保持项目结构的清洁，便于多人协作和框架定制。对于需要自定义的插件或长期维护的项目，Git + 本地 UPM 方式是一个非常强大且方便的选择。</p>
<p>如果有具体操作上的问题或者想进一步了解如何处理更新、团队协作等，随时告诉我！😊</p>
<h1 id="Git-UPM-统一管理版本"><a href="#Git-UPM-统一管理版本" class="headerlink" title="Git + UPM (统一管理版本)"></a>Git + UPM (统一管理版本)</h1><p>将 <strong>UnityGameFramework 插件</strong> 拷贝到Assets父级目录中，这样既不会污染Assets，同时还让游戏框架的代码随工程项目一起，提交git,但是不能控制框架代码的版本。</p>
<p>将 <strong>UnityGameFramework 插件</strong> 拷贝到 <code>Assets</code> 父级目录中，并通过 <strong>Git</strong> 管理项目代码，而不使用 <strong>UPM</strong> 形式的方式，确实是一种常见的做法。它有一些优点，但也存在一些明显的缺点。下面我们详细分析一下这种做法的 <strong>好处</strong> 和 <strong>问题</strong>。</p>
<hr>
<h2 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a><strong>优点：</strong></h2><h3 id="1-框架代码与项目代码一起管理"><a href="#1-框架代码与项目代码一起管理" class="headerlink" title="1. 框架代码与项目代码一起管理"></a><strong>1. 框架代码与项目代码一起管理</strong></h3><ul>
<li><strong>紧密集成</strong>：插件代码和游戏项目代码在同一 Git 仓库中管理，便于团队开发时统一管理和控制，不需要考虑 UPM 形式的插件版本和依赖问题。</li>
<li><strong>简化流程</strong>：在项目中直接修改框架代码非常方便，避免了使用 UPM 需要克隆或额外管理的步骤，开发者可以直接在 <code>Assets/</code> 目录修改和调试插件代码。</li>
</ul>
<h3 id="2-版本控制与跟踪"><a href="#2-版本控制与跟踪" class="headerlink" title="2. 版本控制与跟踪"></a><strong>2. 版本控制与跟踪</strong></h3><ul>
<li><strong>直接版本控制</strong>：将插件直接集成到项目代码库，可以跟随项目一起提交和更新。每个修改都可以进行版本控制，且可以在项目更新时同步更新框架代码。</li>
<li><strong>Git 提交</strong>：由于框架和项目代码在同一仓库，所有修改都可以一起提交和同步，避免了手动管理框架版本的问题。</li>
</ul>
<h3 id="3-便于调试和定制"><a href="#3-便于调试和定制" class="headerlink" title="3. 便于调试和定制"></a><strong>3. 便于调试和定制</strong></h3><ul>
<li><strong>直接修改框架代码</strong>：如果需要修改框架的实现或调试某个功能，可以直接在 <code>Assets/</code> 目录中找到相关代码，修改时不需要额外处理包管理。</li>
<li><strong>定制化更方便</strong>：你可以更轻松地根据项目需求定制游戏框架，无需担心 UPM 形式插件的限制。</li>
</ul>
<h3 id="4-没有外部依赖"><a href="#4-没有外部依赖" class="headerlink" title="4. 没有外部依赖"></a><strong>4. 没有外部依赖</strong></h3><ul>
<li><strong>无需网络依赖</strong>：不像 UPM 需要通过网络拉取插件，所有的框架代码都存储在本地，项目可以完全离线工作，避免了网络问题对开发环境的影响。</li>
<li><strong>简单易用</strong>：这种方法相对简单，特别是在 Unity 的较旧版本中，可能没有完全集成 UPM 系统。</li>
</ul>
<hr>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a><strong>缺点：</strong></h2><h3 id="1-不能轻松管理框架版本"><a href="#1-不能轻松管理框架版本" class="headerlink" title="1. 不能轻松管理框架版本"></a><strong>1. 不能轻松管理框架版本</strong></h3><ul>
<li><strong>版本控制缺失</strong>：将框架代码直接包含在项目中，你无法像 UPM 那样轻松地管理插件的版本（回滚、更新、替换等）。如果框架代码发生更新，你需要手动更新并提交，而这可能导致多个项目中框架版本不一致。</li>
<li><strong>手动管理更新</strong>：每次框架有更新时，需要手动获取新版本，直接替换或合并代码。没有 UPM 那样的包管理系统，更新流程更容易出错。</li>
</ul>
<h3 id="2-项目结构可能变得混乱"><a href="#2-项目结构可能变得混乱" class="headerlink" title="2. 项目结构可能变得混乱"></a><strong>2. 项目结构可能变得混乱</strong></h3><ul>
<li><strong><code>Assets/</code> 目录可能污染</strong>：框架代码存放在项目的 <code>Assets/</code> 目录外面，虽然不会直接污染 <code>Assets/</code> 目录，但可能会导致项目文件夹结构变得复杂，尤其是当框架代码需要频繁更新和修改时。</li>
<li><strong>文件夹管理问题</strong>：将框架代码放在 <code>Assets</code> 父级目录下，可能会导致一些资源或脚本文件和项目的其他部分混杂，影响项目管理和可维护性，尤其是大型项目。</li>
</ul>
<h3 id="3-难以与其他项目共享框架"><a href="#3-难以与其他项目共享框架" class="headerlink" title="3. 难以与其他项目共享框架"></a><strong>3. 难以与其他项目共享框架</strong></h3><ul>
<li><strong>无法轻松复用</strong>：如果你在多个项目中都使用同一个框架，每次更新框架代码时，你需要手动同步到每个项目中。这比起 UPM 的方式要麻烦得多，尤其是在框架更新频繁时。</li>
<li><strong>跨项目依赖管理复杂</strong>：无法通过 Git 子模块、UPM 等方式方便地共享框架代码，这使得跨多个项目的框架维护变得更复杂。</li>
</ul>
<h3 id="4-框架与主项目耦合"><a href="#4-框架与主项目耦合" class="headerlink" title="4. 框架与主项目耦合"></a><strong>4. 框架与主项目耦合</strong></h3><ul>
<li><strong>框架修改难以隔离</strong>：框架和主项目代码紧密耦合，难以做到框架代码和主项目代码的解耦。即使你修改框架代码，这些修改也会直接影响主项目，可能会导致框架变更与主项目变更之间的混淆。</li>
</ul>
<h3 id="5-不易维护长期项目"><a href="#5-不易维护长期项目" class="headerlink" title="5. 不易维护长期项目"></a><strong>5. 不易维护长期项目</strong></h3><ul>
<li><strong>长期维护困难</strong>：当框架代码在多个项目中频繁使用时，版本更新和维护的工作量会增加，尤其是涉及到 bug 修复或框架功能扩展时。你可能需要针对不同的项目做不同的框架版本管理，这会导致维护工作变得更加复杂。</li>
</ul>
<hr>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h2><table>
<thead>
<tr>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>框架与项目代码紧密集成，便于管理和定制</td>
<td>无法轻松管理框架版本，缺乏版本控制机制</td>
</tr>
<tr>
<td>版本控制方便，代码和项目同步提交</td>
<td>项目结构可能变得混乱，尤其在大型项目中</td>
</tr>
<tr>
<td>便于调试和修改框架代码</td>
<td>难以与多个项目共享框架代码</td>
</tr>
<tr>
<td>无需外部依赖，简单易用</td>
<td>框架与主项目耦合，难以解耦</td>
</tr>
<tr>
<td>适合小型或单一项目开发</td>
<td>长期项目维护复杂，版本更新困难</td>
</tr>
</tbody></table>
<hr>
<h2 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a><strong>适用场景：</strong></h2><ul>
<li><strong>适用小型或中型项目</strong>：如果你在开发一个单一的项目，并且框架的功能和版本不会频繁更新，这种方式是一个简单、直接且方便的解决方案。</li>
<li><strong>适用项目需求高度定制的场景</strong>：当你需要在项目中大量修改框架代码，或框架本身比较简单时，这种方式能让你方便快捷地进行调试和开发。</li>
</ul>
<h2 id="不推荐场景："><a href="#不推荐场景：" class="headerlink" title="不推荐场景："></a><strong>不推荐场景：</strong></h2><ul>
<li><strong>长期维护的项目</strong>：如果你的框架是长期维护，并且有多个项目需要使用，或者框架的版本更新频繁，UPM 或 Git Submodule 形式会更适合，能方便管理和共享框架代码。</li>
</ul>
<hr>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a><strong>结论：</strong></h3><p>将 <strong>UnityGameFramework 插件</strong> 直接放入 <code>Assets/</code> 父级目录并通过 Git 管理，适合 <strong>小型项目</strong> 或 <strong>定制化需求高的项目</strong>，但对于 <strong>长期维护、多个项目使用的框架</strong>，使用 <strong>UPM</strong> 或 <strong>Git Submodule</strong> 等更合适，因为它们能够更好地管理框架版本、提高代码的可维护性并支持多个项目之间的共享。</p>
]]></content>
  </entry>
  <entry>
    <title>vs隐藏unity插件在解决方案列表中显示</title>
    <url>/2025/01/07/vs%E9%9A%90%E8%97%8Funity%E6%8F%92%E4%BB%B6%E5%9C%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%88%97%E8%A1%A8%E4%B8%AD%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>在 Unity 项目中，如果你使用的插件工具（如 Asset Store 插件）在解决方案中生成了许多项目（如 <code>.csproj</code> 文件），但你并不需要修改它们，可以通过以下几种方法将它们从 Visual Studio 的解决方案中隐藏或不加载。以下是几种可行的方式：</p>
<hr>
<h3 id="方法-1：修改-Unity-的生成规则（推荐）"><a href="#方法-1：修改-Unity-的生成规则（推荐）" class="headerlink" title="方法 1：修改 Unity 的生成规则（推荐）"></a><strong>方法 1：修改 Unity 的生成规则（推荐）</strong></h3><p>Unity 的解决方案和项目文件是自动生成的，你可以通过自定义 <code>*.asmdef</code> 文件或修改生成规则来避免加载不必要的插件项目。</p>
<h4 id="步骤：自定义插件的-Assembly-Definition"><a href="#步骤：自定义插件的-Assembly-Definition" class="headerlink" title="步骤：自定义插件的 Assembly Definition"></a><strong>步骤：自定义插件的 Assembly Definition</strong></h4><ol>
<li><p><strong>找到插件目录</strong></p>
<ul>
<li>在 Unity 项目中找到插件工具所在的文件夹（如 <code>Assets/Plugins</code> 或 <code>Assets/ThirdParty</code>）。</li>
</ul>
</li>
<li><p><strong>创建 <code>.asmdef</code> 文件</strong></p>
<ul>
<li>在插件的主文件夹下创建一个 <strong>Assembly Definition 文件</strong>（右键 &gt; Create &gt; Assembly Definition）。</li>
<li>设置一个合适的名称，如 <code>MyPluginAssembly</code>.</li>
<li>Unity 会将插件的代码隔离到这个程序集。</li>
</ul>
</li>
<li><p><strong>避免在解决方案中显示</strong></p>
<ul>
<li>打开创建的 <code>.asmdef</code> 文件，将 <code>Auto Referenced</code> 属性取消勾选。</li>
<li>这样插件代码会被编译，但不会作为单独的项目出现在解决方案中。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="方法-2：修改-Unity-编辑器设置"><a href="#方法-2：修改-Unity-编辑器设置" class="headerlink" title="方法 2：修改 Unity 编辑器设置"></a><strong>方法 2：修改 Unity 编辑器设置</strong></h3><p>Unity 提供了选项让你在生成解决方案时忽略某些插件的代码。</p>
<ol>
<li><p><strong>编辑 Unity 编辑器的配置文件</strong></p>
<ul>
<li>打开 Unity Preferences（<strong>Edit &gt; Preferences</strong> 或 <strong>Unity &gt; Preferences</strong>）。</li>
<li>找到 <strong>External Tools</strong> 面板。</li>
<li>确保取消勾选 <code>Generate All .csproj files</code>，然后勾选 <code>Generate .csproj files for: Embedded packages</code> 和 <code>Local packages</code>，这样 Unity 不会生成额外的项目文件。</li>
</ul>
</li>
<li><p><strong>手动移除插件的项目文件</strong></p>
<ul>
<li>如果插件仍然出现在解决方案中，可以手动删除它们的 <code>.csproj</code> 文件（通常在 <code>Library/ScriptAssemblies</code> 中）。</li>
<li>注意：删除后 Unity 会自动重新生成，但只要配置正确，不会再次生成这些文件。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="方法-3：使用-Visual-Studio-的项目过滤功能"><a href="#方法-3：使用-Visual-Studio-的项目过滤功能" class="headerlink" title="方法 3：使用 Visual Studio 的项目过滤功能"></a><strong>方法 3：使用 Visual Studio 的项目过滤功能</strong></h3><p>如果你不能改变 Unity 的项目生成规则，也可以在 Visual Studio 中隐藏多余的插件项目。</p>
<ol>
<li><p><strong>编辑解决方案文件（<code>.sln</code>）</strong></p>
<ul>
<li>打开解决方案文件（<code>YourProject.sln</code>），删除不需要的项目引用。</li>
<li>保存文件后，重新加载解决方案。</li>
<li>注意：每次 Unity 重新生成解决方案时，这些修改会被覆盖。</li>
</ul>
</li>
<li><p><strong>使用 Visual Studio 的解决方案文件夹</strong></p>
<ul>
<li>在 Visual Studio 中，将插件项目移动到一个单独的解决方案文件夹中。</li>
<li>这样可以通过折叠文件夹隐藏它们，减少干扰。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="方法-4：利用插件设置隐藏它们的代码"><a href="#方法-4：利用插件设置隐藏它们的代码" class="headerlink" title="方法 4：利用插件设置隐藏它们的代码"></a><strong>方法 4：利用插件设置隐藏它们的代码</strong></h3><p>某些插件（如 Odin Inspector、DoTween 等）会附带设置选项，你可以在插件的设置中禁用编辑器脚本或编译规则，从而减少它们生成的项目。</p>
<h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a><strong>具体步骤</strong></h4><ul>
<li>打开插件的设置面板（通常在 <strong>Tools</strong> 菜单或 <code>Edit &gt; Preferences</code> 下）。</li>
<li>检查是否有选项允许禁用开发模式或额外的脚本生成。</li>
</ul>
<hr>
<h3 id="方法-5：手动分离插件到-dll-文件"><a href="#方法-5：手动分离插件到-dll-文件" class="headerlink" title="方法 5：手动分离插件到 .dll 文件"></a><strong>方法 5：手动分离插件到 <code>.dll</code> 文件</strong></h3><p>如果你不需要修改插件代码，可以将插件的源码编译为 <code>.dll</code> 文件并移除原始脚本。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><strong>步骤</strong></h4><ol>
<li><p><strong>将插件源码编译为 <code>.dll</code></strong></p>
<ul>
<li>使用 Visual Studio 或其他工具（如 Rider）将插件的源码编译成一个 <code>.dll</code> 文件。</li>
<li>确保引用的依赖项齐全。</li>
</ul>
</li>
<li><p><strong>替换源码</strong></p>
<ul>
<li>将插件目录下的源码替换为编译后的 <code>.dll</code> 文件。</li>
<li>确保将 <code>.dll</code> 文件放入 <code>Assets/Plugins</code> 或 <code>Assets/ThirdParty</code> 文件夹中。</li>
</ul>
</li>
<li><p><strong>移除插件源码</strong></p>
<ul>
<li>删除原始脚本，Unity 只会加载 <code>.dll</code> 文件，不会显示插件项目。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ul>
<li>如果你计划以后修改或调试插件代码，保留源码是更好的选择。</li>
<li>有些插件的功能可能依赖于运行时动态生成的代码或脚本文件，完全移除源码可能导致功能异常。</li>
<li>优化解决方案文件后，确保在 Unity 中正常运行游戏或项目。</li>
</ul>
<p>通过以上方法，可以让你的 Visual Studio 项目更清爽，同时不会影响 Unity 项目的正常运行。</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>医保</title>
    <url>/2025/01/03/%E5%8C%BB%E4%BF%9D/</url>
    <content><![CDATA[<h1 id="灵活就业一档医保报销政策"><a href="#灵活就业一档医保报销政策" class="headerlink" title="灵活就业一档医保报销政策"></a>灵活就业一档医保报销政策</h1><p>深圳灵活就业人员缴纳的医保是职工一档医保，享受的也是职工一档医保待遇。普通门诊统筹支付比例与医疗机构级别挂钩，最高可报销75%，更多报销内容说明见正文。</p>
<h2 id="一档医保报销比例"><a href="#一档医保报销比例" class="headerlink" title="一档医保报销比例"></a>一档医保报销比例</h2><p>深圳灵活就业人员缴纳的医保是职工一档医保，享受的也是职工一档医保待遇。</p>
<h3 id="一、门诊报销比例"><a href="#一、门诊报销比例" class="headerlink" title="一、门诊报销比例"></a>一、门诊报销比例</h3><p>职工基本医保、居民基本医保普通门诊统筹支付比例与医疗机构级别挂钩。</p>
<ul>
<li>一级以下医疗机构(例如社康)报销比例：75%;</li>
<li>二级医院报销比例：65%;</li>
<li>三级医院报销比例：55%;</li>
</ul>
<p>退休人员、60周岁及以上居民在上述基础上相应提高5%。</p>
<h3 id="二、一档医保市内住院报销比例"><a href="#二、一档医保市内住院报销比例" class="headerlink" title="二、一档医保市内住院报销比例"></a>二、一档医保市内住院报销比例</h3><p>在一级以下医院支付比例为94%;</p>
<p>二级医院支付比例为92%;</p>
<p>三级医院支付比例为90%;</p>
<p>退休人员支付比例为95%。</p>
<p>住院起付线</p>
<p>参保人在市内定点医疗机构住院发生的基本医疗费用，未超过起付线的由参保人支付;超过起付线的部分，由基本医疗保险统筹基金按规定支付。</p>
<p>住院起付线按照医院级别设定，其中一级以下医院为200元，二级医院为400元，三级医院为600元。</p>
<p>参保人在一个医疗保险年度内二次及以上住院的，住院起付线分别为：一级以下医院为100元，二级医院为200元，三级医院为300元。</p>
<h2 id="灵活就业医保缴费标准"><a href="#灵活就业医保缴费标准" class="headerlink" title="灵活就业医保缴费标准"></a>灵活就业医保缴费标准</h2><p><img src="/.io//image.png"></p>
<blockquote>
<p>缴费金额：</p>
</blockquote>
<p>6733x0.02 个人余额134</p>
<p>6733x0.07 个人缴纳医保费用471</p>
<p>一级医院  限额1万多  报销 75% 费用，个人只需要支付剩余的 25% 费用。</p>
<p><code>小知识</code>：社康是一级，三甲医院是是三级</p>
<p><code>各级别医院医保报销比例一般情况</code>（医保内的项目和药物）：</p>
<ul>
<li>一级医院（社区医院）： 报销比例最高，鼓励患者首诊在社区医院。</li>
<li>二级医院： 报销比例次之，适合治疗一些常见的疾病。</li>
<li>三级医院（三甲医院）： 报销比例最低，主要用于治疗疑难杂症和重症疾病。</li>
</ul>
<p><code>不同级别医院的医保报销限额</code>（医保内的项目和药物）：</p>
<ul>
<li>一级医院（社区医院）： 报销限额相对较低，但报销比例较高。</li>
<li>二级医院： 报销限额比一级医院高，但比三级医院低。</li>
<li>三级医院（三甲医院）： 报销限额最高，但报销比例相对较低。</li>
</ul>
<h2 id="门诊和住院医保报销的区别"><a href="#门诊和住院医保报销的区别" class="headerlink" title="门诊和住院医保报销的区别"></a>门诊和住院医保报销的区别</h2><table>
<thead>
<tr>
<th>项目</th>
<th>门诊</th>
<th>住院</th>
</tr>
</thead>
<tbody><tr>
<td>报销比例</td>
<td>一般较低</td>
<td>一般较高</td>
</tr>
<tr>
<td>起付线</td>
<td>一般有</td>
<td>一般有</td>
</tr>
<tr>
<td>年度限额</td>
<td>一般有</td>
<td>一般有</td>
</tr>
<tr>
<td>报销范围</td>
<td>诊疗费、药费、检查费等</td>
<td>所有医疗费用</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>社保</category>
      </categories>
      <tags>
        <tag>医保</tag>
      </tags>
  </entry>
  <entry>
    <title>团结引擎</title>
    <url>/2025/01/15/%E5%9B%A2%E7%BB%93%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<p><a href="https://unity.cn/tuanjie/tuanjieyinqing">原文</a></p>
<h1 id="一站式微信小游戏解决方案"><a href="#一站式微信小游戏解决方案" class="headerlink" title="一站式微信小游戏解决方案"></a>一站式微信小游戏解决方案</h1><p>基于WebGL，团结引擎针对微信小游戏开发了专属的目标平台。您可以轻松将其他平台的游戏转换成微信小游戏，覆盖更广阔的玩家群体。</p>
<p>IL2CPP 内存和性能优化，专项渲染&#x2F;异常优化，加强版的 Profiler 工具，更有一站式游戏云服务解决方案原生集成了对微信小游戏的支持，助您的作品在性能和体验上更进一步。不仅如此，微信小游戏解决方案还可以实现项目首包大小自动精简、按需获取项目资产等功能。</p>
<p>借助团结引擎的众多功能及特性，您可以轻松实现创意想法，并创建出独具个性的微信小游戏。</p>
<h1 id="一站式智能座舱解决方案"><a href="#一站式智能座舱解决方案" class="headerlink" title="一站式智能座舱解决方案"></a>一站式智能座舱解决方案</h1><p>团结引擎车机版不仅支持HMI Android、QNX、Embedded Linux多种操作系统，同时可以帮助车机实现启动时间、内存占用、线程数量等指标的充分优化。内置了常用车机APP的开发模版，将大幅缩短开发流程；车机模拟器则实现了可视化开发，实时反馈开发进程中的每一步。</p>
<p>下一代HMI渲染解决方案，不仅能够为原生APP渲染3D内容，还能够让不同项目独立开发并更新，互不干扰，极大提高运行效率。</p>
<h1 id="适配OpenHarmony操作系统"><a href="#适配OpenHarmony操作系统" class="headerlink" title="适配OpenHarmony操作系统"></a>适配OpenHarmony操作系统</h1><p>新增OpenHarmony目标平台。您可以通过团结引擎轻松构建出能有运行在OpenHarmony操作系统的游戏，同时获得与安卓及iOS同样丝滑的游戏体验。</p>
<p>全面适配OpenHarmony系统，包括Ability框架、XComponent、ArkUI、音视频、文件系统、触控系统等。确保丝滑工作流，兼容老版本项目，支持一键切换平台和构建出包。提供快速迭代速度，直连设备支持Patch and Run&#x2F;Build and Run，同时能导出Ability Project。完善的Profiler支持包括引擎Profiler适配和平台Profiler，以及专有的C#与ts交互API方便SDK接入。</p>
<p>团结引擎将为OpenHarmony生态快速带来更多高品质游戏与实时3D内容，未来双方也携手致力于推进游戏技术突破和创新成果转化，拓展更多游戏新场景，为游戏产业注入新活力。</p>
<h1 id="虚拟几何体系统"><a href="#虚拟几何体系统" class="headerlink" title="虚拟几何体系统"></a>虚拟几何体系统</h1><p>团结引擎基于GPU Driven Pipeline开发了一套虚拟几何体系统。现在您可以轻松导入高精度的模型，不需要再担心超高面数的模型给您项目带来的渲染和显存压力。</p>
<p>利用GPU Driven Pipeline，我们对虚拟几何体进行了精细的剔除和组织；大大降低了渲染系统对CPU的消耗，同时提升了GPU的吞吐量。</p>
<p>借助于虚拟几何体系统，团结引擎可以帮助优化您的开发工作流，以及运行时的渲染效果和性能；它可以满足您的场景对海量（数以亿计）多边形的需求。</p>
<h1 id="团结引擎功能优势"><a href="#团结引擎功能优势" class="headerlink" title="团结引擎功能优势"></a>团结引擎功能优势</h1><ul>
<li><p>专为中国开发者定制</p>
<p>  Customized Feature<br>  致力于满足中国开发者的独特需求，结合本土文化元素和市场特色，为创作提供全面支持。</p>
</li>
<li><p>本土科技生态支持</p>
<p>  Domestic Ecosystem Support<br>  通过多项原创性的本土优化与拓展，团结引擎已兼容适配了中国科技生态内的众多软硬件平台。团结引擎目前已支持Windows、Mac、Linux操作系统，以及Android、iOS、WebGL、Weixin Mini Game、HMI Android、QNX、Embedded Linux平台，OpenHarmony开源项目等，并即将支持AliOS操作系统。</p>
</li>
<li><p>微信小游戏解决方案</p>
<p>  Weixin Mini Game Solution<br>  基于WebGL开发的微信小游戏专属目标平台，同时配置丰富的工具与功能，帮助开发者在不断提高创作效率的同时，让小游戏在性能和体验上更进一步。</p>
</li>
<li><p>车机定制编辑器</p>
<p>  HMI Editor<br>  界面友好且高度可定制的编辑器，结合车机创新应用模板，使开发者能够根据项目需求轻松调整和优化开发工具，节省时间，提升效率。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2025/07/09/%E5%A4%9A%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E5%AF%B9%E6%AF%94%E5%B7%A5%E5%85%B7%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="工具概述"><a href="#工具概述" class="headerlink" title="工具概述"></a>工具概述</h2><p>多语言文件批量对比工具是一个Unity编辑器扩展工具，用于批量扫描和对比游戏中的多语言Lua文件，检查不同语言版本之间的键值一致性。该工具能够自动识别同名语言文件组，并对比各组文件中键的差异，帮助开发者快速发现多语言文件中的缺失或多余键值。</p>
<h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><ul>
<li>批量扫描指定目录下的所有Lua语言文件</li>
<li>自动按文件名分组多语言文件</li>
<li>对比同组文件中键值的差异</li>
<li>显示缺失键和多余键的详细报告</li>
<li>支持嵌套表结构的键值对比</li>
<li>提供简洁直观的GUI界面</li>
</ul>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h3><ol>
<li>将脚本放置在Unity项目的Editor文件夹下</li>
<li>在Unity编辑器中，通过菜单栏选择 <code>Tools/多语言文件批量对比</code> 打开工具窗口</li>
</ol>
<h3 id="界面说明"><a href="#界面说明" class="headerlink" title="界面说明"></a>界面说明</h3><p>工具窗口包含以下主要部分：</p>
<ul>
<li><strong>路径选择</strong>：显示和修改语言文件所在目录（默认为<code>Assets/_GameCenter/ClientLua/Model/Language</code>）</li>
<li><strong>扫描对比按钮</strong>：点击后开始扫描指定目录并对比文件</li>
<li><strong>结果展示区域</strong>：显示对比结果的详细信息</li>
</ul>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol>
<li>确认或修改语言文件目录路径</li>
<li>点击”Scan and Compare All Language Files”按钮</li>
<li>查看对比结果：<ul>
<li>文件总数和分组数统计</li>
<li>存在差异的文件组列表</li>
<li>每组文件中缺失或多余的键值详情</li>
</ul>
</li>
</ol>
<h3 id="输出结果解读"><a href="#输出结果解读" class="headerlink" title="输出结果解读"></a>输出结果解读</h3><ul>
<li><strong>一致性报告</strong>：<code>All language file groups are consistent!</code> 表示所有文件组内容一致</li>
<li><strong>差异报告</strong>：包含以下信息：<ul>
<li>差异文件组名称</li>
<li>组内所有文件名</li>
<li>与基准文件相比缺失的键</li>
<li>与基准文件相比多余的键</li>
<li>文件路径信息便于定位问题</li>
</ul>
</li>
</ul>
<h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><ol>
<li><strong>文件扫描</strong>：递归查找指定目录下的所有.lua文件</li>
<li><strong>文件分组</strong>：按文件名（不含扩展名）将文件分组</li>
<li><strong>键值提取</strong>：使用Lua解析器读取文件内容，提取所有键（包括嵌套表键）</li>
<li><strong>差异对比</strong>：以每组第一个文件为基准，对比其他文件的键集合</li>
<li><strong>结果生成</strong>：汇总所有差异信息，格式化输出</li>
</ol>
<h3 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h3><ul>
<li><code>ExtractLuaTableKeys</code>：解析Lua文件并提取所有键</li>
<li><code>ExtractKeysRecursively</code>：递归处理嵌套表结构</li>
<li><code>ScanAndCompareFiles</code>：主逻辑流程控制</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>工具依赖Lua环境，首次使用会自动初始化</li>
<li>需要确保Lua文件路径正确且可访问</li>
<li>基准文件为每组中的第一个文件，对比结果以此为参照</li>
<li>复杂的Lua文件结构可能导致解析失败，请检查错误日志</li>
</ol>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> LuaInterface;</span><br><span class="line"><span class="keyword">using</span> LuaFramework;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LanguageFilesBatchComparer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 功能：批量对比多语言 Lua 文件中的字段差异，找出各语言版本文件之间的缺失字段与多余字段。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用说明：</span></span><br><span class="line"><span class="comment"> * --------------------------------------</span></span><br><span class="line"><span class="comment"> * 1. 将该脚本放入 Unity 工程的 Editor 文件夹中。</span></span><br><span class="line"><span class="comment"> * 2. 在 Unity 菜单栏点击 Tools &gt; 多语言文件批量对比 打开窗口。</span></span><br><span class="line"><span class="comment"> * 3. 默认目录为：Assets/_GameCenter/ClientLua/Model/Language，可点击“Select Folder”修改目标目录。</span></span><br><span class="line"><span class="comment"> * 4. 点击“Scan and Compare All Language Files”按钮，工具将自动扫描该目录下所有 `.lua` 文件并进行分组对比。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 工具特性：</span></span><br><span class="line"><span class="comment"> * --------------------------------------</span></span><br><span class="line"><span class="comment"> * - **自动扫描**：递归查找指定文件夹及其子文件夹下所有 `.lua` 文件。</span></span><br><span class="line"><span class="comment"> * - **智能分组**：以文件名（不含扩展名）为键，对文件进行自动分组。</span></span><br><span class="line"><span class="comment"> * - **批量对比**：每组文件内部进行字段对比，支持找出：</span></span><br><span class="line"><span class="comment"> *     - 缺失字段（参考文件有但当前文件没有）</span></span><br><span class="line"><span class="comment"> *     - 多余字段（当前文件有但参考文件没有）</span></span><br><span class="line"><span class="comment"> * - **结果输出**：将对比结果输出至编辑器窗口，同时在控制台输出详细信息。</span></span><br><span class="line"><span class="comment"> * - **Lua VM 支持**：内部使用 LuaState 启动 Lua 虚拟机执行文件，解析 Lua 表结构，准确性更高。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意事项：</span></span><br><span class="line"><span class="comment"> * --------------------------------------</span></span><br><span class="line"><span class="comment"> * - 所有语言 Lua 文件 **必须返回一个 table**，例如：</span></span><br><span class="line"><span class="comment"> *       return &#123;</span></span><br><span class="line"><span class="comment"> *           key1 = &quot;内容1&quot;,</span></span><br><span class="line"><span class="comment"> *           key2 = &quot;内容2&quot;</span></span><br><span class="line"><span class="comment"> *       &#125;</span></span><br><span class="line"><span class="comment"> * - 文件名必须保持一致，才能分为一组。</span></span><br><span class="line"><span class="comment"> * - 以 **每组的第一个文件**作为参考标准，其他文件与其对比字段差异。</span></span><br><span class="line"><span class="comment"> * - 文件中如包含全局变量、语法错误、注释混淆等内容，可能导致 Lua 解析失败。</span></span><br><span class="line"><span class="comment"> * - 该工具不会解析嵌套表，仅支持一级 key 的对比。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LanguageFilesBatchComparer</span> : <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, List&lt;LanguageFileInfo&gt;&gt; fileGroups = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, List&lt;LanguageFileInfo&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Vector2 scrollPosition;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> comparisonResult = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> folderPath, defaultPath = <span class="string">&quot;Assets/_GameCenter/ClientLua/Model/Language&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LuaState lua &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> isStarted;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">LanguageFileInfo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> FileName;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> FullPath;</span><br><span class="line">        <span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; Keys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Initialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isStarted &amp;&amp; lua != <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//这句代码需要执行一下，不然lualoader初始化不成，LuaManager.inst.Start()会执行失败</span></span><br><span class="line">        <span class="keyword">var</span> loader = ROYAL_EMPIRE_GAMES_LuaLoader.inst;</span><br><span class="line">        lua = <span class="keyword">new</span> LuaState();</span><br><span class="line">        OpenCJson(); <span class="comment">//必须向当前的 LuaState 注册 cjson 库,否则会报错</span></span><br><span class="line">        lua.LuaSetTop(<span class="number">0</span>);</span><br><span class="line">        LuaBinder.Bind(lua); <span class="comment">// 如果需要绑定C#类</span></span><br><span class="line">        <span class="comment">//向 Lua 解释器添加 Lua 文件的搜索路径，以便在通过 DoFile 或 require 加载 Lua 文件时，能够正确找到所需的 Lua 模块或脚本。</span></span><br><span class="line">        lua.AddSearchPath(ROYAL_EMPIRE_GAMES_AppConst.ClientLuaRoot);</span><br><span class="line">        lua.AddSearchPath(ROYAL_EMPIRE_GAMES_AppConst.FrameworkRoot + <span class="string">&quot;/ToLua/Lua&quot;</span>);</span><br><span class="line">        lua.Start(); <span class="comment">// 启动 VM</span></span><br><span class="line">        isStarted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cjson 比较特殊，只new了一个table，没有注册库，这里注册一下</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenCJson</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        lua.LuaGetField(LuaIndexes.LUA_REGISTRYINDEX, <span class="string">&quot;_LOADED&quot;</span>);</span><br><span class="line">        lua.OpenLibs(LuaDLL.luaopen_cjson);</span><br><span class="line">        lua.LuaSetField(<span class="number">-2</span>, <span class="string">&quot;cjson&quot;</span>);</span><br><span class="line">        lua.OpenLibs(LuaDLL.luaopen_cjson_safe);</span><br><span class="line">        lua.LuaSetField(<span class="number">-2</span>, <span class="string">&quot;cjson.safe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="string">&quot;Tools/多语言文件批量对比&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowWindow</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetWindow&lt;LanguageFilesBatchComparer&gt;(<span class="string">&quot;Language Files Batch Comparer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GUILayout.Label(<span class="string">&quot;Language Files Comparison Tool&quot;</span>, EditorStyles.boldLabel);</span><br><span class="line">        EditorGUILayout.Space();</span><br><span class="line">        folderPath = <span class="built_in">string</span>.IsNullOrEmpty(folderPath) ? defaultPath : folderPath;</span><br><span class="line">        EditorGUILayout.BeginHorizontal();</span><br><span class="line">        EditorGUILayout.LabelField(<span class="string">&quot;Languages Folder Path:&quot;</span>, folderPath);</span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;...&quot;</span>, GUILayout.Width(<span class="number">30</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> path = EditorUtility.OpenFolderPanel(<span class="string">&quot;Select Languages Folder&quot;</span>, defaultPath, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(path)) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 转换为相对于Assets的路径</span></span><br><span class="line">            <span class="keyword">if</span> (path.StartsWith(Application.dataPath))</span><br><span class="line">                folderPath = path.Substring(path.IndexOf(<span class="string">&quot;Assets&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        EditorGUILayout.EndHorizontal();</span><br><span class="line">        EditorGUILayout.Space();</span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;Scan and Compare All Language Files&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(folderPath) || !Directory.Exists(folderPath))</span><br><span class="line">                Debug.Log(<span class="string">&quot;Please select a valid folder path first!&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ScanAndCompareFiles();</span><br><span class="line">        &#125;</span><br><span class="line">        EditorGUILayout.Space();</span><br><span class="line">        GUILayout.Label(<span class="string">&quot;Comparison Results&quot;</span>, EditorStyles.boldLabel);</span><br><span class="line">        scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition, GUILayout.ExpandHeight(<span class="literal">true</span>));</span><br><span class="line">        EditorGUILayout.TextArea(comparisonResult, GUILayout.ExpandHeight(<span class="literal">true</span>));</span><br><span class="line">        EditorGUILayout.EndScrollView(); <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ScanAndCompareFiles</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Initialize(); <span class="comment">// 确保已初始化</span></span><br><span class="line">        fileGroups.Clear();</span><br><span class="line">        comparisonResult = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有Lua文件</span></span><br><span class="line">        <span class="keyword">var</span> path = Path.GetFullPath(Path.Combine(Application.dataPath, folderPath.Replace(<span class="string">&quot;Assets/&quot;</span>, <span class="string">&quot;&quot;</span>)));</span><br><span class="line">        <span class="keyword">var</span> files = Directory.GetFiles(path, <span class="string">&quot;*.lua&quot;</span>, SearchOption.AllDirectories);</span><br><span class="line">        <span class="keyword">if</span> (files.Length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            comparisonResult = <span class="string">&quot;No .lua files found in the specified folder!&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按文件名分组(不带扩展名)</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> filePath <span class="keyword">in</span> files)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> fileName = Path.GetFileNameWithoutExtension(filePath);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> keys = ExtractLuaTableKeys(filePath);</span><br><span class="line">                <span class="keyword">var</span> fileInfo = <span class="keyword">new</span> LanguageFileInfo</span><br><span class="line">                &#123;</span><br><span class="line">                    FileName = fileName,</span><br><span class="line">                    FullPath = filePath,</span><br><span class="line">                    Keys = keys</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">if</span> (!fileGroups.ContainsKey(fileName)) fileGroups.Add(fileName, <span class="keyword">new</span> List&lt;LanguageFileInfo&gt;());</span><br><span class="line">                fileGroups[fileName].Add(fileInfo);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(<span class="string">$&quot;Error parsing file <span class="subst">&#123;filePath&#125;</span>: <span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lua?.Dispose();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对比每组同名文件</span></span><br><span class="line">        <span class="keyword">var</span> totalIssues = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> <span class="keyword">group</span> <span class="keyword">in</span> fileGroups)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">group</span>.Value.Count &lt; <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                comparisonResult += <span class="string">$&quot;File &#x27;<span class="subst">&#123;<span class="keyword">group</span>.Key&#125;</span>&#x27; has no counterparts to compare with.\n&quot;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以第一个文件为基准</span></span><br><span class="line">            <span class="keyword">var</span> referenceFile = <span class="keyword">group</span>.Value[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> hasIssues = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">var</span> groupResult = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">group</span>.Value.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> currentFile = <span class="keyword">group</span>.Value[i];</span><br><span class="line">                <span class="keyword">var</span> missingKeys = referenceFile.Keys.Except(currentFile.Keys).ToList();</span><br><span class="line">                <span class="keyword">var</span> extraKeys = currentFile.Keys.Except(referenceFile.Keys).ToList();</span><br><span class="line">                <span class="keyword">if</span> (missingKeys.Count &gt; <span class="number">0</span> || extraKeys.Count &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    hasIssues = <span class="literal">true</span>;</span><br><span class="line">                    groupResult += <span class="string">$&quot;\nCompared to <span class="subst">&#123;referenceFile.FileName&#125;</span>:\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (missingKeys.Count &gt; <span class="number">0</span>)</span><br><span class="line">                        groupResult += <span class="string">$&quot;Missing keys in <span class="subst">&#123;currentFile.FullPath&#125;</span>:\n<span class="subst">&#123;<span class="built_in">string</span>.Join(<span class="string">&quot;\n&quot;</span>, missingKeys)&#125;</span>\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (extraKeys.Count &gt; <span class="number">0</span>)</span><br><span class="line">                        groupResult += <span class="string">$&quot;Extra keys in <span class="subst">&#123;currentFile.FullPath&#125;</span>:\n<span class="subst">&#123;<span class="built_in">string</span>.Join(<span class="string">&quot;\n&quot;</span>, extraKeys)&#125;</span>\n&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hasIssues)</span><br><span class="line">            &#123;</span><br><span class="line">                totalIssues++;</span><br><span class="line">                comparisonResult += <span class="string">$&quot;\n=== Differences found in &#x27;<span class="subst">&#123;<span class="keyword">group</span>.Key&#125;</span>&#x27; group ===\n&quot;</span>;</span><br><span class="line">                comparisonResult += <span class="string">$&quot;Files in group: <span class="subst">&#123;<span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, <span class="keyword">group</span>.Value.Select(f =&gt; f.FileName))&#125;</span>\n&quot;</span>;</span><br><span class="line">                comparisonResult += groupResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        comparisonResult =</span><br><span class="line">            <span class="string">$&quot;Scanned <span class="subst">&#123;files.Length&#125;</span> files, found <span class="subst">&#123;fileGroups.Count&#125;</span> groups, <span class="subst">&#123;totalIssues&#125;</span> groups with issues.\n&quot;</span> +</span><br><span class="line">            comparisonResult;</span><br><span class="line">        <span class="keyword">if</span> (totalIssues == <span class="number">0</span>) comparisonResult += <span class="string">&quot;\nAll language file groups are consistent!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">ExtractLuaTableKeys</span>(<span class="params"><span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> keys = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用 DoFile 加载 Lua 文件并直接获取返回值（LuaTable）</span></span><br><span class="line">            <span class="keyword">var</span> lanTable = lua.DoFile&lt;LuaTable&gt;(filePath);</span><br><span class="line">            <span class="keyword">if</span> (lanTable == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;无法加载 Lua 文件：<span class="subst">&#123;filePath&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归提取所有键（包括嵌套表的键）</span></span><br><span class="line">            ExtractKeysRecursively(lanTable, <span class="string">&quot;&quot;</span>, keys);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放资源（可选，但建议加上）</span></span><br><span class="line">            lanTable.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">$&quot;解析文件 <span class="subst">&#123;filePath&#125;</span> 失败: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ExtractKeysRecursively</span>(<span class="params">LuaTable table, <span class="built_in">string</span> parentKey, List&lt;<span class="built_in">string</span>&gt; keys</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> dictTable = table.ToDictTable();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> entry <span class="keyword">in</span> dictTable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> key = entry.Key?.ToString();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(key)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建完整键路径</span></span><br><span class="line">            <span class="keyword">var</span> fullKey = <span class="built_in">string</span>.IsNullOrEmpty(parentKey) ? key : <span class="string">$&quot;<span class="subst">&#123;parentKey&#125;</span>.<span class="subst">&#123;key&#125;</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是嵌套表，递归处理</span></span><br><span class="line">            <span class="keyword">if</span> (entry.Value <span class="keyword">is</span> LuaTable nestedTable)</span><br><span class="line">                ExtractKeysRecursively(nestedTable, fullKey, keys);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                keys.Add(fullKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>提升</title>
    <url>/2025/05/21/%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<ol>
<li>做demo</li>
<li>看技术文章</li>
<li>逛社区，看别人的问题和解决方案</li>
<li>研究GitHub开源项目</li>
<li>学习新技术，看教程</li>
<li>刷boss直聘,关注市场技术需求和趋势</li>
<li>根据unity 官方认证考核要求，系统学习技能点</li>
<li><a href="https://unity.com/cn/products/unity-certifications/associate-game-developer">https://unity.com/cn/products/unity-certifications/associate-game-developer</a></li>
<li><a href="https://images.response.unity3d.com/Web/Unity/%7B49e92fbc-2b28-4405-9e4c-64b56e231fbe%7D_Unity_Certified_Associate__Game_Developer_Exam_Objectives_document.pdf">https://images.response.unity3d.com/Web/Unity/%7B49e92fbc-2b28-4405-9e4c-64b56e231fbe%7D_Unity_Certified_Associate__Game_Developer_Exam_Objectives_document.pdf</a></li>
<li><a href="https://certification.u3d.cn/exam/67d29d3cc72f320008354040">https://certification.u3d.cn/exam/67d29d3cc72f320008354040</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">课程大纲：</span><br><span class="line"></span><br><span class="line">Part1</span><br><span class="line">Unity编辑器基础</span><br><span class="line"></span><br><span class="line">Part2</span><br><span class="line">Unity物理引擎系统</span><br><span class="line"></span><br><span class="line">Part3</span><br><span class="line">Unity动画系统</span><br><span class="line"></span><br><span class="line">Part4</span><br><span class="line">Unity导航寻路系统</span><br><span class="line"></span><br><span class="line">Part5</span><br><span class="line">UnityUI系统</span><br><span class="line"></span><br><span class="line">Part6</span><br><span class="line">Unity特效系统</span><br><span class="line"></span><br><span class="line">Part7</span><br><span class="line">Unity资源动态加载和热更</span><br><span class="line"></span><br><span class="line">Part8</span><br><span class="line">Unity数据存储</span><br><span class="line"></span><br><span class="line">Part9</span><br><span class="line">Unity移动平台输入控制和发布</span><br><span class="line"></span><br><span class="line">Part10</span><br><span class="line">Unity版本控制管理系统</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">考试内容</span><br><span class="line">你会遇到涉及以下主题的问题：</span><br><span class="line"></span><br><span class="line">动画</span><br><span class="line">资源管理</span><br><span class="line">音频</span><br><span class="line">就业准备</span><br><span class="line">游戏美术原理</span><br><span class="line">游戏设计原理</span><br><span class="line">行业意识</span><br><span class="line">光照</span><br><span class="line">材质和特效</span><br><span class="line">物理</span><br><span class="line">编程</span><br><span class="line">项目管理</span><br><span class="line">服务</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要求：</span><br><span class="line"></span><br><span class="line">1.Unity编辑器界面基本操作</span><br><span class="line"></span><br><span class="line">2.解析Unity编辑器的资源</span><br><span class="line"></span><br><span class="line">3.预制体Prefab</span><br><span class="line"></span><br><span class="line">4.游戏项目管理</span><br><span class="line"></span><br><span class="line">5.游戏场景的光照</span><br><span class="line"></span><br><span class="line">6.Unity脚本常用工具类学习</span><br><span class="line"></span><br><span class="line">7.Invoke与与协程函数</span><br><span class="line"></span><br><span class="line">8.相机Camera控制</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>提升</category>
      </categories>
      <tags>
        <tag>提升</tag>
      </tags>
  </entry>
  <entry>
    <title>文件树状层级图生成</title>
    <url>/2025/05/01/%E6%96%87%E4%BB%B6%E6%A0%91%E7%8A%B6%E5%B1%82%E7%BA%A7%E5%9B%BE%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pyperclip  <span class="comment"># 需要安装 pip install pyperclip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_tab_tree</span>(<span class="params">directory, level=<span class="number">0</span>, exclude_dirs=[], exclude_exts=[]</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        files = <span class="built_in">sorted</span>(os.listdir(directory))  <span class="comment"># 按字母排序，方便阅读</span></span><br><span class="line">    <span class="keyword">except</span> PermissionError:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>  <span class="comment"># 避免访问无权限目录时报错</span></span><br><span class="line"></span><br><span class="line">    content = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        path = os.path.join(directory, file)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 过滤掉指定的文件夹</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(path) <span class="keyword">and</span> file <span class="keyword">in</span> exclude_dirs:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 过滤掉指定后缀的文件</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(path) <span class="keyword">and</span> <span class="built_in">any</span>(file.endswith(ext) <span class="keyword">for</span> ext <span class="keyword">in</span> exclude_exts):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用制表符（Tab）进行缩进</span></span><br><span class="line">        content += <span class="string">&quot;\t&quot;</span> * level + file + <span class="string">&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归处理子文件夹</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(path):</span><br><span class="line">            content += generate_tab_tree(path, level + <span class="number">1</span>, exclude_dirs, exclude_exts)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置你的目标文件夹路径</span></span><br><span class="line">directory = <span class="string">r&quot;C:\malaysiaMainPackage\malaysiaMainPackage\Assets\_GameWrap\Editor&quot;</span>  <span class="comment"># 你可以修改为你的目录路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置要排除的文件夹</span></span><br><span class="line">exclude_dirs = [<span class="string">&quot;ThirdParty&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置要排除的文件后缀（如 .lua、.meta、.proto） &quot;.lua&quot;, </span></span><br><span class="line">exclude_exts = [<span class="string">&quot;.meta&quot;</span>, <span class="string">&quot;.proto&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成树状结构</span></span><br><span class="line">tree_structure = generate_tab_tree(directory, exclude_dirs=exclude_dirs, exclude_exts=exclude_exts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制到剪贴板</span></span><br><span class="line">pyperclip.copy(tree_structure)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;层级结构已复制到剪贴板，可以直接粘贴！🎯&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>日历【FullCalendar+Lunar+RRule+Popper】</title>
    <url>/2025/01/02/%E6%97%A5%E5%8E%86%E3%80%90FullCalendar-Lunar-RRule-Popper%E3%80%91/</url>
    <content><![CDATA[<p><strong>先看官方文档，不懂的再chatgpt，最后谷歌百度搜问题</strong></p>
<h1 id="FullCalendar"><a href="#FullCalendar" class="headerlink" title="FullCalendar"></a>FullCalendar</h1><ul>
<li>视图</li>
<li>单元格渲染</li>
<li>单元格大小适配</li>
</ul>
<p>确保计算和数据加载完毕，延迟100ms渲染。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">datesSet</span>:</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">dateInfo</span>) &#123;<span class="comment">//处理默认空事件留白</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Dates set:&#x27;</span>, dateInfo);  <span class="comment">// 打印日期范围</span></span><br><span class="line">        <span class="comment">// 延迟执行，以确保日历完全渲染</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> dayCells = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.fc-daygrid-day&#x27;</span>);  <span class="comment">// 获取所有日期格子</span></span><br><span class="line">            dayCells.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">dayCell</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> eventsContainer = dayCell.<span class="title function_">querySelector</span>(<span class="string">&#x27;.fc-daygrid-day-events&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (eventsContainer) &#123;</span><br><span class="line">                    eventsContainer.<span class="property">style</span>.<span class="property">margin</span> = <span class="number">0</span>;  <span class="comment">// 隐藏没有事件的容器</span></span><br><span class="line">                    <span class="comment">// 如果该日期格子没有事件，隐藏事件容器</span></span><br><span class="line">                    <span class="keyword">if</span> (!dayCell.<span class="title function_">querySelector</span>(<span class="string">&#x27;.fc-event&#x27;</span>)) &#123;</span><br><span class="line">                        eventsContainer.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;  <span class="comment">// 隐藏没有事件的容器</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, <span class="number">100</span>);  <span class="comment">// 延迟100ms执行</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<h1 id="Lunar"><a href="#Lunar" class="headerlink" title="Lunar"></a>Lunar</h1><ul>
<li>法定节假日</li>
<li>节气</li>
<li>农历日期</li>
<li>宜忌</li>
<li>生日</li>
</ul>
<h1 id="RRule"><a href="#RRule" class="headerlink" title="RRule"></a>RRule</h1><ul>
<li><p>命名空间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rruleOccurrences = <span class="keyword">new</span> <span class="title class_">RRule</span>(rruleEvent.<span class="property">rrule</span>).<span class="title function_">all</span>(); </span><br><span class="line"><span class="comment">//无法识别 RRule，提示未定义，我们引入了rrule库就要引入命名空间 rrule</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">RRule</span> = rrule.<span class="property">RRule</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>格式与FullCalendar插件语法不同：</p>
<ul>
<li><strong>FullCalendar语法</strong><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> calendar2 = <span class="keyword">new</span> <span class="title class_">FullCalendar</span>.<span class="title class_">Calendar</span>(calendarEl, &#123;</span><br><span class="line">      <span class="attr">events</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="attr">title</span>: <span class="string">&#x27;my recurring event&#x27;</span>,</span><br><span class="line">              <span class="attr">rrule</span>: &#123;</span><br><span class="line">                  <span class="attr">freq</span>: <span class="string">&#x27;weekly&#x27;</span>,</span><br><span class="line">                  <span class="attr">interval</span>: <span class="number">1</span>,</span><br><span class="line">                  <span class="attr">byweekday</span>: [<span class="string">&#x27;mo&#x27;</span>, <span class="string">&#x27;fr&#x27;</span>],</span><br><span class="line">                  <span class="attr">dtstart</span>: <span class="string">&#x27;2024-02-01T10:30:00&#x27;</span>, <span class="comment">// will also accept &#x27;20120201T103000&#x27;</span></span><br><span class="line">                  <span class="attr">until</span>: <span class="string">&#x27;2025-06-01&#x27;</span> <span class="comment">// will also accept &#x27;20120201&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      ]</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li>
<li><strong>RRule 语法</strong><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">RRule</span> = rrule.<span class="property">RRule</span>;</span><br><span class="line"><span class="keyword">var</span> rruleEvent =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;rrule event&#x27;</span>,</span><br><span class="line">    <span class="attr">rrule</span>: &#123;</span><br><span class="line">        <span class="attr">freq</span>: <span class="title class_">RRule</span>.<span class="property">WEEKLY</span>,</span><br><span class="line">        <span class="attr">interval</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">byweekday</span>: [<span class="title class_">RRule</span>.<span class="property">MO</span>, <span class="title class_">RRule</span>.<span class="property">FR</span>],</span><br><span class="line">        <span class="attr">dtstart</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">30</span>),</span><br><span class="line">        <span class="attr">until</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2025</span>, <span class="number">12</span>, <span class="number">31</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">duration</span>: <span class="string">&#x27;02:00&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 rrule.js 解析 RRule</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">RRule</span>); <span class="comment">// 应该输出 &quot;function&quot;</span></span><br><span class="line"><span class="keyword">const</span> rruleOccurrences = <span class="keyword">new</span> <span class="title class_">RRule</span>(rruleEvent.<span class="property">rrule</span>).<span class="title function_">all</span>(); <span class="comment">// 获取所有日期实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为 FullCalendar 可用事件格式</span></span><br><span class="line"><span class="keyword">const</span> rruleEvents = rruleOccurrences.<span class="title function_">map</span>(<span class="function"><span class="params">date</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">title</span>: rruleEvent.<span class="property">title</span>,</span><br><span class="line">    <span class="attr">start</span>: date,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>单个对象声明<br>在还没有做好重复事件配置处理时，保持按照单个声明，这个和其他event配置不同。因为一个重复事件肯能涉及好多时间段，相当于多个事件的集合。</p>
</li>
<li><p>events 属性和 evens 函数不可兼得<br>evens 函数:更灵活，配置变量,但是重复事件要自己转换<br>events 属性:死板，但是支持重复事件，根据FullCalendar语法来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">events</span>:  [...birthdayEvents, ...myEvents, ...<span class="title class_">InternationalFestivals</span>, ...rruleEvents],</span><br><span class="line">or</span><br><span class="line"><span class="attr">events</span>: <span class="keyword">function</span> (<span class="params">info, successCallback, failureCallback</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取当前视图的起始日期</span></span><br><span class="line">            <span class="keyword">const</span> viewStart = <span class="keyword">new</span> <span class="title class_">Date</span>(info.<span class="property">start</span>);</span><br><span class="line">            <span class="keyword">const</span> curMonthIndex = (viewStart.<span class="title function_">getDate</span>() !== <span class="number">1</span>) ? viewStart.<span class="title function_">getMonth</span>() + <span class="number">1</span> : viewStart.<span class="title function_">getMonth</span>();<span class="comment">//月份下标  0-11  12是下一年1月</span></span><br><span class="line">            currentYear = (viewStart.<span class="title function_">getMonth</span>() === <span class="number">11</span> &amp;&amp; curMonthIndex === <span class="number">12</span>) ? viewStart.<span class="title function_">getFullYear</span>() + <span class="number">1</span> : viewStart.<span class="title function_">getFullYear</span>();</span><br><span class="line">            <span class="keyword">var</span> curMonth = curMonthIndex == <span class="number">12</span> ? <span class="number">1</span> : curMonthIndex + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> solar = <span class="title class_">Solar</span>.<span class="title function_">fromYmd</span>(currentYear, curMonth, <span class="number">1</span>); <span class="comment">// 构造阳历日期</span></span><br><span class="line">            <span class="keyword">const</span> lunar = solar.<span class="title function_">getLunar</span>(); <span class="comment">// 转为农历日期</span></span><br><span class="line">            <span class="keyword">var</span> curYearLunar = lunar.<span class="title function_">getYear</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前显示的主月份年份是:&#x27;</span>, currentYear, <span class="string">&#x27; &#x27;</span>, curMonth, <span class="string">&#x27; &#x27;</span>, lunar.<span class="title function_">toString</span>(), <span class="string">&#x27; &#x27;</span>, solar.<span class="title function_">toString</span>());</span><br><span class="line"></span><br><span class="line">            <span class="title function_">defineBirthday</span>(curYearLunar);</span><br><span class="line">            <span class="title class_">AddAnniversaryDate</span>();</span><br><span class="line">            <span class="title function_">defineMyEvent</span>();</span><br><span class="line">            <span class="title function_">defineInternationalFestivals</span>();</span><br><span class="line">            <span class="comment">// 合并所有事件数组</span></span><br><span class="line">            <span class="keyword">const</span> allEvents = [...birthdayEvents, ...myEvents, ...<span class="title class_">InternationalFestivals</span>, ...rruleEvents];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 过滤出在当前视图范围内的事件</span></span><br><span class="line">            <span class="keyword">const</span> filteredEvents = allEvents.<span class="title function_">filter</span>(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> eventStart = <span class="keyword">new</span> <span class="title class_">Date</span>(event.<span class="property">start</span>).<span class="title function_">getTime</span>();</span><br><span class="line">                <span class="keyword">const</span> eventEnd = event.<span class="property">end</span> ? <span class="keyword">new</span> <span class="title class_">Date</span>(event.<span class="property">end</span>).<span class="title function_">getTime</span>() : eventStart;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断事件是否与视图范围有重叠</span></span><br><span class="line">                <span class="keyword">return</span> eventEnd &gt;= <span class="keyword">new</span> <span class="title class_">Date</span>(info.<span class="property">start</span>).<span class="title function_">getTime</span>() &amp;&amp; eventStart &lt;= <span class="keyword">new</span> <span class="title class_">Date</span>(info.<span class="property">end</span>).<span class="title function_">getTime</span>();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回过滤后的事件</span></span><br><span class="line">            <span class="title function_">successCallback</span>(filteredEvents);</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Popper"><a href="#Popper" class="headerlink" title="Popper"></a>Popper</h1><p>鼠标进入时事件详情弹窗</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">eventDidMount</span>: <span class="keyword">function</span> (<span class="params">info</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> eventElement = info.<span class="property">el</span>;</span><br><span class="line">            <span class="keyword">const</span> title = info.<span class="property">event</span>.<span class="property">title</span>;  <span class="comment">// 获取事件标题</span></span><br><span class="line">            <span class="keyword">const</span> description = info.<span class="property">event</span>.<span class="property">extendedProps</span>.<span class="property">description</span> || <span class="string">&#x27;&#x27;</span>;  <span class="comment">// 获取事件描述，如果没有描述则为空字符串  自定义属性</span></span><br><span class="line">            <span class="comment">// 创建 Tooltip 元素</span></span><br><span class="line">            <span class="keyword">const</span> tooltip = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">            tooltip.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;tooltip&#x27;</span>);</span><br><span class="line">            <span class="comment">// 设置 Tooltip 内容：标题在第一行，描述在第二行（如果有描述）</span></span><br><span class="line">            tooltip.<span class="property">innerHTML</span> = <span class="string">`&lt;strong&gt;标题:<span class="subst">$&#123;title&#125;</span>&lt;/strong&gt;&lt;br&gt;描述：<span class="subst">$&#123;description ? description : <span class="string">&#x27;null&#x27;</span>&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置 Tooltip 样式</span></span><br><span class="line">            tooltip.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;absolute&#x27;</span>;</span><br><span class="line">            tooltip.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;black&#x27;</span>;  <span class="comment">// 黑色背景</span></span><br><span class="line">            tooltip.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;white&#x27;</span>;  <span class="comment">// 白色字体</span></span><br><span class="line">            tooltip.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&#x27;1px solid white&#x27;</span>;  <span class="comment">// 白色边框</span></span><br><span class="line">            tooltip.<span class="property">style</span>.<span class="property">padding</span> = <span class="string">&#x27;5px 10px&#x27;</span>;  <span class="comment">// 内边距</span></span><br><span class="line">            tooltip.<span class="property">style</span>.<span class="property">borderRadius</span> = <span class="string">&#x27;4px&#x27;</span>;  <span class="comment">// 边角圆润</span></span><br><span class="line">            tooltip.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&#x27;12px&#x27;</span>;  <span class="comment">// 字体大小</span></span><br><span class="line"></span><br><span class="line">            tooltip.<span class="property">style</span>.<span class="property">maxWidth</span> = <span class="string">&#x27;500px&#x27;</span>;  <span class="comment">// 设置最大宽度</span></span><br><span class="line">            tooltip.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;auto&#x27;</span>;      <span class="comment">// 宽度自适应内容</span></span><br><span class="line">            tooltip.<span class="property">style</span>.<span class="property">whiteSpace</span> = <span class="string">&#x27;normal&#x27;</span>;  <span class="comment">// 允许文本换行</span></span><br><span class="line">            tooltip.<span class="property">style</span>.<span class="property">wordBreak</span> = <span class="string">&#x27;break-word&#x27;</span>; <span class="comment">// 防止文本溢出</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 确保 Tooltip 在内容过长时能够滚动显示</span></span><br><span class="line">            <span class="comment">//  tooltip.style.maxWidth = &#x27;1000px&#x27;;</span></span><br><span class="line">            <span class="comment">// tooltip.style.overflow = &#x27;auto&#x27;; </span></span><br><span class="line"></span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(tooltip);  <span class="comment">// 将 tooltip 移动到 body 里 calendarEl</span></span><br><span class="line">            <span class="comment">// 使用 Popper.js 来定位 Tooltip</span></span><br><span class="line">            <span class="keyword">const</span> popperInstance = <span class="title class_">Popper</span>.<span class="title function_">createPopper</span>(eventElement, tooltip, &#123;</span><br><span class="line">                <span class="attr">placement</span>: <span class="string">&#x27;top&#x27;</span>,  <span class="comment">// Tooltip 显示在事件上方</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Tooltip 初始为不可见，鼠标悬停时显示</span></span><br><span class="line">            tooltip.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&#x27;hidden&#x27;</span>;</span><br><span class="line">            eventElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseenter&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                tooltip.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&#x27;visible&#x27;</span>;  <span class="comment">// 鼠标悬停时显示</span></span><br><span class="line">                tooltip.<span class="property">style</span>.<span class="property">zIndex</span> = <span class="number">9999</span>;  <span class="comment">// 显示时将 z-index 提升 ,至于最顶层，防止被遮挡</span></span><br><span class="line">                popperInstance.<span class="title function_">update</span>();  <span class="comment">// 强制更新位置</span></span><br><span class="line">            &#125;);</span><br><span class="line">            eventElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseleave&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                tooltip.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&#x27;hidden&#x27;</span>;  <span class="comment">// 鼠标离开时隐藏</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 MutationObserver 监听弹窗的显示</span></span><br><span class="line">            <span class="comment">//由于 FullCalendar 的弹窗是通过动态加载的，你可能需要监听弹窗的显示事件，然后再修改其样式。你可以使用 MutationObserver 来监听 DOM 变动，确保弹窗被渲染出来后再进行修改。</span></span><br><span class="line">            <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="keyword">function</span> (<span class="params">mutationsList, observer</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> mutation <span class="keyword">of</span> mutationsList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mutation.<span class="property">type</span> === <span class="string">&#x27;childList&#x27;</span> &amp;&amp; mutation.<span class="property">addedNodes</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">const</span> popover = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.fc-popover&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (popover) &#123;</span><br><span class="line">                            popover.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;#d3d3d3&#x27;</span>;</span><br><span class="line">                            popover.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;#333&#x27;</span>;</span><br><span class="line">                            popover.<span class="property">style</span>.<span class="property">borderRadius</span> = <span class="string">&#x27;8px&#x27;</span>;</span><br><span class="line">                            popover.<span class="property">style</span>.<span class="property">maxWidth</span> = <span class="string">&#x27;500px&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">const</span> popoverBody = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.fc-popover-body&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (popoverBody) &#123;</span><br><span class="line">                            popoverBody.<span class="property">style</span>.<span class="property">padding</span> = <span class="string">&#x27;0px 10px 10px 10px&#x27;</span>; <span class="comment">// 设置新的 padding 值</span></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.fc-more-popover-misc br&#x27;</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">br</span>) =&gt;</span> &#123;</span><br><span class="line">                            br.<span class="title function_">remove</span>(); <span class="comment">// 移除多余的换行符</span></span><br><span class="line">                        &#125;);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 获取 fc-popover-header  元素</span></span><br><span class="line">                        <span class="keyword">var</span> morePopover = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.fc-popover-header&#x27;</span>);</span><br><span class="line">                        <span class="comment">// 检查元素是否存在</span></span><br><span class="line">                        <span class="keyword">if</span> (morePopover) &#123;</span><br><span class="line">                            <span class="comment">// 设置高度和溢出属性</span></span><br><span class="line">                            morePopover.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;28px&#x27;</span>; <span class="comment">// 你可以根据需要调整高度</span></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        observer.<span class="title function_">disconnect</span>();  <span class="comment">// 一旦修改了样式，停止监听</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 配置观察选项</span></span><br><span class="line">            observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>部门</title>
    <url>/2025/06/09/%E6%B8%B8%E6%88%8F%E7%A0%94%E5%8F%91%E9%83%A8%E9%97%A8%E5%8D%8F%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="游戏开发中各组件的协作流程"><a href="#游戏开发中各组件的协作流程" class="headerlink" title="游戏开发中各组件的协作流程"></a>游戏开发中各组件的协作流程</h1><p>在游戏开发中，客户端、Web、服务器和数据库这几个核心组件通过协同工作来实现完整的游戏体验。以下是它们的协作方式：</p>
<h2 id="1-基本协作架构"><a href="#1-基本协作架构" class="headerlink" title="1. 基本协作架构"></a>1. 基本协作架构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">玩家操作 → 客户端 → (Web层) → 游戏服务器 → 数据库</span><br><span class="line">       ↑        ↓              ↑             ↓</span><br><span class="line">       └────────┴──────────────┴─────────────┘</span><br></pre></td></tr></table></figure>

<h2 id="2-各组件职责与协作细节"><a href="#2-各组件职责与协作细节" class="headerlink" title="2. 各组件职责与协作细节"></a>2. 各组件职责与协作细节</h2><h3 id="客户端-Client"><a href="#客户端-Client" class="headerlink" title="客户端 (Client)"></a>客户端 (Client)</h3><ul>
<li><strong>职责</strong>：负责游戏画面渲染、玩家输入处理、本地逻辑计算</li>
<li><strong>协作方式</strong>：<ul>
<li>向服务器发送玩家操作（移动、攻击等）</li>
<li>接收服务器同步的游戏状态</li>
<li>对于网络游戏，客户端通常不存储关键数据（如玩家等级、装备）</li>
</ul>
</li>
</ul>
<h3 id="Web层-可选"><a href="#Web层-可选" class="headerlink" title="Web层 (可选)"></a>Web层 (可选)</h3><ul>
<li><strong>职责</strong>：<ul>
<li>账号系统、支付系统、公告系统</li>
<li>游戏官网、社区论坛</li>
<li>CDN资源分发</li>
</ul>
</li>
<li><strong>协作方式</strong>：<ul>
<li>处理用户注册&#x2F;登录（通常通过OAuth等协议）</li>
<li>为客户端提供静态资源（游戏更新包、素材等）</li>
<li>与游戏服务器交互获取玩家基础数据</li>
</ul>
</li>
</ul>
<h3 id="游戏服务器-Game-Server"><a href="#游戏服务器-Game-Server" class="headerlink" title="游戏服务器 (Game Server)"></a>游戏服务器 (Game Server)</h3><ul>
<li><strong>职责</strong>：<ul>
<li>游戏核心逻辑计算</li>
<li>反作弊验证</li>
<li>玩家间同步</li>
<li>房间&#x2F;匹配管理</li>
</ul>
</li>
<li><strong>协作方式</strong>：<ul>
<li>接收并验证客户端请求</li>
<li>处理游戏逻辑（战斗计算、道具使用等）</li>
<li>向数据库读写持久化数据</li>
<li>广播游戏状态给相关客户端</li>
</ul>
</li>
</ul>
<h3 id="数据库-Database"><a href="#数据库-Database" class="headerlink" title="数据库 (Database)"></a>数据库 (Database)</h3><ul>
<li><strong>职责</strong>：持久化存储游戏数据</li>
<li><strong>协作方式</strong>：<ul>
<li>存储玩家档案、物品库存、排行榜等</li>
<li>提供事务支持确保数据一致性</li>
<li>通常通过服务器间接访问，客户端不直接操作</li>
</ul>
</li>
</ul>
<h2 id="3-典型数据流示例"><a href="#3-典型数据流示例" class="headerlink" title="3. 典型数据流示例"></a>3. 典型数据流示例</h2><p><strong>场景</strong>：玩家购买游戏道具</p>
<ol>
<li><strong>客户端</strong>：玩家点击购买按钮 → 向Web服务器发送购买请求</li>
<li><strong>Web层</strong>：验证支付信息 → 向游戏服务器发送道具授予请求</li>
<li><strong>游戏服务器</strong>：验证请求合法性 → 更新玩家道具数据 → 将变更写入数据库</li>
<li><strong>数据库</strong>：持久化存储新的道具数据 → 返回成功响应</li>
<li><strong>游戏服务器</strong>：通知客户端更新道具栏</li>
<li><strong>客户端</strong>：刷新UI显示新道具</li>
</ol>
<h2 id="4-技术实现选择"><a href="#4-技术实现选择" class="headerlink" title="4. 技术实现选择"></a>4. 技术实现选择</h2><ul>
<li><strong>通信协议</strong>：<ul>
<li>客户端-服务器：通常使用TCP&#x2F;UDP（如WebSocket、KCP）</li>
<li>Web-服务器：常用HTTP&#x2F;HTTPS、RESTful API或gRPC</li>
</ul>
</li>
<li><strong>数据库类型</strong>：<ul>
<li>关系型：MySQL、PostgreSQL（适合结构化数据）</li>
<li>文档型：MongoDB（适合灵活数据结构）</li>
<li>内存数据库：Redis（用于缓存和实时数据）</li>
</ul>
</li>
</ul>
<h2 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h2><ol>
<li><strong>安全性</strong>：客户端数据必须经过服务器验证</li>
<li><strong>性能</strong>：高频更新数据可先缓存在服务器内存，再异步写入数据库</li>
<li><strong>一致性</strong>：重要操作需要事务支持</li>
<li><strong>容错</strong>：设计重连机制处理网络中断</li>
</ol>
<p>这种协作架构可以根据游戏类型（MMO、竞技、休闲等）进行适当调整，但基本的数据流向和职责划分是相似的。</p>
<h1 id="Web与游戏服务器的关系"><a href="#Web与游戏服务器的关系" class="headerlink" title="Web与游戏服务器的关系"></a>Web与游戏服务器的关系</h1><p>在游戏开发架构中，Web和游戏服务器确实有明确的关系，但它们通常承担不同的职责，协作方式取决于具体设计。以下是它们的详细关系分析：</p>
<h2 id="1-基本关系概述"><a href="#1-基本关系概述" class="headerlink" title="1. 基本关系概述"></a>1. 基本关系概述</h2><p>Web和游戏服务器通常是<strong>分离但协作</strong>的两个组件：</p>
<ul>
<li><strong>Web服务器</strong>：主要处理HTTP&#x2F;HTTPS请求，负责与游戏官网、账号系统、支付等”外围”功能</li>
<li><strong>游戏服务器</strong>：处理核心游戏逻辑和实时通信，使用TCP&#x2F;UDP&#x2F;WebSocket等协议</li>
</ul>
<h2 id="2-常见协作场景"><a href="#2-常见协作场景" class="headerlink" title="2. 常见协作场景"></a>2. 常见协作场景</h2><h3 id="场景1：账号认证流程"><a href="#场景1：账号认证流程" class="headerlink" title="场景1：账号认证流程"></a>场景1：账号认证流程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">玩家 → Web(登录页) → 认证服务 → 游戏服务器</span><br></pre></td></tr></table></figure>
<ol>
<li>玩家通过Web页面登录</li>
<li>Web服务器验证凭证后生成token</li>
<li>玩家客户端使用该token连接游戏服务器</li>
<li>游戏服务器向认证服务验证token有效性</li>
</ol>
<h3 id="场景2：游戏内支付"><a href="#场景2：游戏内支付" class="headerlink" title="场景2：游戏内支付"></a>场景2：游戏内支付</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">玩家 → 游戏服务器 → Web(支付网关) → 第三方支付 → 游戏服务器</span><br></pre></td></tr></table></figure>
<ol>
<li>玩家在游戏内发起购买</li>
<li>游戏服务器将请求转发给Web支付网关</li>
<li>Web处理支付流程后回调通知游戏服务器</li>
<li>游戏服务器发放道具</li>
</ol>
<h3 id="场景3：数据统计展示"><a href="#场景3：数据统计展示" class="headerlink" title="场景3：数据统计展示"></a>场景3：数据统计展示</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库 ← 游戏服务器 → Web(管理后台)</span><br></pre></td></tr></table></figure>
<p>游戏服务器将数据写入数据库，Web后台从数据库读取数据展示给运营人员</p>
<h2 id="3-分离设计的原因"><a href="#3-分离设计的原因" class="headerlink" title="3. 分离设计的原因"></a>3. 分离设计的原因</h2><ol>
<li><p><strong>协议差异</strong>：</p>
<ul>
<li>Web基于HTTP&#x2F;HTTPS（无状态、短连接）</li>
<li>游戏服务器需要长连接、低延迟通信</li>
</ul>
</li>
<li><p><strong>安全隔离</strong>：</p>
<ul>
<li>Web暴露在公网，面临更多攻击面</li>
<li>游戏服务器通常需要更严格的网络隔离</li>
</ul>
</li>
<li><p><strong>扩展性</strong>：</p>
<ul>
<li>Web层可以水平扩展应对突发流量</li>
<li>游戏服务器需要保持玩家会话状态</li>
</ul>
</li>
<li><p><strong>职责分离</strong>：</p>
<ul>
<li>Web：用户管理、内容分发、社区功能</li>
<li>游戏服务器：实时同步、战斗计算等</li>
</ul>
</li>
</ol>
<h2 id="4-混合架构案例"><a href="#4-混合架构案例" class="headerlink" title="4. 混合架构案例"></a>4. 混合架构案例</h2><p>有些轻量级游戏会采用<strong>WebSocket服务器</strong>同时承担Web和游戏服务器角色：</p>
<ul>
<li>使用同一个Node.js&#x2F;Spring等服务同时处理：<ul>
<li>HTTP请求（官网、API）</li>
<li>WebSocket连接（游戏实时通信）</li>
</ul>
</li>
<li>优点是架构简单，适合小规模游戏</li>
</ul>
<h2 id="5-关键交互点"><a href="#5-关键交互点" class="headerlink" title="5. 关键交互点"></a>5. 关键交互点</h2><p>两者主要通过以下方式交互：</p>
<ol>
<li><strong>共享数据库</strong>：都访问同一个用户数据存储</li>
<li><strong>RPC调用</strong>：通过内部网络API相互调用</li>
<li><strong>消息队列</strong>：用于异步事件通知（如支付完成事件）</li>
<li><strong>共享缓存</strong>：如Redis存储会话状态</li>
</ol>
<p>是否需要完全分离取决于游戏类型和规模，大型游戏通常保持分离架构，而休闲网页游戏可能合并两者。</p>
<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><p>在游戏开发架构中，不同类型的数据会存储在不同的位置，根据数据的重要性、访问频率和安全性要求进行分布。以下是客户端、Web服务器、游戏服务器和数据库各自存储的数据类型及位置：</p>
<hr>
<h2 id="1-客户端存储的数据"><a href="#1-客户端存储的数据" class="headerlink" title="1. 客户端存储的数据"></a><strong>1. 客户端存储的数据</strong></h2><p><strong>存储位置</strong>：玩家设备（PC&#x2F;手机&#x2F;游戏主机）的本地存储<br><strong>数据类型</strong>（通常是非关键或临时数据）：</p>
<ul>
<li><strong>本地设置</strong>：画面质量、音量、键位配置</li>
<li><strong>缓存资源</strong>：下载的游戏素材（纹理、音效、模型）</li>
<li><strong>临时状态</strong>：未提交的游戏进度（单机游戏）、会话Token</li>
<li><strong>预测数据</strong>：客户端预测的玩家位置（网络游戏先显示，后由服务器验证）</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>易丢失（玩家清理缓存或换设备会消失）</li>
<li>可能被篡改（需服务器验证重要数据）</li>
</ul>
<hr>
<h2 id="2-Web服务器存储的数据"><a href="#2-Web服务器存储的数据" class="headerlink" title="2. Web服务器存储的数据"></a><strong>2. Web服务器存储的数据</strong></h2><p><strong>存储位置</strong>：Web服务器的文件系统或缓存（如CDN）<br><strong>数据类型</strong>：</p>
<ul>
<li><strong>静态资源</strong>：官网HTML&#x2F;JS&#x2F;CSS、游戏补丁下载包</li>
<li><strong>会话信息</strong>：用户登录状态的Session或JWT Token（短期）</li>
<li><strong>CDN缓存</strong>：热更新的游戏资源（皮肤、活动素材）</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>通常是无状态的（依赖数据库持久化关键数据）</li>
<li>高可用性要求（通过负载均衡多节点部署）</li>
</ul>
<hr>
<h2 id="3-游戏服务器存储的数据"><a href="#3-游戏服务器存储的数据" class="headerlink" title="3. 游戏服务器存储的数据"></a><strong>3. 游戏服务器存储的数据</strong></h2><p><strong>存储位置</strong>：服务器内存 + 数据库<br><strong>数据类型</strong>：</p>
<ul>
<li><strong>内存中（临时）</strong>：<ul>
<li>实时游戏状态（玩家位置、战斗数值）</li>
<li>房间&#x2F;匹配信息（MOBA&#x2F;吃鸡的战场数据）</li>
<li>会话连接（Socket连接状态）</li>
</ul>
</li>
<li><strong>持久化到数据库</strong>：<ul>
<li>玩家档案（等级、装备、成就）</li>
<li>交易记录（充值、道具购买）</li>
</ul>
</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>内存数据追求高性能（Redis&#x2F;Memcached）</li>
<li>持久化数据需强一致性（MySQL&#x2F;MongoDB事务）</li>
</ul>
<hr>
<h2 id="4-数据库存储的核心数据"><a href="#4-数据库存储的核心数据" class="headerlink" title="4. 数据库存储的核心数据"></a><strong>4. 数据库存储的核心数据</strong></h2><p><strong>存储位置</strong>：独立数据库集群<br><strong>数据类型</strong>：</p>
<ul>
<li><strong>结构化数据</strong>（关系型数据库如MySQL&#x2F;PostgreSQL）：<ul>
<li>玩家账号信息（用户名、密码哈希、绑定邮箱）</li>
<li>物品库存（装备、货币数量）</li>
<li>社交关系（好友列表、公会数据）</li>
</ul>
</li>
<li><strong>非结构化数据</strong>（文档型数据库如MongoDB）：<ul>
<li>玩家行为日志（分析用）</li>
<li>动态配置（活动规则、赛季参数）</li>
</ul>
</li>
<li><strong>高速缓存</strong>（Redis等）：<ul>
<li>排行榜实时数据</li>
<li>限时活动状态</li>
</ul>
</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>高可靠性（主从复制、定期备份）</li>
<li>敏感数据加密（如密码、支付信息）</li>
</ul>
<hr>
<h2 id="5-数据流向示例"><a href="#5-数据流向示例" class="headerlink" title="5. 数据流向示例"></a><strong>5. 数据流向示例</strong></h2><p>以玩家获得新装备为例：</p>
<ol>
<li><strong>客户端</strong>：发送”开宝箱”请求 → 游戏服务器  </li>
<li><strong>游戏服务器</strong>：  <ul>
<li>内存中计算掉落概率  </li>
<li>向数据库写入新装备记录（事务保证原子性）</li>
</ul>
</li>
<li><strong>数据库</strong>：持久化装备数据 → 返回成功  </li>
<li><strong>游戏服务器</strong>：  <ul>
<li>更新内存中的玩家装备列表  </li>
<li>广播给客户端和其他玩家（如MMO中装备特效）</li>
</ul>
</li>
<li><strong>客户端</strong>：本地显示新装备（非权威，以服务器数据为准）</li>
</ol>
<hr>
<h2 id="关键原则"><a href="#关键原则" class="headerlink" title="关键原则"></a><strong>关键原则</strong></h2><ol>
<li><strong>权威数据在服务端</strong>：客户端只显示，服务器决定真实性  </li>
<li><strong>分层存储</strong>：  <ul>
<li>热数据在内存（Redis&#x2F;服务器内存）  </li>
<li>冷数据在数据库</li>
</ul>
</li>
<li><strong>安全边界</strong>：  <ul>
<li>客户端 ↔ Web服务器：HTTPS加密  </li>
<li>Web服务器 ↔ 游戏服务器：内网通信 + API鉴权</li>
</ul>
</li>
<li><strong>防作弊</strong>：关键逻辑（如伤害计算）必须在服务器执行</li>
</ol>
<p>不同游戏类型（单机、手游、MMO）会有存储策略差异，但核心原则一致：<strong>确保数据安全、一致，同时提供流畅的玩家体验</strong>。</p>
]]></content>
      <categories>
        <category>游戏研发</category>
      </categories>
      <tags>
        <tag>游戏研发</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏资源服部署</title>
    <url>/2025/02/08/%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%E6%9C%8D%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="unity-游戏开发时要用的ftp-hfs-内网穿透-http-这些干嘛的，局域网共享如何做到？"><a href="#unity-游戏开发时要用的ftp-hfs-内网穿透-http-这些干嘛的，局域网共享如何做到？" class="headerlink" title="unity 游戏开发时要用的ftp hfs 内网穿透 http,这些干嘛的，局域网共享如何做到？"></a>unity 游戏开发时要用的ftp hfs 内网穿透 http,这些干嘛的，局域网共享如何做到？</h1><p>在 Unity 游戏开发中，<strong>FTP</strong>、<strong>HFS</strong>、<strong>内网穿透</strong> 和 <strong>HTTP</strong> 等技术通常用于 <strong>文件传输</strong>、<strong>资源共享</strong> 和 <strong>远程访问</strong>。它们能帮助开发团队更高效地管理资源、进行热更新、以及在开发和测试过程中共享文件。以下是它们的详细用途和如何实现局域网共享。</p>
<h3 id="1-FTP（File-Transfer-Protocol）"><a href="#1-FTP（File-Transfer-Protocol）" class="headerlink" title="1. FTP（File Transfer Protocol）"></a><strong>1. FTP（File Transfer Protocol）</strong></h3><ul>
<li><p><strong>作用</strong>：FTP 是一种用于在客户端和服务器之间传输文件的协议，特别适合批量文件的上传和下载。在游戏开发中，可以使用 FTP 将资源、更新包、构建文件等从本地上传到服务器，或者从服务器下载到本地进行测试。</p>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>将 Unity 项目的资源（如 <code>AssetBundles</code>、<code>Textures</code>、<code>Sounds</code>）上传到 FTP 服务器，供其他团队成员或测试人员下载。</li>
<li>热更新时，使用 FTP 从服务器下载最新的资源包或更新文件。</li>
</ul>
</li>
<li><p><strong>实现方式</strong>：</p>
<ul>
<li>可以使用 Unity 中的第三方 FTP 插件（如 <code>System.Net.FtpWebRequest</code>）来连接到 FTP 服务器进行文件上传和下载操作。</li>
<li>在游戏开发过程中，常常会通过 <strong>FTP 客户端</strong>（如 FileZilla）与 FTP 服务器进行文件交换。</li>
</ul>
</li>
</ul>
<h3 id="2-HFS（HTTP-File-Server）"><a href="#2-HFS（HTTP-File-Server）" class="headerlink" title="2. HFS（HTTP File Server）"></a><strong>2. HFS（HTTP File Server）</strong></h3><ul>
<li><p>教程：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Xm4y1g7Sq/?spm_id_from=333.880.my_history.page.click&vd_source=93e9aaa0076b54e6be62025284056121">软件部署视频</a></li>
<li><a href="https://www.bilibili.com/video/BV1vF411T7y6/?spm_id_from=333.880.my_history.page.click&vd_source=93e9aaa0076b54e6be62025284056121">网页部署视频</a></li>
</ul>
</li>
<li><p><strong>作用</strong>：HFS 是一个轻量级的 HTTP 文件服务器工具，允许用户在局域网内快速共享文件。与 FTP 不同，HFS 使用 HTTP 协议来提供文件的上传和下载，这使得它在局域网中更易于使用和配置。</p>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>用 HFS 设置一个简易的文件服务器，在内网中共享 Unity 游戏资源、热更新文件和其他开发相关文件。</li>
<li>通过 HTTP 协议，在开发过程中通过浏览器访问服务器，下载或上传文件。</li>
</ul>
</li>
<li><p><strong>实现方式</strong>：</p>
<ul>
<li>安装并启动 HFS，选择要共享的文件夹，HFS 会提供一个可以通过 HTTP 访问的 URL。</li>
<li>例如：<code>http://your-server-ip:8080</code>，其他团队成员可以通过这个地址访问文件。</li>
</ul>
</li>
<li><p><strong>局域网共享</strong>：</p>
<ul>
<li>通过 HFS，在同一局域网内，其他开发者可以通过浏览器访问服务器，下载或上传资源。确保设备在同一网络中，且防火墙允许 HTTP 端口访问。</li>
</ul>
</li>
</ul>
<h3 id="3-内网穿透"><a href="#3-内网穿透" class="headerlink" title="3. 内网穿透"></a><strong>3. 内网穿透</strong></h3><ul>
<li><p><strong>作用</strong>：内网穿透技术使得位于 <strong>局域网</strong>（LAN）中的设备可以通过 <strong>公网 IP</strong> 访问。开发过程中，内网穿透可以帮助开发者将本地服务器（如本地开发环境或数据库）暴露到互联网上，供远程人员或团队成员访问。</p>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>在开发阶段，开发者的本地服务器或测试环境通常位于局域网中，无法直接从外部访问。通过内网穿透，可以让远程开发人员访问本地测试服务器（例如，访问你搭建的 HFS 服务器或 Unity 编辑器）。</li>
<li>用于 <strong>Unity 项目热更新</strong>，将开发机上的资源通过内网穿透提供给远程机器进行更新。</li>
</ul>
</li>
<li><p><strong>实现方式</strong>：</p>
<ul>
<li>使用内网穿透工具，如 <strong>Ngrok</strong>、<strong>Frp</strong> 或 <strong>ZeroTier</strong>，将内网服务器暴露到外网。</li>
<li>例如，使用 Ngrok：<code>ngrok http 8080</code> 会将本地的 8080 端口映射到一个公网地址，其他开发者可以通过这个公网地址访问本地服务器。</li>
</ul>
</li>
</ul>
<h3 id="4-HTTP（HyperText-Transfer-Protocol）"><a href="#4-HTTP（HyperText-Transfer-Protocol）" class="headerlink" title="4. HTTP（HyperText Transfer Protocol）"></a><strong>4. HTTP（HyperText Transfer Protocol）</strong></h3><ul>
<li><p><strong>作用</strong>：HTTP 是一种用于传输网页数据的协议，通常用于文件的上传和下载。在游戏开发中，HTTP 通常与其他工具（如 HFS）结合使用，提供远程资源更新、资源下载等功能。</p>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li><strong>资源下载</strong>：通过 HTTP 协议从服务器获取资源包、补丁包等文件。比如，游戏客户端会通过 HTTP 向服务器请求资源更新包，并下载到本地。</li>
<li><strong>服务器交互</strong>：HTTP 用于客户端与服务器之间的数据交换，如热更新过程中的文件传输。</li>
</ul>
</li>
<li><p><strong>实现方式</strong>：</p>
<ul>
<li>Unity 可以使用 <code>UnityWebRequest</code> 来通过 HTTP 协议进行资源的下载和上传。例如：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">UnityWebRequest request = UnityWebRequest.Get(<span class="string">&quot;https://your-server.com/resourcepack.zip&quot;</span>);</span><br><span class="line">request.SendWebRequest().completed += (asyncOp) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (request.result == UnityWebRequest.Result.Success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理下载的文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="string">&quot;Failed to download: &quot;</span> + request.error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="5-局域网共享实现方法："><a href="#5-局域网共享实现方法：" class="headerlink" title="5. 局域网共享实现方法："></a><strong>5. 局域网共享实现方法：</strong></h3><h4 id="使用-HFS-或-FTP-进行局域网共享："><a href="#使用-HFS-或-FTP-进行局域网共享：" class="headerlink" title="使用 HFS 或 FTP 进行局域网共享："></a><strong>使用 HFS 或 FTP 进行局域网共享</strong>：</h4><ul>
<li><p><strong>通过 HFS</strong>：</p>
<ol>
<li>在局域网中的计算机上安装并配置 HFS。</li>
<li>在 HFS 配置界面中选择要共享的文件夹，启动 HTTP 文件共享。</li>
<li>其他计算机可以在同一网络中使用浏览器访问 HFS 服务器提供的 IP 地址（例如 <code>http://192.168.1.100:8080</code>）下载或上传资源。</li>
</ol>
</li>
<li><p><strong>通过 FTP</strong>：</p>
<ol>
<li>设置一个 <strong>FTP 服务器</strong>（如 FileZilla Server），并配置好 FTP 用户和权限。</li>
<li>在 Unity 编辑器中使用 FTP 插件来从 FTP 服务器上传和下载文件，或者手动使用 FTP 客户端管理文件。</li>
<li>局域网内的其他设备可以通过 FTP 客户端访问这个 FTP 服务器，进行资源的上传和下载。</li>
</ol>
</li>
</ul>
<h4 id="通过内网穿透实现远程访问："><a href="#通过内网穿透实现远程访问：" class="headerlink" title="通过内网穿透实现远程访问："></a><strong>通过内网穿透实现远程访问</strong>：</h4><ol>
<li>使用 <strong>Ngrok</strong> 或 <strong>Frp</strong> 等内网穿透工具，将局域网中的服务器暴露到公网。</li>
<li>在远程设备上使用内网穿透的公网 IP 地址访问本地文件服务器，进行资源共享和下载。</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><ul>
<li><strong>FTP</strong> 和 <strong>HFS</strong> 用于 <strong>局域网内共享资源</strong>，方便开发者和测试人员访问和下载资源。</li>
<li><strong>内网穿透</strong> 允许你在局域网环境中搭建的文件服务器（如 HFS 或 Unity 编辑器）暴露到外网，供远程人员访问。</li>
<li><strong>HTTP</strong> 是访问资源服务器的常用协议，结合 <strong>HFS</strong> 或 <strong>FTP</strong> 提供资源文件的下载功能。</li>
</ul>
<p>通过以上技术，你可以轻松实现局域网或远程资源共享，进行高效的资源管理和热更新。</p>
<h1 id="如果要搭建远程资源服务器，那要如何保证外界的访问"><a href="#如果要搭建远程资源服务器，那要如何保证外界的访问" class="headerlink" title="如果要搭建远程资源服务器，那要如何保证外界的访问"></a>如果要搭建远程资源服务器，那要如何保证外界的访问</h1><p>要搭建一个远程资源服务器，并确保外界能够访问，你需要做好 <strong>服务器搭建、网络配置、安全防护</strong> 等多个方面的工作。以下是详细的步骤：</p>
<hr>
<h2 id="1-选择服务器"><a href="#1-选择服务器" class="headerlink" title="1. 选择服务器"></a><strong>1. 选择服务器</strong></h2><p>你可以选择以下几种方式搭建远程资源服务器：</p>
<ul>
<li><p><strong>云服务器（推荐）</strong>：</p>
<ul>
<li>购买 <strong>云服务器</strong>（如阿里云、腾讯云、AWS、Vultr 等）。</li>
<li>适合公网访问，带宽稳定，可配置防火墙和访问控制。</li>
</ul>
</li>
<li><p><strong>本地服务器（内网穿透）</strong>：</p>
<ul>
<li>直接在家用或公司服务器上搭建，但需要内网穿透让外网访问。</li>
<li>适用于开发阶段测试，公网访问不稳定。</li>
</ul>
</li>
<li><p><strong>NAS 设备</strong>：</p>
<ul>
<li>适用于局域网环境，也可以结合动态域名（DDNS）和端口映射实现外部访问。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-服务器环境搭建"><a href="#2-服务器环境搭建" class="headerlink" title="2. 服务器环境搭建"></a><strong>2. 服务器环境搭建</strong></h2><p>根据你的需求，可以使用不同的服务器环境来提供远程资源访问：</p>
<h3 id="1-使用-HFS（轻量级-HTTP-服务器）"><a href="#1-使用-HFS（轻量级-HTTP-服务器）" class="headerlink" title="(1) 使用 HFS（轻量级 HTTP 服务器）"></a><strong>(1) 使用 HFS（轻量级 HTTP 服务器）</strong></h3><ul>
<li>HFS（HTTP File Server）是一个简单的 HTTP 服务器，适合在 Windows 上快速共享文件：<ol>
<li>下载 HFS（<a href="http://www.rejetto.com/hfs/">http://www.rejetto.com/hfs/</a>）。</li>
<li>运行 HFS，选择要共享的文件夹。</li>
<li>HFS 会提供一个 <code>http://你的IP地址:端口</code> 供外部访问。</li>
<li>配置 <strong>端口转发（Port Forwarding）</strong> 和 <strong>动态域名</strong> 以允许外网访问。</li>
</ol>
</li>
</ul>
<h3 id="2-使用-FTP-服务器"><a href="#2-使用-FTP-服务器" class="headerlink" title="(2) 使用 FTP 服务器"></a><strong>(2) 使用 FTP 服务器</strong></h3><ul>
<li>适用于文件传输，可以用 <strong>FileZilla Server</strong> 搭建 FTP 服务器：<ol>
<li>安装 <strong>FileZilla Server</strong>（<a href="https://filezilla-project.org/">https://filezilla-project.org/</a>）。</li>
<li>配置 FTP 账户和文件共享目录。</li>
<li>开放 <strong>21 端口</strong>，允许外部访问。</li>
<li>通过 <strong>动态域名（DDNS）+ 端口转发</strong> 让公网可以访问。</li>
</ol>
</li>
</ul>
<h3 id="3-使用-Web-服务器（Apache-Nginx）"><a href="#3-使用-Web-服务器（Apache-Nginx）" class="headerlink" title="(3) 使用 Web 服务器（Apache &#x2F; Nginx）"></a><strong>(3) 使用 Web 服务器（Apache &#x2F; Nginx）</strong></h3><ul>
<li>如果你希望远程访问资源并支持热更新，推荐使用 Web 服务器：<ul>
<li><strong>Apache</strong>：<ol>
<li>在服务器上安装 Apache（Linux: <code>sudo apt install apache2</code>）。</li>
<li>配置 <code>DocumentRoot</code> 指向存放资源的目录。</li>
<li>启动 Apache 并开放 80&#x2F;443 端口。</li>
</ol>
</li>
<li><strong>Nginx</strong>：<ol>
<li>在服务器上安装 Nginx（Linux: <code>sudo apt install nginx</code>）。</li>
<li>配置 <code>server &#123;&#125;</code> 块指向资源目录：<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> your-domain.com;</span><br><span class="line">    <span class="attribute">root</span> /var/www/game-assets;</span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">on</span>;  <span class="comment"># 开启目录索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重启 Nginx 并开放 80&#x2F;443 端口。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-确保外界能访问"><a href="#3-确保外界能访问" class="headerlink" title="3. 确保外界能访问"></a><strong>3. 确保外界能访问</strong></h2><h3 id="1-端口转发（Port-Forwarding）"><a href="#1-端口转发（Port-Forwarding）" class="headerlink" title="(1) 端口转发（Port Forwarding）"></a><strong>(1) 端口转发（Port Forwarding）</strong></h3><p>如果服务器在 <strong>内网</strong>，你需要在路由器上<strong>转发端口</strong>，允许外部访问：</p>
<ul>
<li>登录路由器管理页面（通常是 <code>192.168.1.1</code>）。</li>
<li>找到 <strong>端口转发 &#x2F; 虚拟服务器</strong> 设置。</li>
<li><strong>添加转发规则</strong>：<ul>
<li>协议：TCP</li>
<li>内部 IP：本地服务器 IP（如 <code>192.168.1.100</code>）</li>
<li>内部端口：服务器监听端口（如 <code>80</code> 或 <code>8080</code>）</li>
<li>外部端口：与内部端口相同（或 <code>80</code> 映射 <code>8080</code>）</li>
</ul>
</li>
</ul>
<h3 id="2-绑定动态域名（DDNS）"><a href="#2-绑定动态域名（DDNS）" class="headerlink" title="(2) 绑定动态域名（DDNS）"></a><strong>(2) 绑定动态域名（DDNS）</strong></h3><p>如果你的公网 IP 不是固定的，可以使用 <strong>动态域名解析（DDNS）</strong> 绑定一个固定域名：</p>
<ol>
<li><strong>注册 DDNS 服务</strong>（如 <strong>No-IP</strong>、<strong>花生壳</strong>）。</li>
<li><strong>在路由器或服务器上配置 DDNS</strong>，自动更新公网 IP。</li>
<li>访问你的 DDNS 域名（如 <code>yourname.ddns.net</code>）。</li>
</ol>
<h3 id="3-使用内网穿透"><a href="#3-使用内网穿透" class="headerlink" title="(3) 使用内网穿透"></a><strong>(3) 使用内网穿透</strong></h3><p>如果你无法控制路由器或 ISP 限制端口，你可以使用 <strong>内网穿透工具</strong>：</p>
<ul>
<li><strong>Ngrok</strong>（临时测试）：<code>ngrok http 80</code> 会生成一个公网 URL。</li>
<li><strong>Frp</strong>（推荐）：搭建 <strong>Frp 服务器</strong>，将内网服务映射到外网。</li>
<li><strong>ZeroTier</strong>（内网互通）：建立虚拟局域网，允许外网访问。</li>
</ul>
<h3 id="4-配置-HTTPS-访问"><a href="#4-配置-HTTPS-访问" class="headerlink" title="(4) 配置 HTTPS 访问"></a><strong>(4) 配置 HTTPS 访问</strong></h3><p>为了安全性，建议使用 HTTPS：</p>
<ul>
<li><strong>Let’s Encrypt</strong> 提供免费 SSL 证书，安装 Certbot 自动获取证书：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> certbot --nginx -d your-domain.com</span><br></pre></td></tr></table></figure></li>
<li>Nginx 配置 HTTPS：<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> your-domain.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/your-domain.com/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/your-domain.com/privkey.pem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="4-在-Unity-里请求资源"><a href="#4-在-Unity-里请求资源" class="headerlink" title="4. 在 Unity 里请求资源"></a><strong>4. 在 Unity 里请求资源</strong></h2><p>当你的远程服务器搭建完成后，可以在 Unity 代码中使用 <code>UnityWebRequest</code> 下载资源：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">DownloadResource</span>(<span class="params"><span class="built_in">string</span> url</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    UnityWebRequest request = UnityWebRequest.Get(url);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> request.SendWebRequest();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.result == UnityWebRequest.Result.Success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] data = request.downloadHandler.data;</span><br><span class="line">        File.WriteAllBytes(Application.persistentDataPath + <span class="string">&quot;/downloaded_file&quot;</span>, data);</span><br><span class="line">        Debug.Log(<span class="string">&quot;下载成功: &quot;</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="string">&quot;下载失败: &quot;</span> + request.error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">StartCoroutine(DownloadResource(<span class="string">&quot;https://your-domain.com/assets/update.dat&quot;</span>));</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-远程资源热更新"><a href="#5-远程资源热更新" class="headerlink" title="5. 远程资源热更新"></a><strong>5. 远程资源热更新</strong></h2><p>在 <strong>HybridCLR + UnityGameFramework（UGF）</strong> 组合中，你需要 <strong>同时更新 C# 热更 DLL 和 资源文件</strong>：</p>
<ol>
<li><strong>存放 C# 热更 DLL</strong>（<code>Assembly-CSharp.dll</code> 等）在服务器的 <code>hotfix</code> 目录。</li>
<li><strong>存放资源（AssetBundles）</strong> 在 <code>assets</code> 目录。</li>
<li><strong>在 UGF 里配置资源下载地址</strong>：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GameEntry.Resource.UpdatePrefixUri = <span class="string">&quot;https://your-domain.com/assets/&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>使用 UnityGameFramework 下载和更新资源</strong>。</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>✅ <strong>云服务器方案（推荐）</strong>：最稳定，直接公网访问。<br>✅ <strong>端口转发 + DDNS</strong>：适合内网服务器，映射到公网。<br>✅ <strong>内网穿透（Frp &#x2F; Ngrok）</strong>：适合无公网 IP 的场景。<br>✅ <strong>HTTP &#x2F; FTP 服务器</strong>：提供资源下载，结合 Unity 进行热更新。<br>✅ <strong>启用 HTTPS</strong>：提升安全性，避免数据被篡改。  </p>
<p>如果你的游戏需要频繁更新，建议采用 <strong>云服务器 + CDN</strong> 方案，这样可以提高资源下载的速度和稳定性！🚀</p>
<h1 id="游戏资源服部署"><a href="#游戏资源服部署" class="headerlink" title="游戏资源服部署"></a>游戏资源服部署</h1><p>游戏资源服务器的部署涉及<strong>服务器环境搭建、资源存储与访问、网络配置、安全防护</strong>等多个方面。下面是详细的部署方案，涵盖<strong>云服务器、内网服务器、CDN 加速、内网穿透</strong>等不同方案，适用于 <strong>Unity 热更新（UGF&#x2F;HybridCLR）</strong> 场景。  </p>
<hr>
<h2 id="🎯-1-选择服务器"><a href="#🎯-1-选择服务器" class="headerlink" title="🎯 1. 选择服务器"></a><strong>🎯 1. 选择服务器</strong></h2><p>你可以选择以下方式来搭建资源服务器：  </p>
<table>
<thead>
<tr>
<th>方案</th>
<th>适用场景</th>
<th>访问方式</th>
<th>成本</th>
<th>适用人群</th>
</tr>
</thead>
<tbody><tr>
<td><strong>云服务器</strong></td>
<td>游戏上线、公测、远程更新</td>
<td>直接公网访问</td>
<td>付费（带宽计费）</td>
<td>公司团队</td>
</tr>
<tr>
<td><strong>本地服务器</strong></td>
<td>局域网测试、内网共享</td>
<td>需端口转发&#x2F;DDNS</td>
<td>低</td>
<td>个人&#x2F;小团队</td>
</tr>
<tr>
<td><strong>CDN 加速</strong></td>
<td>提高下载速度</td>
<td>依赖源站</td>
<td>付费</td>
<td>大型游戏</td>
</tr>
</tbody></table>
<hr>
<h2 id="🚀-2-搭建资源服务器"><a href="#🚀-2-搭建资源服务器" class="headerlink" title="🚀 2. 搭建资源服务器"></a><strong>🚀 2. 搭建资源服务器</strong></h2><h3 id="🔹-方案-1：使用-Web-服务器（Nginx-Apache）"><a href="#🔹-方案-1：使用-Web-服务器（Nginx-Apache）" class="headerlink" title="🔹 方案 1：使用 Web 服务器（Nginx &#x2F; Apache）"></a><strong>🔹 方案 1：使用 Web 服务器（Nginx &#x2F; Apache）</strong></h3><p>适合 <strong>云服务器 &#x2F; 本地服务器</strong>，支持 HTTP 访问资源。</p>
<h4 id="1-安装-Nginx"><a href="#1-安装-Nginx" class="headerlink" title="(1) 安装 Nginx"></a><strong>(1) 安装 Nginx</strong></h4><p><strong>Linux（Ubuntu &#x2F; CentOS）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install nginx -y</span><br></pre></td></tr></table></figure>
<p><strong>Windows</strong> 可以使用 <a href="https://www.apachefriends.org/zh_cn/index.html">XAMPP</a> 直接部署 Apache。</p>
<h4 id="2-配置资源目录"><a href="#2-配置资源目录" class="headerlink" title="(2) 配置资源目录"></a><strong>(2) 配置资源目录</strong></h4><p>编辑 Nginx 配置 <code>/etc/nginx/sites-available/default</code>：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> your-domain.com;</span><br><span class="line">    <span class="attribute">root</span> /var/www/game-assets;</span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">on</span>;  <span class="comment"># 开启目录浏览</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>资源放在 <code>/var/www/game-assets</code></li>
<li>访问 <code>http://your-domain.com/assets/xxx.ab</code></li>
</ul>
<h4 id="3-启动-Nginx"><a href="#3-启动-Nginx" class="headerlink" title="(3) 启动 Nginx"></a><strong>(3) 启动 Nginx</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart nginx</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🔹-方案-2：使用-FTP-服务器"><a href="#🔹-方案-2：使用-FTP-服务器" class="headerlink" title="🔹 方案 2：使用 FTP 服务器"></a><strong>🔹 方案 2：使用 FTP 服务器</strong></h3><p>适合 <strong>内网共享</strong>，客户端通过 FTP 下载资源。</p>
<h4 id="1-安装-FTP-服务器"><a href="#1-安装-FTP-服务器" class="headerlink" title="(1) 安装 FTP 服务器"></a><strong>(1) 安装 FTP 服务器</strong></h4><p><strong>Linux</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install vsftpd -y</span><br></pre></td></tr></table></figure>
<p><strong>Windows</strong></p>
<ul>
<li><strong>FileZilla Server</strong>: <a href="https://filezilla-project.org/">https://filezilla-project.org/</a></li>
</ul>
<h4 id="2-创建-FTP-账户"><a href="#2-创建-FTP-账户" class="headerlink" title="(2) 创建 FTP 账户"></a><strong>(2) 创建 FTP 账户</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> adduser ftpuser</span><br><span class="line"><span class="built_in">sudo</span> passwd ftpuser</span><br></pre></td></tr></table></figure>

<h4 id="3-配置-FTP-目录"><a href="#3-配置-FTP-目录" class="headerlink" title="(3) 配置 FTP 目录"></a><strong>(3) 配置 FTP 目录</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /var/ftp/game-assets</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> ftpuser:ftpuser /var/ftp/game-assets</span><br></pre></td></tr></table></figure>

<h4 id="4-开放-FTP-端口（21）"><a href="#4-开放-FTP-端口（21）" class="headerlink" title="(4) 开放 FTP 端口（21）"></a><strong>(4) 开放 FTP 端口（21）</strong></h4><p>在服务器安全组&#x2F;防火墙中<strong>允许 TCP 21 端口</strong>。</p>
<h4 id="5-客户端访问"><a href="#5-客户端访问" class="headerlink" title="(5) 客户端访问"></a><strong>(5) 客户端访问</strong></h4><p>Unity 端代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> ftpUrl = <span class="string">&quot;ftp://your-ip/game-assets/update.ab&quot;</span>;</span><br><span class="line">WebClient client = <span class="keyword">new</span> WebClient();</span><br><span class="line">client.Credentials = <span class="keyword">new</span> NetworkCredential(<span class="string">&quot;ftpuser&quot;</span>, <span class="string">&quot;yourpassword&quot;</span>);</span><br><span class="line">client.DownloadFile(ftpUrl, Application.persistentDataPath + <span class="string">&quot;/update.ab&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🔹-方案-3：使用-HFS（轻量级-HTTP-服务器）"><a href="#🔹-方案-3：使用-HFS（轻量级-HTTP-服务器）" class="headerlink" title="🔹 方案 3：使用 HFS（轻量级 HTTP 服务器）"></a><strong>🔹 方案 3：使用 HFS（轻量级 HTTP 服务器）</strong></h3><p>适用于 <strong>内网测试 &#x2F; 小团队</strong>，简单快捷。</p>
<h4 id="1-下载-HFS"><a href="#1-下载-HFS" class="headerlink" title="(1) 下载 HFS"></a><strong>(1) 下载 HFS</strong></h4><p><a href="http://www.rejetto.com/hfs/?f=dl">下载地址</a></p>
<h4 id="2-运行-HFS"><a href="#2-运行-HFS" class="headerlink" title="(2) 运行 HFS"></a><strong>(2) 运行 HFS</strong></h4><ol>
<li>打开 HFS.exe</li>
<li>拖入 <code>game-assets</code> 文件夹</li>
<li>获取本机 IP（如 <code>192.168.1.100:8080</code>）</li>
<li>访问 <code>http://192.168.1.100:8080/game-assets</code></li>
</ol>
<h4 id="3-Unity-下载资源"><a href="#3-Unity-下载资源" class="headerlink" title="(3) Unity 下载资源"></a><strong>(3) Unity 下载资源</strong></h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">DownloadResource</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> url = <span class="string">&quot;http://192.168.1.100:8080/game-assets/update.ab&quot;</span>;</span><br><span class="line">    UnityWebRequest request = UnityWebRequest.Get(url);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> request.SendWebRequest();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (request.result == UnityWebRequest.Result.Success)</span><br><span class="line">    &#123;</span><br><span class="line">        File.WriteAllBytes(Application.persistentDataPath + <span class="string">&quot;/update.ab&quot;</span>, request.downloadHandler.data);</span><br><span class="line">        Debug.Log(<span class="string">&quot;下载成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🔹-方案-4：使用-CDN-加速"><a href="#🔹-方案-4：使用-CDN-加速" class="headerlink" title="🔹 方案 4：使用 CDN 加速"></a><strong>🔹 方案 4：使用 CDN 加速</strong></h3><p>适用于 <strong>正式上线 &#x2F; 大型游戏</strong>，提高资源下载速度。</p>
<h4 id="1-选择-CDN-服务"><a href="#1-选择-CDN-服务" class="headerlink" title="(1) 选择 CDN 服务"></a><strong>(1) 选择 CDN 服务</strong></h4><ul>
<li><strong>阿里云 OSS + CDN</strong></li>
<li><strong>腾讯云 COS + CDN</strong></li>
<li><strong>Cloudflare（免费 HTTPS 加速）</strong></li>
</ul>
<h4 id="2-上传资源"><a href="#2-上传资源" class="headerlink" title="(2) 上传资源"></a><strong>(2) 上传资源</strong></h4><p>如果使用 <strong>阿里云 OSS</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ossutil <span class="built_in">cp</span> -r ./game-assets oss://your-bucket/game-assets</span><br></pre></td></tr></table></figure>

<h4 id="3-配置-CDN-加速"><a href="#3-配置-CDN-加速" class="headerlink" title="(3) 配置 CDN 加速"></a><strong>(3) 配置 CDN 加速</strong></h4><p>在 CDN 控制台：</p>
<ul>
<li>绑定 <strong>源站</strong>（OSS &#x2F; 服务器）</li>
<li>配置 <strong>缓存规则</strong></li>
<li>获取 <strong>CDN 访问地址</strong>（如 <code>https://cdn.yourgame.com/assets</code>）</li>
</ul>
<h4 id="4-Unity-下载资源"><a href="#4-Unity-下载资源" class="headerlink" title="(4) Unity 下载资源"></a><strong>(4) Unity 下载资源</strong></h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> cdnUrl = <span class="string">&quot;https://cdn.yourgame.com/assets/update.ab&quot;</span>;</span><br><span class="line">UnityWebRequest request = UnityWebRequest.Get(cdnUrl);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🌍-3-确保外界能访问"><a href="#🌍-3-确保外界能访问" class="headerlink" title="🌍 3. 确保外界能访问"></a><strong>🌍 3. 确保外界能访问</strong></h3><h4 id="🔹-方案-1：端口转发"><a href="#🔹-方案-1：端口转发" class="headerlink" title="🔹 方案 1：端口转发"></a><strong>🔹 方案 1：端口转发</strong></h4><p>适用于 <strong>本地服务器 &#x2F; 内网穿透</strong></p>
<ol>
<li>登录路由器管理页面（<code>192.168.1.1</code>）。</li>
<li>进入 <strong>端口转发（Port Forwarding）</strong>。</li>
<li>配置 <strong>80 端口</strong>转发到本地服务器 IP（<code>192.168.1.100</code>）。</li>
<li>访问 <code>http://公网IP:80/game-assets/update.ab</code>。</li>
</ol>
<hr>
<h4 id="🔹-方案-2：动态域名（DDNS）"><a href="#🔹-方案-2：动态域名（DDNS）" class="headerlink" title="🔹 方案 2：动态域名（DDNS）"></a><strong>🔹 方案 2：动态域名（DDNS）</strong></h4><p>如果你的公网 IP 不是固定的，可以用 <strong>DDNS</strong>：</p>
<ol>
<li><strong>注册 No-IP &#x2F; 花生壳</strong>。</li>
<li><strong>在路由器上配置 DDNS</strong>，绑定公网 IP。</li>
<li>访问 <code>http://yourname.ddns.net/game-assets/update.ab</code>。</li>
</ol>
<hr>
<h4 id="🔹-方案-3：内网穿透（FRP）"><a href="#🔹-方案-3：内网穿透（FRP）" class="headerlink" title="🔹 方案 3：内网穿透（FRP）"></a><strong>🔹 方案 3：内网穿透（FRP）</strong></h4><p>如果你无法控制路由器，可以用 <strong>FRP</strong>：</p>
<ol>
<li><strong>搭建 FRP 服务器</strong></li>
<li><strong>在本地运行 FRP 客户端</strong></li>
<li>让外网访问 <code>http://your-frp-domain.com/game-assets/update.ab</code>。</li>
</ol>
<hr>
<h3 id="🔥-4-Unity-资源热更新"><a href="#🔥-4-Unity-资源热更新" class="headerlink" title="🔥 4. Unity 资源热更新"></a><strong>🔥 4. Unity 资源热更新</strong></h3><p>在 <strong>HybridCLR + UnityGameFramework（UGF）</strong> 组合中：</p>
<ol>
<li><strong>C# 热更 DLL</strong> 存放在 <code>hotfix/</code> 目录。</li>
<li><strong>AssetBundle 资源</strong> 存放在 <code>assets/</code> 目录。</li>
<li><strong>UnityGameFramework 资源服务器配置</strong>：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">GameEntry.Resource.UpdatePrefixUri = <span class="string">&quot;http://your-server.com/assets/&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>下载资源 &amp; 加载</strong>：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">LoadAssetBundle</span>(<span class="params"><span class="built_in">string</span> url</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    UnityWebRequest request = UnityWebRequestAssetBundle.GetAssetBundle(url);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> request.SendWebRequest();</span><br><span class="line">    <span class="keyword">if</span> (request.result == UnityWebRequest.Result.Success)</span><br><span class="line">    &#123;</span><br><span class="line">        AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);</span><br><span class="line">        Debug.Log(<span class="string">&quot;资源加载成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>HybridCLR 加载热更 DLL</strong>：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Assembly assembly = Assembly.Load(File.ReadAllBytes(<span class="string">&quot;hotfix/Hotfix.dll&quot;</span>));</span><br><span class="line">Type type = assembly.GetType(<span class="string">&quot;Hotfix.Main&quot;</span>);</span><br><span class="line">MethodInfo method = type.GetMethod(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line">method.Invoke(<span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a><strong>✅ 总结</strong></h2><table>
<thead>
<tr>
<th>方案</th>
<th>适用场景</th>
<th>访问方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Nginx &#x2F; Apache</strong></td>
<td>云服务器 &#x2F; 内网</td>
<td>HTTP</td>
</tr>
<tr>
<td><strong>FTP 服务器</strong></td>
<td>内网 &#x2F; 文件传输</td>
<td>FTP</td>
</tr>
<tr>
<td><strong>HFS</strong></td>
<td>快速测试</td>
<td>HTTP</td>
</tr>
<tr>
<td><strong>CDN</strong></td>
<td>大型游戏</td>
<td>HTTPS</td>
</tr>
<tr>
<td><strong>内网穿透</strong></td>
<td>没有公网 IP</td>
<td>FRP &#x2F; DDNS</td>
</tr>
</tbody></table>
<p>如果你的游戏需要频繁更新，推荐 <strong>Nginx + CDN 方案</strong>，确保资源下载快、稳定！🚀</p>
<h1 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h1><p>是的，<strong>Clash for Windows</strong> 可能会影响 Unity 的 <code>UnityWebRequest</code>，导致 <strong>502 Bad Gateway</strong> 错误。原因如下：  </p>
<ol>
<li><p><strong>代理干扰 Unity 请求</strong>  </p>
<ul>
<li>Clash 可能会对 Unity 的网络请求进行代理，而某些 Unity 服务器或 API 可能不支持代理访问。</li>
</ul>
</li>
<li><p><strong>局域网 (LAN) 代理设置问题</strong>  </p>
<ul>
<li>Clash 通常会修改 <strong>Windows 代理设置</strong>，使网络流量通过本地代理（例如 <code>127.0.0.1:7890</code>）。如果 Unity <strong>未正确识别</strong> 代理或代理连接异常，就可能导致 <code>502</code> 错误。</li>
</ul>
</li>
<li><p><strong>进程代理模式影响</strong>  </p>
<ul>
<li>Clash 有 <strong>“系统代理”</strong> 和 <strong>“进程代理”</strong> 模式，如果 Unity 走了 Clash 代理，可能会导致连接问题。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h3><h4 id="方法-1：关闭-Clash-代理"><a href="#方法-1：关闭-Clash-代理" class="headerlink" title="方法 1：关闭 Clash 代理"></a><strong>方法 1：关闭 Clash 代理</strong></h4><ul>
<li>直接<strong>退出 Clash for Windows</strong>，然后重新启动 Unity，测试是否正常。</li>
</ul>
<h4 id="方法-2：排除-Unity-进程不走代理"><a href="#方法-2：排除-Unity-进程不走代理" class="headerlink" title="方法 2：排除 Unity 进程不走代理"></a><strong>方法 2：排除 Unity 进程不走代理</strong></h4><ul>
<li>打开 <strong>Clash for Windows</strong>，进入 <strong>“Proxies”</strong> 页面。</li>
<li>确保 <strong>Unity</strong> 进程没有走 Clash 代理（如使用 <strong>规则模式</strong>，可检查 <code>bypass</code> 规则）。</li>
</ul>
<h4 id="方法-3：关闭-Windows-系统代理"><a href="#方法-3：关闭-Windows-系统代理" class="headerlink" title="方法 3：关闭 Windows 系统代理"></a><strong>方法 3：关闭 Windows 系统代理</strong></h4><ul>
<li><strong>Windows 11 代理设置：</strong>  <ol>
<li><code>Win + I</code> 打开 <strong>设置</strong>，选择 <strong>“网络和 Internet” → “代理”</strong>。  </li>
<li>在 <strong>手动代理</strong> 中，<strong>关闭</strong> 代理服务器。  </li>
<li>在 <strong>自动代理设置</strong>，关闭 <strong>自动检测设置</strong>。  </li>
<li>关闭 Clash 并重启 Unity 测试。</li>
</ol>
</li>
</ul>
<h4 id="方法-4：改为-“直连”-模式"><a href="#方法-4：改为-“直连”-模式" class="headerlink" title="方法 4：改为 “直连” 模式"></a><strong>方法 4：改为 “直连” 模式</strong></h4><ul>
<li><strong>Clash for Windows → 选择 “Direct” 模式</strong>，这样所有流量不会经过代理。这里推荐使用 <strong>rule</strong>模式。</li>
</ul>
<hr>
<p><strong>总结</strong><br><strong>如果关闭 Clash 后 Unity 可以正常请求网络，那问题就是 Clash 代理影响了 Unity 的请求。</strong><br>你可以尝试 <strong>关闭 Clash 或者排除 Unity 进程不走代理</strong> 来解决问题。</p>
]]></content>
  </entry>
  <entry>
    <title>登录流程</title>
    <url>/2025/06/03/%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LoginWithProcess()</span><br><span class="line">└── LoginWithToken()</span><br><span class="line">    └── LoadPlayerWithPropType()</span><br><span class="line">        └── RegToPublisher()</span><br><span class="line">            └── ParallelRequest()   ← 当前方法</span><br><span class="line">                ├── 新手签到</span><br><span class="line">                ├── CV锁状态</span><br><span class="line">                ├── 排行榜数据</span><br><span class="line">                ├── 邀请代理信息</span><br><span class="line">                ├── IP分析</span><br><span class="line">                ├── 新手任务</span><br><span class="line">                └── 其他游戏数据</span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">LoginDefine.LoginType = &#123;</span><br><span class="line">	Common = <span class="number">1</span>,<span class="comment">--正常登陆</span></span><br><span class="line">	Logout = <span class="number">2</span>,<span class="comment">--登出登陆</span></span><br><span class="line">	Reconnect = <span class="number">3</span>,<span class="comment">--重连</span></span><br><span class="line">	AutoFacebook = <span class="number">4</span>,<span class="comment">--fb自动登录，在游戏内返回登陆页面</span></span><br><span class="line">	AutoLine = <span class="number">5</span>,<span class="comment">--废弃</span></span><br><span class="line">	Kickedout = <span class="number">6</span><span class="comment">--被挤下线</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LoginDefine.LoginWay = &#123;</span><br><span class="line">	Guest = <span class="number">1</span>,</span><br><span class="line">	Facebook = <span class="number">2</span>,</span><br><span class="line">	Line = <span class="number">3</span>,<span class="comment">--废弃</span></span><br><span class="line">	OPPO = <span class="number">4</span><span class="comment">--废弃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://mermaid-live.nodejs.cn/edit#pako:eNpVU39P2zAQ_SonS0NMoukP2pBGAwQtAybEJsY0bQRNbnJNPJw4sp2Vru1339lpYeQv-3Lv3rv3khVLVYYsZnOpFmnBtYX7aVIBPWcPN4pnosrh290NzLmQmAXwHSHlFVi9BKtgLvJGI6jGwqJYBo_Q6Zysp-hmwqevn2_XcL7_RSI3hCowfQJb0ElVRkl0eIPoS64XeJUBaq00ZGiJzgTvWyXnbixMVtfmtTlVWmNqTzdty8Qz_0CzhumOcSIFMRaoPdUdF1Qj6cKYBkFUkAtbNLPgw0x3T66rVDZ-Wccw0-oJK5CienKNrtSifC8shJRgasQMmtq_nYvnndhWya1aw8VqKjIwqkRVbaEGacelaggkjJ-_W-DidYGPD2fGO1W2FhHEg1uc86-sJVr0-Mf_4Y710rO63lTVy63iNzCKc8d66Z3d-vamlLBbBfF-wtZwtX9PaTdm5869KJGoyVU-c_ZcCWOV3lLNtSrB8NKbuDCovZTGkFe0TKqR2zbyTPBc83JnW-rDmkKhcQ4JK6ytTdztbjMi7d0SdclF1vltXo5S_MEOZoLouz4g061wccqNEXmFaI73JJ-hNMezJt-zSPsTu7v80lgrbYMy27PCSjw-94m_G_ScpwkjBe334qcmjB2wXIuMxVY3eMC2_PTbrJz6hLmwqC2mY8Y1DUiqDWFqXv1UqtzBtGrygsVzLg3dmjojNdPWhpcWShv1RDWVZfFhGPkZLF6xZ7pGo2A86EXDYTgeHEWHowO2ZPFgEPSGR_1oMOyFh6MhlTcH7K9n7Qf9qD8Ko-goHIfjYRiFm39YsUmx">mermaid在线编辑器</a></p>
<hr>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><pre><code class="highlight mermaid">sequenceDiagram
  participant 玩家
  participant 客户端
  participant 服务器
  玩家--&gt;&gt;客户端: 选择游客登陆
  客户端-&gt;&gt;玩家: 成功回调

  loop 递归
      玩家-&gt;&gt;玩家: 接收消息
  end
  Note right of 玩家: 输入密码 &lt;br/&gt;长连接...</code></pre>


<hr>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><blockquote>
<p>login</p>
</blockquote>
<pre><code class="highlight mermaid">graph TD
    subgraph 登录模块
        子游戏接口--&gt;z
        z[登出]--&gt;V
        引导--&gt;z
        设置退出账号--&gt;z
        子游戏接口--&gt;被踢
        大厅推送--&gt;被踢--&gt;V
        大厅--&gt;W[重连]
        游戏--&gt;W
        重连失败--&gt;W
        当服务器连接断开--&gt;W
        W--&gt;V
        FB绑定奖励领取回调--&gt;游戏内跳转FB登陆--&gt;V
        注销--&gt;z
        服务器返回错误码--&gt;z
        ViewManager.CommonEnterMainScene--&gt;LoginViewCtr:OnCreate --&gt; LoginViewCtr:OnOpenSocket--&gt;CC.Network.Start--&gt;
        LoginViewCtr:OnSocketConnect--&gt; LoginViewCtr:ReadyToEnter
        V[ViewManager.BackToLogin,从当前界面（如大厅或游戏）返回到登录界面，清理相关状态和资源]--&gt;LoginViewCtr:OnCreate
    end

    subgraph 登录模块2
        A(玩家登录) --&gt; B1&#123;存在登录方式&#125;
        B1 --&gt;|❌| B2[玩家选择登录方式]
        B2 --&gt; B[ID登录]
        B2 --&gt; C[游客登录]--&gt;a3[LoginWithProcess]
        B2 --&gt; D[FB登录]
        B --&gt; F[RoyalLoginView] --&gt; G[Login] --&gt; OnAccountLogin--&gt;C
        D --&gt; |FB sdk 
        成功回调、
        失败回调注册|H[CC.FacebookPlugin.LogIn] --&gt; K&#123;成功登录FB&#125; --&gt; |✅|J[请求 FacebookLogin] --&gt;
        a1&#123;成功登录游戏&#125; --&gt; a2[保存玩家登录数据，向第三方分析平台发送注册事件，埋点统计、次日留存、本地缓存注册和新玩状态]--&gt;
        a3--&gt;|请求|a4[LoginWithToken]--&gt;
        a5&#123;请求回调&#125;--&gt;|✅|a6[保存玩家设备id,登录方式]--&gt;
        a7&#123;请求加载玩家的特定属性数据（如财富、称号、统计信息等），用于初始化玩家在游戏中的基础状态&#125;--&gt;
        |✅|a8[保存玩家个人信息]--&gt;
        a9&#123;将玩家的登录信息注册到游戏发布平台（如 Google Play、App Store 等），用于后续平台相关的功能验证或服务调用。&#125;--&gt;
        |✅|b1[存储成功发布状态]--&gt;|并行请求业务数据|b2[ParallelRequest]--&gt;b3[获取新手签到状态:如是否开启新手签到
        获取 CV 锁定状态:用于控制某些功能的解锁条件
        获取金币排行榜数据
        获取每日赢取排行榜数据
        获取大奖回放周榜数据
        获取新玩家标志:判断是否是新手玩家
        加载玩家的游戏相关数据:如上次登录信息等
        获取邀请代理相关信息
        分析玩家 IP 地址信息:可能用于风控或地区统计
        获取新手任务信息]--&gt;LoginViewCtr:Update --&gt;|percent &gt;= 100|LoginViewCtr:EnterGame
        LoginViewCtr:Update--&gt;LoginView:RefreshUI--&gt;loadingNode,进度及按钮的展示
        D--&gt;Request.FacebookLogin--&gt;LoginWithProcess
        C--&gt;Request.Login--&gt;LoginWithProcess

        subgraph 共同请求模块
            LoginWithProcess--&gt;Request.LoginWithToken--&gt;Request.ReqLoadPlayerWithPropType--&gt;Request.RegToPublisher--&gt;ParallelRequest--&gt;b3
        end
        
    end

   subgraph 新登录流程
        OnFacebookLogin--&gt;NewFacebookLogin--&gt;GetLoginProcess--&gt; FacebookLogin:InitData--&gt;LoginProcess:CommonReq
        --&gt;CC.Request:NewLogin--&gt;LoginProcess:OnLoginResponse--&gt;ProcessingFacebookLoginTokenInfoData
        --&gt;OnNewLoginSuc--&gt;ProcessingLoginWithToken
        
        subgraph 合并请求回复的数据
            ProcessingLoginWithToken--&gt;ProcessingLoadPlayerWithPropType--&gt;ProcessingReqNewPlayerSignStatus
            --&gt;ProcessingGetNewPlayerFlag--&gt;ProcessingReqLoadPlayerGameInfo
        end

        ProcessingReqLoadPlayerGameInfo--&gt;RegToPublisher--&gt;并行请求数据



        OnGuestLogin--&gt;NewGuestLogin--&gt;GetLoginProcess--&gt;GuestLogin:InitData--&gt;LoginProcess:CommonReq
        LoginProcess:OnLoginResponse--&gt;ProcessingGuestLoginTokenInfoData--&gt;OnNewLoginSuc

        ReadyToEnter--&gt;|Guest|NewAccountLogin
        ReadyToEnter--&gt;|RoyalLogin|NewAccountLogin
        oa[OnAccountLogin]--&gt;NewAccountLogin--&gt;GetLoginProcess--&gt;RoyalLogin:InitData--&gt;LoginProcess:CommonReq
        LoginProcess:OnLoginResponse--&gt;ProcessingAccountLoginTokenInfoData--&gt;OnNewLoginSuc
    
        subgraph 各登录方式请求所需的数据
            FacebookLogin:InitData
            GuestLogin:InitData
            RoyalLogin:InitData
        end

        subgraph 各登录方式请求的成功回调
            ProcessingAccountLoginTokenInfoData
            ProcessingGuestLoginTokenInfoData
            ProcessingFacebookLoginTokenInfoData
        end

      
    
    end
    



</code></pre>
<pre><code class="highlight mermaid">graph TD
    subgraph 登录模块
        子游戏接口--&gt;z
        z[登出]--&gt;V
        引导--&gt;z
        设置退出账号--&gt;z
        子游戏接口--&gt;被踢
        大厅推送--&gt;被踢--&gt;V
        大厅--&gt;W[重连]
        游戏--&gt;W
        重连失败--&gt;W
        当服务器连接断开--&gt;W
        W--&gt;V
        FB绑定奖励领取回调--&gt;游戏内跳转FB登陆--&gt;V
        注销--&gt;z
        服务器返回错误码--&gt;z
        ViewManager.CommonEnterMainScene--&gt;LoginViewCtr:OnCreate --&gt; LoginViewCtr:OnOpenSocket--&gt;CC.Network.Start--&gt;
        LoginViewCtr:OnSocketConnect
        --&gt; LoginViewCtr:ReadyToEnter
        V[ViewManager.BackToLogin,从当前界面（如大厅或游戏）返回到登录界面，清理相关状态和资源]--&gt;LoginViewCtr:OnCreate
    end

    subgraph 登录模块2
        A(玩家登录) --&gt; B1&#123;存在登录方式&#125;
        B1 --&gt;|❌| B2[玩家选择登录方式]
        B2 --&gt; B[ID登录]
        B2 --&gt; C[游客登录]--&gt;a3[LoginWithProcess]
        B2 --&gt; D[FB登录]
        B --&gt; F[RoyalLoginView] --&gt; G[Login] --&gt; OnAccountLogin--&gt;C
        D --&gt; |FB sdk 
        成功回调、
        失败回调注册|H[CC.FacebookPlugin.LogIn] --&gt; K&#123;成功登录FB&#125; --&gt; |✅|J[请求 FacebookLogin] --&gt;
        a1&#123;成功登录游戏&#125; --&gt; a2[保存玩家登录数据，向第三方分析平台发送注册事件，埋点统计、次日留存、本地缓存注册和新玩状态]--&gt;
        a3--&gt;|请求|a4[LoginWithToken]--&gt;
        a5&#123;请求回调&#125;--&gt;|✅|a6[保存玩家设备id,登录方式]--&gt;
        a7&#123;请求加载玩家的特定属性数据（如财富、称号、统计信息等），用于初始化玩家在游戏中的基础状态&#125;--&gt;
        |✅|a8[保存玩家个人信息]--&gt;
        a9&#123;将玩家的登录信息注册到游戏发布平台（如 Google Play、App Store 等），用于后续平台相关的功能验证或服务调用。&#125;--&gt;
        |✅|b1[存储成功发布状态]--&gt;|并行请求业务数据|b2[ParallelRequest]--&gt;b3[获取新手签到状态:如是否开启新手签到
        获取 CV 锁定状态:用于控制某些功能的解锁条件
        获取金币排行榜数据
        获取每日赢取排行榜数据
        获取大奖回放周榜数据
        获取新玩家标志:判断是否是新手玩家
        加载玩家的游戏相关数据:如上次登录信息等
        获取邀请代理相关信息
        分析玩家 IP 地址信息:可能用于风控或地区统计
        获取新手任务信息]--&gt;LoginViewCtr:Update --&gt;|percent &gt;= 100|LoginViewCtr:EnterGame
        LoginViewCtr:Update--&gt;LoginView:RefreshUI--&gt;loadingNode,进度及按钮的展示
    end</code></pre>
<blockquote>
<p>loading</p>
</blockquote>
<pre><code class="highlight mermaid">
graph TD
    subgraph 登录模块
        z[登出]--&gt;V
        引导--&gt;z
        设置退出账号--&gt;z
        子游戏接口--&gt;被踢
        大厅推送--&gt;被踢--&gt;V
        大厅--&gt;W[重连]
        游戏--&gt;W
        重连失败--&gt;W
        当服务器连接断开--&gt;W
        W--&gt;V
        FB绑定奖励领取回调--&gt;游戏内跳转FB登陆--&gt;V
        注销--&gt;z
        服务器返回错误码--&gt;z
        子游戏接口--&gt;z
    end

    subgraph 加载模块
    
        CC.Notifications.ReqGameListAndGameVersionFinish--&gt;aaa[LoadingView:CheckUpdate]--&gt;LoadingView:StartUpdate--&gt;ch[ResDownloadManager.CheckHall检查大厅资源热更]--&gt;
        |debug|zz[ResDownloadManager.EnterLogin]--&gt;
        LoadingView:Update--&gt;|加载完成|LoadingView:EnterGame--&gt;ViewManager.CommonEnterMainScene
        ch--&gt;|非debug|bv[bigVersion &gt; localBigVersion判断]--&gt;|大于|aa[ResDownloadManager.BigVersionHandle]--&gt;
        SafeQuit--&gt;|编辑器|zz
        SafeQuit--&gt;|非编辑器|Application.Quit
        bv--&gt;|等于|az[指定版本检查]
        az--&gt;|等于|ResDownloadManager.BigVersionHandle--&gt;hhf[ResDownloadManager.HallHotFix]
        az--&gt;|不等于|hhf--&gt;hotResVersion判断--&gt;|要热更|ViewManager.CommonEnterMainScene
        bv--&gt;|小于|zz
        hotResVersion判断--&gt;|不热更|zz
    end

    ViewManager.CommonEnterMainScene--&gt;LoginViewCtr:OnCreate --&gt; LoginViewCtr:OnOpenSocket--&gt;CC.Network.Start--&gt;
    LoginViewCtr:OnSocketConnect
    --&gt; LoginViewCtr:ReadyToEnter
    V[ViewManager.BackToLogin,从当前界面（如大厅或游戏）返回到登录界面，清理相关状态和资源]--&gt;LoginViewCtr:OnCreate</code></pre>
<blockquote>
<p>推荐下面的方式:在<a href="https://mermaid-live.nodejs.cn/edit#pako:eNpVU39P2zAQ_SonS0NMatOkaQuNBghaxg8xNjGmaSNocpNr4uHYke2sdG2_-2ynhZG_nMu9e-_ei1ckkzmShMy5XGQlVQbup6kA-5w-3EiaM1HAt7sbmFPGMQ_gO0JGBRi1BCNhzopGIcjGwKJcBo_Q7R6vp-hmwvXXz7drONv_wpFqiyoxewJT2pMUWnJ0eI3oS64XqMgBlZIKcjSWTgfvWyVnbixMVlf6tTmTSmFmTjZty8Qz_0C9humOccKZZSxReao7ymzNSmdaNwhMQMFM2cyCDzPVO74SGW_8so5hpuQTCuBMPLlGV2pRvhcWjHPQNWIOTe2_ztnzTmyr5Fau4Xw1ZTloWaEUW6hGu-NSNhbEtJ-_W-D8dYGPD6faO1W1FlmIB7c4519VczTo8Y__wx3rhWd1vZmsl1vFb2A2zh3rhXd269ubUkpuJST7KVnD5f69TbvRO3fuWYWW2rpKZ86eS6aNVFuquZIVaFp5ExcalZfSaOuVXSZTSE0bec5ooWi1sy3zYU2hVDiHlJTG1Drp9bYZWe29ClVFWd79rV-OnP3BLubM0vd8QLoncHFCtWaFQNRHe5zOkOujWVPsGbT7W3b38kthLZUJqnzPMMPx6Mwn_q4fOk9TYhW0_4ufmhLSIYViOUnmlGvskK0Ae29WTn5KXFq2L7HHnCo7IRUbC6qp-CllRRKjGgtTsinKlyFNnVs509aHlxYbN6qJbIQhydhPIMmKPJOkG4WDID4YRFF_MBwdxKNhhyxJEg2HwSg-HI8H42g0iML-waZD_nrSMBhH4zgKwziO-1F8GI46pHXrU3vp_d3f_ANXSlAf">Mermaid 在线编辑器</a>绘制图标，完成后点击下方的【复制 Markdown】，将链接粘贴到md文档就可以预览，点击图表也能跳转到Mermaid继续编辑，并且Mermaid可以点击【分享Kroki】来全屏预览。不过为了确保数据不会丢失最好在文档中记录一份。Mermaid还可以团队协助一起编辑，这个要使用<a href="https://mermaid.live/edit#pako:eNpdjstOwzAQRX_FuiuQkiiP5uUFUtPsWcAKzMJKnIdo7Mh1RCHKv-NaqoLwyjPnnplZ0ahWgML3fSYbJbuxp0wS98wgJkGJFu1yZdIlurP6agauDXmt7zFCjg_vDC_Gthk-Hv_0ie8_kWplqEUzXkYlGbYdVw6frPs8GwvJ0er_cb3jymF46PXYghq9CA-T0BO_lVhvKoO7moHab8v1JwOTm3VmLt-Umu6aVks_gHb8fLHVMrfciHrkveZ7RMhW6JNapAGNEjcCdMUVNImz4BBlcRQWaVSGRebhGzRNg0OSp3FRlnGYx2W-efhxO8OgyNPtF0tIahg">国际版</a>国际版还支持Playground-more featureS, no account required，点击【Playground】可以直接鼠标创建完成绘制图标像xmind一样，不用手敲语法，并且自带全屏预览效果，不用分享Kroki。</p>
</blockquote>
<p><a href="https://mermaid-live.nodejs.cn/edit#pako:eNp9lN9P01AUx_-V5j4Psq7bYE00ICSGBxOjPGl9KPTCFrd2absobEvmCFBgvwiOGUWUhClRXCD-KuvY_hh6b7un_Qve9srEgPap59xzzvdzvs1tFswrEgQ8WFTFdJyZnRZkQWbI4xwf22bBNj-hahHXT0ZGbqOzHtrexO0aec-hw1P3WzPXXy075y38dqW_Xr6atl65rUP2z6R26a9JtZJzaqH9Ldt8SXvxXgEdfvQm4MZ7eoxNExvVHC5t4MqRW67RQveg6f74ek0qdAV646qU26u5tSbFvFmNVlCNm9VC1-S4S5cmJ7KMFhfTkGfmVHEeagEmKc7BJM8IAFUsMkIATN6rpvV3_lM_I2u6mEwyD-ACVFWoMpP3Z9zKT1TdpdqCTNdwD46cTpvksLGLOkVkmoJMofsFy-1uu90zp17CK6to7fugY6APxUUxBRMS2RXXjYvCi6H91GJiVH-9aptlsuqgs3EJ7OEuP8aNJuo10Lstp3g26Lzu7xXc1gk6r98ES02nyFQeVTcpGTIaHra1g_f3Bp2S3e3Z7QqqVRzrC2nB5RYy1vB-7aJQfPLbrKmJ7L-Momx3yVKzS2lIqvWHSUXXmFsMG_CiqTjUvCjkR7PKM6hOE0xZgyTJCcBfjwja7c_9nS6uNP3v68PnkPEGWe1hmi5DQxAglyQhAX5BTGowAFJQTYleDLIekQD0OExBAXiIkqg-9UDzpCktyo8UJQV4Xc2QNlXJLMaHQzJpSdThdEIk9y81zKpQlqA6pWRkHfAhNjruTwF8FjwH_AgbDI9yY2GWDYUj0TEuGgmAJcCzkcholBuPxcIxNhpmg6GxfAAs-8LB0Rgb49hgkOO4EMuNB0kHlBK6ot6jl9__B-R_AQXhABI"><img src="https://mermaid.ink/img/pako:eNp9lN9P01AUx_-V5j4Psq7bYE00ICSGBxOjPGl9KPTCFrd2absobEvmCFBgvwiOGUWUhClRXCD-KuvY_hh6b7un_Qve9srEgPap59xzzvdzvs1tFswrEgQ8WFTFdJyZnRZkQWbI4xwf22bBNj-hahHXT0ZGbqOzHtrexO0aec-hw1P3WzPXXy075y38dqW_Xr6atl65rUP2z6R26a9JtZJzaqH9Ldt8SXvxXgEdfvQm4MZ7eoxNExvVHC5t4MqRW67RQveg6f74ek0qdAV646qU26u5tSbFvFmNVlCNm9VC1-S4S5cmJ7KMFhfTkGfmVHEeagEmKc7BJM8IAFUsMkIATN6rpvV3_lM_I2u6mEwyD-ACVFWoMpP3Z9zKT1TdpdqCTNdwD46cTpvksLGLOkVkmoJMofsFy-1uu90zp17CK6to7fugY6APxUUxBRMS2RXXjYvCi6H91GJiVH-9aptlsuqgs3EJ7OEuP8aNJuo10Lstp3g26Lzu7xXc1gk6r98ES02nyFQeVTcpGTIaHra1g_f3Bp2S3e3Z7QqqVRzrC2nB5RYy1vB-7aJQfPLbrKmJ7L-Momx3yVKzS2lIqvWHSUXXmFsMG_CiqTjUvCjkR7PKM6hOE0xZgyTJCcBfjwja7c_9nS6uNP3v68PnkPEGWe1hmi5DQxAglyQhAX5BTGowAFJQTYleDLIekQD0OExBAXiIkqg-9UDzpCktyo8UJQV4Xc2QNlXJLMaHQzJpSdThdEIk9y81zKpQlqA6pWRkHfAhNjruTwF8FjwH_AgbDI9yY2GWDYUj0TEuGgmAJcCzkcholBuPxcIxNhpmg6GxfAAs-8LB0Rgb49hgkOO4EMuNB0kHlBK6ot6jl9__B-R_AQXhABI?type=png"></a></p>
<p><a href="https://mermaid-live.nodejs.cn/edit#pako:eNqNVVtTGkkU_ivUPCOFIBh5SFXEuD7oplZdUxXwoZlpYQroZochJohVuImKFoLZVVLEaBKjxqqNl5TuhlLI_hl7Lk_5C9s9zTKDmkp4Gs75zne-PpfuOUHEEhRCQlwBmYRrciiKXPSXzcW4Qa9fktamdviObL_kLvbLR5h9-WK6p-fulG0mzU1y0qS2vG0zjr_orWOzWKRw4_yAVD93-8nRutZoaKWqVtkn1ffUaez-ZTR2HYi9D6SyqFUOzeJCx30tsQWhtocRc3nN-Hdn2vZxduazbRxE9j4Z5_vdHtL6U3u9RlbfkfohhVBRWu2INIvdqIfd6YcH9csX5PgV2a-R1U_m7hKp1sjWjnH6jOJ4frK0aHw-M1ofKbZ-adaXuhm0s0Nzo9hdGYeODcpmbtSNkxP97cL36td2QiRF0bVuktW3Rqvl7KZNFA57fsaqPCOLQJUxynrG4W8_gTQclbPqPSSxzymoZKlrWEZyNkEzAQAioxhIMopPyXA2FE5AMflrRgIqZJPhdE2oQFG5i3rERGQcZofwLEpRzBhAIA4VjxU-AlIp7X1Re7PPm2r8_Vy7WNefHWlb54zUFlyQYCwXL-Tzt3HdRypURnFcRt1BTk0dOQVeF3Jc1krrBSfEomFHZ-2iho5UnE5jZHnHgIwmRIignURkxSmY2ztcYexxJCbH28Vz3XWlsAhSgx0LKe3RGZu2dOx9uLqoFGhZbzmSHTECkJSC3QebADPwl5ysMhq9WTO-vKCTQ4tzO4Jqs0H3MplUu-seBrBDYo8tuqMVS1U-opWX6ZjrKyXt9UfeJMeigbwD_AP6KTqRmLntpGwGRrA6LD-5QX_VWGtnoLGMAauUoKuSDGYcLPCRKfx41_hhyWmVsTsL940cTArPkb-5ct9La60HnU6GC6tK6AEKK5BOo4s6XNc8DzIQTWAxCVnr2JpCdRYrSY-1U50huBbEA8IYISi2O3qDehwC6ekktpS1ZUecwgeBmJzEVoj76rJC70aysqZvls3t3a_NEjn4vX01l2r8CvraXOF3FSmd8ofjf3BZayzq60v6VoMsnumr_2jFBfJHme_29LdqwSUJbvo2yZIQmgGpLHQLaaikAfsvzDFAVFATMA2jQoh-SkBJRoUomqdBGYAeYZwWQqqSo2EKzsUTHZKctfpDMqD3og2h_YNKGOeQKoQCFoMQmhOeCKEev9_j8_r7fH3eXl8g6OsPuoWn1Oy7E_Tc8Qd7vYGAt8_v7fPNu4W8lbTXExwI9g70B7wD_UEaQemgJKtYGePPrfXqzv8H_SEXcw"><img src="https://mermaid.ink/img/pako:eNqNVVtTGkkU_ivUPCOFIBh5SFXEuD7oplZdUxXwoZlpYQroZochJohVuImKFoLZVVLEaBKjxqqNl5TuhlLI_hl7Lk_5C9s9zTKDmkp4Gs75zne-PpfuOUHEEhRCQlwBmYRrciiKXPSXzcW4Qa9fktamdviObL_kLvbLR5h9-WK6p-fulG0mzU1y0qS2vG0zjr_orWOzWKRw4_yAVD93-8nRutZoaKWqVtkn1ffUaez-ZTR2HYi9D6SyqFUOzeJCx30tsQWhtocRc3nN-Hdn2vZxduazbRxE9j4Z5_vdHtL6U3u9RlbfkfohhVBRWu2INIvdqIfd6YcH9csX5PgV2a-R1U_m7hKp1sjWjnH6jOJ4frK0aHw-M1ofKbZ-adaXuhm0s0Nzo9hdGYeODcpmbtSNkxP97cL36td2QiRF0bVuktW3Rqvl7KZNFA57fsaqPCOLQJUxynrG4W8_gTQclbPqPSSxzymoZKlrWEZyNkEzAQAioxhIMopPyXA2FE5AMflrRgIqZJPhdE2oQFG5i3rERGQcZofwLEpRzBhAIA4VjxU-AlIp7X1Re7PPm2r8_Vy7WNefHWlb54zUFlyQYCwXL-Tzt3HdRypURnFcRt1BTk0dOQVeF3Jc1krrBSfEomFHZ-2iho5UnE5jZHnHgIwmRIignURkxSmY2ztcYexxJCbH28Vz3XWlsAhSgx0LKe3RGZu2dOx9uLqoFGhZbzmSHTECkJSC3QebADPwl5ysMhq9WTO-vKCTQ4tzO4Jqs0H3MplUu-seBrBDYo8tuqMVS1U-opWX6ZjrKyXt9UfeJMeigbwD_AP6KTqRmLntpGwGRrA6LD-5QX_VWGtnoLGMAauUoKuSDGYcLPCRKfx41_hhyWmVsTsL940cTArPkb-5ct9La60HnU6GC6tK6AEKK5BOo4s6XNc8DzIQTWAxCVnr2JpCdRYrSY-1U50huBbEA8IYISi2O3qDehwC6ekktpS1ZUecwgeBmJzEVoj76rJC70aysqZvls3t3a_NEjn4vX01l2r8CvraXOF3FSmd8ofjf3BZayzq60v6VoMsnumr_2jFBfJHme_29LdqwSUJbvo2yZIQmgGpLHQLaaikAfsvzDFAVFATMA2jQoh-SkBJRoUomqdBGYAeYZwWQqqSo2EKzsUTHZKctfpDMqD3og2h_YNKGOeQKoQCFoMQmhOeCKEev9_j8_r7fH3eXl8g6OsPuoWn1Oy7E_Tc8Qd7vYGAt8_v7fPNu4W8lbTXExwI9g70B7wD_UEaQemgJKtYGePPrfXqzv8H_SEXcw?type=png"></a></p>
]]></content>
      <categories>
        <category>登录流程,mermaid</category>
      </categories>
      <tags>
        <tag>Markdown,mermaid</tag>
      </tags>
  </entry>
  <entry>
    <title>社保和公积金的补缴问题</title>
    <url>/2025/05/17/%E7%A4%BE%E4%BF%9D%E5%92%8C%E5%85%AC%E7%A7%AF%E9%87%91%E7%9A%84%E8%A1%A5%E7%BC%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>离职后，社保和公积金的补缴问题与个人权益密切相关，以下是需要关注的要点及原因解析：</p>
<hr>
<h2 id="社保和公积金的补缴问题"><a href="#社保和公积金的补缴问题" class="headerlink" title="社保和公积金的补缴问题"></a>社保和公积金的补缴问题</h2><h3 id="一、需要自己补缴的情况"><a href="#一、需要自己补缴的情况" class="headerlink" title="一、需要自己补缴的情况"></a><strong>一、需要自己补缴的情况</strong></h3><ol>
<li><p><strong>社保（养老保险、医疗保险等）</strong>  </p>
<ul>
<li><strong>断缴影响</strong>：社保缴费年限直接影响养老金的领取资格（累计15年）和医保报销（断缴后次月停保）。  </li>
<li><strong>补缴方式</strong>：  <ul>
<li><strong>以灵活就业身份参保</strong>：可单独缴纳养老和医疗（费用全额自付，比例约为当地基数的20%-30%）。  </li>
<li><strong>通过新单位续缴</strong>：离职后尽快入职新单位，由新公司接续缴纳（避免断缴）。  </li>
<li><strong>补缴政策</strong>：部分地区允许补缴断缴部分（需咨询12333社保热线），但可能需支付滞纳金。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>住房公积金</strong>  </p>
<ul>
<li><strong>断缴影响</strong>：影响公积金贷款资格（通常需连续缴存6-12个月）。  </li>
<li><strong>补缴方式</strong>：  <ul>
<li>以灵活就业身份缴存（仅部分城市开放）。  </li>
<li>由新单位续缴，无法个人补缴断缴部分（个别城市允许单位申请补缴）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>企业未足额缴纳</strong>  </p>
<ul>
<li>若原单位未按实际工资缴纳社保，可要求补缴差额（通过劳动仲裁或社保稽核）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="二、为什么要补缴？"><a href="#二、为什么要补缴？" class="headerlink" title="二、为什么要补缴？"></a><strong>二、为什么要补缴？</strong></h3><ol>
<li><p><strong>养老保险</strong>  </p>
<ul>
<li>累计缴费年限不足15年，无法领取养老金；缴费基数越高、年限越长，养老金越多。</li>
</ul>
</li>
<li><p><strong>医疗保险</strong>  </p>
<ul>
<li>断缴期间无法报销医疗费，重新缴费后可能有等待期（如3-6个月）。</li>
</ul>
</li>
<li><p><strong>公积金贷款</strong>  </p>
<ul>
<li>断缴后需重新计算连续缴存时间，可能耽误购房计划。</li>
</ul>
</li>
<li><p><strong>其他权益</strong>  </p>
<ul>
<li>部分城市要求社保连续缴纳年限与落户、子女入学、购车摇号等挂钩。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a><strong>三、注意事项</strong></h3><ol>
<li><strong>灵活就业参保</strong>：比职工社保费用高（原单位部分也需个人承担），但可保留缴费记录。  </li>
<li><strong>跨省转移</strong>：在新就业地参保后，可申请将原社保关系转移合并（养老、医疗年限累计）。  </li>
<li><strong>短期过渡</strong>：若短期内不工作，可缴纳城乡居民医保（费用低，保障较弱）。</li>
</ol>
<hr>
<h3 id="四、建议操作"><a href="#四、建议操作" class="headerlink" title="四、建议操作"></a><strong>四、建议操作</strong></h3><ol>
<li><strong>查询缴费记录</strong>：通过“支付宝-市民中心”或“社保官网”确认断缴月份。  </li>
<li><strong>咨询当地政策</strong>：拨打12333（社保）或12329（公积金），了解补缴规则和截止时间。  </li>
<li><strong>优先保证医保</strong>：医疗断缴风险大，可优先以灵活就业身份缴纳。</li>
</ol>
<p>及时处理社保问题能避免权益受损，尤其计划购房或需医保报销时更需谨慎！</p>
<hr>
<h2 id="退休时社保缴纳年限不足"><a href="#退休时社保缴纳年限不足" class="headerlink" title="退休时社保缴纳年限不足"></a>退休时社保缴纳年限不足</h2><p>退休时社保缴纳年限不足（如养老保险未满15年或医保未达当地要求），可根据不同情况选择补救措施。以下是具体解决方案：</p>
<hr>
<h3 id="一、养老保险年限不足怎么办？"><a href="#一、养老保险年限不足怎么办？" class="headerlink" title="一、养老保险年限不足怎么办？"></a><strong>一、养老保险年限不足怎么办？</strong></h3><h4 id="1-继续延长缴费（首选）"><a href="#1-继续延长缴费（首选）" class="headerlink" title="1. 继续延长缴费（首选）"></a><strong>1. 继续延长缴费（首选）</strong></h4><ul>
<li><strong>条件</strong>：  <ul>
<li>2011年7月前首次参保的，延长缴费5年后仍不足15年，可一次性补缴剩余年限。  </li>
<li>2011年7月后首次参保的，需按月延长缴费至满15年（无法一次性补缴）。</li>
</ul>
</li>
<li><strong>操作</strong>：<br>以灵活就业身份继续缴纳养老保险，直至满15年再办理退休（费用需全额自付）。</li>
</ul>
<h4 id="2-转入城乡居民养老保险"><a href="#2-转入城乡居民养老保险" class="headerlink" title="2. 转入城乡居民养老保险"></a><strong>2. 转入城乡居民养老保险</strong></h4><ul>
<li><strong>适用场景</strong>：若延长缴费经济压力大，可转入城乡居民养老保险（城居保）。  </li>
<li><strong>优缺点</strong>：<br>✅ 允许一次性补缴至15年，次月即可领取养老金。<br>❌ 养老金待遇低于职工养老保险（原职工缴费年限可合并计算）。  </li>
<li><strong>操作</strong>：向当地社保局申请转移衔接。</li>
</ul>
<h4 id="3-退保提取个人账户（不推荐）"><a href="#3-退保提取个人账户（不推荐）" class="headerlink" title="3. 退保提取个人账户（不推荐）"></a><strong>3. 退保提取个人账户（不推荐）</strong></h4><ul>
<li><strong>条件</strong>：仅限未缴满15年且不愿继续缴费的情况。  </li>
<li><strong>后果</strong>：  <ul>
<li>仅退还养老保险个人账户余额（单位缴纳部分不退）。  </li>
<li>失去终身领取养老金的资格。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、医疗保险年限不足怎么办？"><a href="#二、医疗保险年限不足怎么办？" class="headerlink" title="二、医疗保险年限不足怎么办？"></a><strong>二、医疗保险年限不足怎么办？</strong></h3><h4 id="1-一次性补缴"><a href="#1-一次性补缴" class="headerlink" title="1. 一次性补缴"></a><strong>1. 一次性补缴</strong></h4><ul>
<li><strong>规则</strong>：多数地区允许退休时一次性补缴医保差额年限（费用&#x3D;补缴基数×当地比例×年限）。  <ul>
<li>例如：需补缴5年医保，按当前基数8%计算，约需数万元。</li>
</ul>
</li>
<li><strong>优势</strong>：补缴后终身享受医保待遇，无需继续缴费。</li>
</ul>
<h4 id="2-继续按月缴费"><a href="#2-继续按月缴费" class="headerlink" title="2. 继续按月缴费"></a><strong>2. 继续按月缴费</strong></h4><ul>
<li><strong>适用场景</strong>：部分地区不支持一次性补缴，需按月缴纳至规定年限（如上海需15年）。</li>
</ul>
<h4 id="3-转为城乡居民医保"><a href="#3-转为城乡居民医保" class="headerlink" title="3. 转为城乡居民医保"></a><strong>3. 转为城乡居民医保</strong></h4><ul>
<li><strong>选择</strong>：若补缴压力大，可改交城乡居民医保（年缴300-500元）。  </li>
<li><strong>缺点</strong>：  <ul>
<li>需每年缴费，不累计年限；  </li>
<li>报销比例低于职工医保（约50%-70%）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="三、其他注意事项"><a href="#三、其他注意事项" class="headerlink" title="三、其他注意事项"></a><strong>三、其他注意事项</strong></h3><ol>
<li><strong>地域差异</strong>：  <ul>
<li>养老保险全国可转移合并年限，医保需咨询转入地政策（如深圳要求医保缴满25年）。</li>
</ul>
</li>
<li><strong>补缴成本</strong>：  <ul>
<li>养老保险补缴费用&#x3D;补缴基数×20%×年限（灵活就业比例）；  </li>
<li>医保补缴费用通常更高（如北京补1年约需5000-1万元）。</li>
</ul>
</li>
<li><strong>优先顺序</strong>：  <ul>
<li>先补养老保险（保障基本生活），再补医保（避免医疗无保障）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="四、操作建议"><a href="#四、操作建议" class="headerlink" title="四、操作建议"></a><strong>四、操作建议</strong></h3><ol>
<li><strong>查询年限</strong>：<br>携带身份证到社保局打印《缴费清单》，确认养老&#x2F;医保实际缴费年限。  </li>
<li><strong>测算补缴金额</strong>：<br>向社保局提供补缴方案及费用明细（如“延长缴费5年需多少钱”）。  </li>
<li><strong>谨慎选择退保</strong>：<br>退保损失大，仅建议无法负担补缴且无其他收入来源的情况。</li>
</ol>
<hr>
<h3 id="五、案例参考"><a href="#五、案例参考" class="headerlink" title="五、案例参考"></a><strong>五、案例参考</strong></h3><ul>
<li><strong>案例1</strong>：王阿姨职工养老缴了12年（2010年首次参保），可延长缴费3年后一次性补缴。  </li>
<li><strong>案例2</strong>：李叔叔医保差8年，选择按月继续缴至满25年（厦门要求），期间享受医保待遇。</li>
</ul>
<hr>
<p>及时与当地社保局（12333）沟通，选择最适合的方案，避免因年限不足影响退休生活质量！</p>
<h2 id="社保和住房公积金的退费"><a href="#社保和住房公积金的退费" class="headerlink" title="社保和住房公积金的退费"></a>社保和住房公积金的退费</h2><p>关于社保（养老保险、医疗保险等）和住房公积金的退费问题，以下是详细解答，涵盖不同情形下的退费条件、流程及注意事项：</p>
<hr>
<h3 id="一、社保退费（养老保险、医疗保险等）"><a href="#一、社保退费（养老保险、医疗保险等）" class="headerlink" title="一、社保退费（养老保险、医疗保险等）"></a><strong>一、社保退费（养老保险、医疗保险等）</strong></h3><h4 id="1-养老保险退费"><a href="#1-养老保险退费" class="headerlink" title="1. 养老保险退费"></a><strong>1. 养老保险退费</strong></h4><p><strong>可退费情形</strong>：</p>
<ul>
<li><strong>参保人去世</strong>：家属可申请退还养老保险个人账户余额（单位缴纳部分不退），需提供死亡证明、亲属关系证明等。</li>
<li><strong>达到退休年龄但缴费不足15年且不愿补缴</strong>：可申请退还个人账户储存额（仅退个人缴费部分）。</li>
<li><strong>移民或注销国籍</strong>：凭移民证明等材料，可退个人账户余额。</li>
<li><strong>重复参保</strong>：如同时参加职工养老和城乡居民养老，可申请清退重复缴费部分。</li>
</ul>
<p><strong>不可退费情形</strong>：</p>
<ul>
<li>正常参保且未达到退休年龄。</li>
<li>已开始领取养老金。</li>
</ul>
<p><strong>退费损失</strong>：</p>
<ul>
<li>仅退个人账户部分（约缴费总额的40%），单位缴纳的60%纳入统筹基金不退。</li>
</ul>
<p><strong>办理流程</strong>：</p>
<ol>
<li>准备材料：身份证、社保卡、退保申请表（社保局领取）、特殊情况证明（如死亡证明）。</li>
<li>到参保地社保局申请 → 审核通过后 → 退款至指定银行卡。</li>
</ol>
<hr>
<h4 id="2-医疗保险退费"><a href="#2-医疗保险退费" class="headerlink" title="2. 医疗保险退费"></a><strong>2. 医疗保险退费</strong></h4><p><strong>可退费情形</strong>：</p>
<ul>
<li><strong>参保人去世</strong>：家属可提取医保个人账户余额。</li>
<li><strong>移民或注销国籍</strong>：部分城市允许退个人账户余额。</li>
<li><strong>重复参保</strong>：如同时缴纳职工医保和居民医保，可退居民医保费用。</li>
</ul>
<p><strong>不可退费情形</strong>：</p>
<ul>
<li>正常参保期间，医保个人账户余额不能随意提取（少数城市如北京可自由支取）。</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>城乡居民医保无个人账户，缴费后不退。</li>
</ul>
<hr>
<h3 id="二、住房公积金退费（提取）"><a href="#二、住房公积金退费（提取）" class="headerlink" title="二、住房公积金退费（提取）"></a><strong>二、住房公积金退费（提取）</strong></h3><h4 id="1-可提取情形"><a href="#1-可提取情形" class="headerlink" title="1. 可提取情形"></a><strong>1. 可提取情形</strong></h4><ul>
<li><strong>购房&#x2F;建房&#x2F;租房</strong>：提供购房合同、租房发票等。</li>
<li><strong>离职或退休</strong>：<ul>
<li>退休：可全额提取公积金余额。</li>
<li>离职：账户封存满6个月至2年（各地不同）且未再就业。</li>
</ul>
</li>
<li><strong>大病医疗</strong>：本人或直系亲属患重大疾病。</li>
<li><strong>移民或户口迁出</strong>：凭相关证明提取。</li>
<li><strong>去世</strong>：由继承人凭死亡证明提取。</li>
</ul>
<h4 id="2-不可提取情形"><a href="#2-不可提取情形" class="headerlink" title="2. 不可提取情形"></a><strong>2. 不可提取情形</strong></h4><ul>
<li>无正当理由（如单纯想套现）不能随意提取。</li>
</ul>
<h4 id="3-办理方式"><a href="#3-办理方式" class="headerlink" title="3. 办理方式"></a><strong>3. 办理方式</strong></h4><ul>
<li>线上：通过支付宝&#x2F;微信“公积金服务”申请。</li>
<li>线下：携带材料（身份证、银行卡、提取证明）到公积金管理中心办理。</li>
</ul>
<hr>
<h3 id="三、补缴规则对比"><a href="#三、补缴规则对比" class="headerlink" title="三、补缴规则对比"></a><strong>三、补缴规则对比</strong></h3><table>
<thead>
<tr>
<th><strong>项目</strong></th>
<th><strong>能否补缴？</strong></th>
<th><strong>能否退费？</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>职工养老保险</strong></td>
<td>✅ 可延长缴费或一次性补缴（视参保时间）。</td>
<td>✅ 仅限特定情形（去世、移民等）。</td>
</tr>
<tr>
<td><strong>职工医保</strong></td>
<td>✅ 退休时可一次性补缴差额年限。</td>
<td>✅ 仅退个人账户余额（需符合条件）。</td>
</tr>
<tr>
<td><strong>城乡居民养老</strong></td>
<td>✅ 允许一次性补缴至15年。</td>
<td>✅ 缴费期间去世或移民可退个人账户。</td>
</tr>
<tr>
<td><strong>城乡居民医保</strong></td>
<td>❌ 按年缴费，不补缴往年。</td>
<td>❌ 缴费后不退。</td>
</tr>
<tr>
<td><strong>公积金</strong></td>
<td>❌ 个人无法补缴断缴部分（需单位操作）。</td>
<td>✅ 符合条件（购房、离职等）可提取。</td>
</tr>
</tbody></table>
<hr>
<h3 id="四、重要提醒"><a href="#四、重要提醒" class="headerlink" title="四、重要提醒"></a><strong>四、重要提醒</strong></h3><ol>
<li><strong>社保退费损失大</strong>：  <ul>
<li>养老保险退保仅退个人部分，单位缴纳的统筹费用作废，晚年失去保障。</li>
</ul>
</li>
<li><strong>公积金提取更灵活</strong>：  <ul>
<li>优先通过购房、租房等合法途径提取，避免违规操作影响信用。</li>
</ul>
</li>
<li><strong>替代方案优于退费</strong>：  <ul>
<li>养老保险缴费不足时，优先选择 <strong>延长缴费</strong> 或 <strong>转入城乡居民养老保险</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="五、常见问题解答"><a href="#五、常见问题解答" class="headerlink" title="五、常见问题解答"></a><strong>五、常见问题解答</strong></h3><p><strong>Q1：离职后社保能退钱吗？</strong>  </p>
<ul>
<li>不能。除非移民、去世或退休时放弃补缴，否则需继续缴费或转移社保关系。</li>
</ul>
<p><strong>Q2：公积金封存后怎么提取？</strong>  </p>
<ul>
<li>离职封存满当地规定时间（如6个月），通过线上或线下申请，无需单位盖章。</li>
</ul>
<p><strong>Q3：社保和公积金退费到账时间？</strong>  </p>
<ul>
<li>通常15-30个工作日，具体咨询当地社保局或公积金中心（电话：12333&#x2F;12329）。</li>
</ul>
<hr>
<p>如有特殊情况，建议直接联系当地社保或公积金管理部门，以最新政策为准！</p>
]]></content>
      <categories>
        <category>社保</category>
        <category>公积金</category>
      </categories>
      <tags>
        <tag>社保,公积金</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记本拓展屏+平板</title>
    <url>/2025/02/07/%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%8B%93%E5%B1%95%E5%B1%8F-%E5%B9%B3%E6%9D%BF/</url>
    <content><![CDATA[<p><a href="https://spacedesk.en.uptodown.com/android/download">安卓平板apk下载地址</a><br><a href="https://www.spacedesk.net/download/">电脑端下载</a></p>
<h2 id="Spacedesk-版本介绍"><a href="#Spacedesk-版本介绍" class="headerlink" title="Spacedesk 版本介绍"></a>Spacedesk 版本介绍</h2><p><strong>Spacedesk</strong> 主要提供免费版本，适合大多数用户的基本需求。不过，它也有一些高级功能可能需要付费或通过捐赠支持开发。以下是 Spacedesk 的收费情况概述：</p>
<hr>
<h3 id="免费功能："><a href="#免费功能：" class="headerlink" title="免费功能："></a><strong>免费功能</strong>：</h3><ol>
<li><p><strong>基本屏幕扩展</strong>：</p>
<ul>
<li>支持将平板或手机作为电脑的扩展显示器。</li>
<li>支持 Wi-Fi 和 USB 连接。</li>
</ul>
</li>
<li><p><strong>多设备连接</strong>：</p>
<ul>
<li>可以同时连接多个设备作为扩展屏幕。</li>
</ul>
</li>
<li><p><strong>跨平台支持</strong>：</p>
<ul>
<li>支持 Windows 电脑与 Android&#x2F;iOS 设备连接。</li>
</ul>
</li>
<li><p><strong>基本分辨率支持</strong>：</p>
<ul>
<li>提供足够的分辨率用于日常办公和娱乐。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="可能收费或需要捐赠的功能："><a href="#可能收费或需要捐赠的功能：" class="headerlink" title="可能收费或需要捐赠的功能："></a><strong>可能收费或需要捐赠的功能</strong>：</h3><ol>
<li><p><strong>更高分辨率和刷新率</strong>：</p>
<ul>
<li>免费版可能限制分辨率或刷新率，付费或捐赠后可解锁更高性能。</li>
</ul>
</li>
<li><p><strong>高级功能</strong>：</p>
<ul>
<li>某些高级功能（如低延迟模式或高级设置）可能需要捐赠或购买。</li>
</ul>
</li>
<li><p><strong>商业用途</strong>：</p>
<ul>
<li>如果用于商业环境，可能需要购买许可证。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="捐赠支持："><a href="#捐赠支持：" class="headerlink" title="捐赠支持："></a><strong>捐赠支持</strong>：</h3><ul>
<li>Spacedesk 的开发团队接受捐赠以支持软件的持续开发和维护。用户可以通过官网捐赠以表达支持。</li>
</ul>
<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul>
<li><strong>免费版</strong>：适合个人用户的基本需求，功能足够日常使用。</li>
<li><strong>付费或捐赠</strong>：如果需要更高分辨率、更低延迟或商业用途，可能需要付费或捐赠。</li>
</ul>
<p>如果您只是偶尔使用或用于个人用途，免费版已经足够。如果需要更高级的功能，可以访问 <a href="https://www.spacedesk.net/">Spacedesk 官网</a> 了解更多详情。</p>
<h2 id="将电脑屏幕投射到平板电脑"><a href="#将电脑屏幕投射到平板电脑" class="headerlink" title="将电脑屏幕投射到平板电脑"></a>将电脑屏幕投射到平板电脑</h2><p>使用 <strong>Spacedesk</strong> 将电脑屏幕投射到平板电脑的步骤如下：</p>
<h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><ol>
<li><p><strong>下载软件</strong>：</p>
<ul>
<li>在电脑（Windows）上下载并安装 <strong>Spacedesk</strong> 驱动程序：<a href="https://www.spacedesk.net/">Spacedesk 官网</a>。</li>
<li>在平板电脑（Android 或 iOS）上下载并安装 <strong>Spacedesk</strong> 客户端应用（通过 Google Play 或 App Store）。</li>
</ul>
</li>
<li><p><strong>确保设备在同一网络</strong>：</p>
<ul>
<li>电脑和平板电脑需连接到同一 Wi-Fi 网络。</li>
</ul>
</li>
</ol>
<h4 id="在平板电脑上："><a href="#在平板电脑上：" class="headerlink" title="在平板电脑上："></a>在平板电脑上：</h4><ol>
<li>打开 <strong>Spacedesk</strong> 客户端应用。</li>
<li>应用会自动搜索同一网络中的电脑。找到您的电脑后，点击连接。</li>
<li>连接成功后，平板电脑将显示电脑屏幕内容。</li>
</ol>
<p><img src="/.io//image.png"><br>注意：</p>
<ul>
<li>WiFi连接需要同在一个局域网下</li>
<li>WiFi有延迟</li>
<li>USB需要打开显示器设备的开发者选项的调试模式</li>
<li>Local Area Network： WiFi连接开关</li>
<li>USB Cable Android：USB连接开关</li>
<li>若是数据线松动而连接失败，可以在电脑端控制台<strong>CONTROL</strong>重启连接: <strong>off</strong> ——&gt; <strong>on</strong></li>
<li>数据线连接了但是没有显示电脑画面，电脑端<strong>USB cable Android</strong>  先关了在开，然后屏幕端就重启Spacedesk软件就可以了</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>算法脑筋急转弯</title>
    <url>/2025/02/20/%E7%AE%97%E6%B3%95%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/</url>
    <content><![CDATA[<h2 id="四瓶药，每瓶含量若干，其中一瓶过期了，过期的药片比正常的药片的重量-1，正常药片的重量是已知的，现在有一个电子秤，请问如何在只秤一次的情况下找出过期的那瓶药？"><a href="#四瓶药，每瓶含量若干，其中一瓶过期了，过期的药片比正常的药片的重量-1，正常药片的重量是已知的，现在有一个电子秤，请问如何在只秤一次的情况下找出过期的那瓶药？" class="headerlink" title="四瓶药，每瓶含量若干，其中一瓶过期了，过期的药片比正常的药片的重量+1，正常药片的重量是已知的，现在有一个电子秤，请问如何在只秤一次的情况下找出过期的那瓶药？"></a>四瓶药，每瓶含量若干，其中一瓶过期了，过期的药片比正常的药片的重量+1，正常药片的重量是已知的，现在有一个电子秤，请问如何在只秤一次的情况下找出过期的那瓶药？</h2><p>可以利用数字编码的方式，只通过一次称重找出过期的那瓶药。方法如下：</p>
<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a><strong>步骤</strong>：</h3><ol>
<li><p><strong>编号</strong>：将四瓶药分别编号为 1、2、3、4。</p>
</li>
<li><p><strong>取样</strong>：从第 ( i ) 瓶药中取出 ( i ) 片药：</p>
<ul>
<li>从 <strong>第 1 瓶</strong> 取 <strong>1 片</strong>，</li>
<li>从 <strong>第 2 瓶</strong> 取 <strong>2 片</strong>，</li>
<li>从 <strong>第 3 瓶</strong> 取 <strong>3 片</strong>，</li>
<li>从 <strong>第 4 瓶</strong> 取 <strong>4 片</strong>。</li>
</ul>
</li>
<li><p><strong>称重</strong>：</p>
<ul>
<li>假设正常药片的重量为 ( w )，</li>
<li>过期药片的重量为 ( w + 1 )。</li>
<li>如果所有药片都是正常的，总重量应为：<br>[<br>1w + 2w + 3w + 4w &#x3D; 10w<br>]</li>
<li>但由于某一瓶药的药片过期，它的药片重量会比正常重量多出 <strong>过期药片数 × 1</strong>。</li>
</ul>
</li>
<li><p><strong>分析结果</strong>：</p>
<ul>
<li>设称得的总重量为 ( S )，</li>
<li>计算超出的重量：<br>[<br>S - 10w<br>]</li>
<li>这个值等于 <strong>过期药瓶的编号</strong>，因为我们从第 ( i ) 瓶中取了 ( i ) 片药，而过期药片的重量比正常药片多 1，所以增加的总重量正好是 ( i )。</li>
</ul>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例</strong>：</h3><p>假设 <strong>第 3 瓶药过期</strong>，那么：</p>
<ul>
<li>取样药片总数：( 1 + 2 + 3 + 4 &#x3D; 10 ) 片，</li>
<li>理论总重量：( 10w )，</li>
<li>实际称重：( 10w + 3 )，</li>
<li>多出的重量为 <strong>3</strong>，因此第 <strong>3 瓶</strong> 过期。</li>
</ul>
<p><strong>结论</strong>：<br>通过一次称重，即可根据超出的重量直接确定哪一瓶药过期。</p>
<h2 id="现有两支香，他们长短粗细各不相同，但是燃烬的时间都是一小时，请问我要如何得到15分钟？"><a href="#现有两支香，他们长短粗细各不相同，但是燃烬的时间都是一小时，请问我要如何得到15分钟？" class="headerlink" title="现有两支香，他们长短粗细各不相同，但是燃烬的时间都是一小时，请问我要如何得到15分钟？"></a>现有两支香，他们长短粗细各不相同，但是燃烬的时间都是一小时，请问我要如何得到15分钟？</h2><p>可以利用香燃烧速度不均匀但总时间固定的特性，通过 <strong>两端点燃</strong> 和 <strong>顺序点燃</strong> 来测量 <strong>15分钟</strong>。</p>
<h3 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a><strong>步骤</strong>：</h3><ol>
<li><p><strong>第一支香</strong>：<strong>两端同时点燃</strong>，它会在 <strong>30分钟</strong> 内燃尽（因为燃烧速度加倍）。</p>
</li>
<li><p><strong>第二支香</strong>：<strong>只点燃一端</strong>，它仍然需要 <strong>60分钟</strong> 燃尽。</p>
</li>
<li><p><strong>当第一支香燃尽时</strong>（即 <strong>30分钟过去了</strong>），<strong>立即点燃第二支香的另一端</strong>。</p>
<ul>
<li>由于此时第二支香已经燃烧了 <strong>30分钟</strong>，还剩 <strong>30分钟</strong> 可燃时间。</li>
<li>现在两端同时点燃，燃烧速度加倍，因此 <strong>剩余部分会在 15 分钟内燃尽</strong>。</li>
</ul>
</li>
</ol>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a><strong>结论</strong>：</h3><p><strong>第一支香 + 第二支香的双端燃烧</strong>，即可精准测得 <strong>15分钟</strong>！</p>
<h2 id="有两个容器分别是5L与6L-如何精准得到3L的水？"><a href="#有两个容器分别是5L与6L-如何精准得到3L的水？" class="headerlink" title="有两个容器分别是5L与6L,如何精准得到3L的水？"></a>有两个容器分别是5L与6L,如何精准得到3L的水？</h2><p>我们可以利用 <strong>倒水、装满、倒空</strong> 的操作，通过 <strong>6L 和 5L 容器的相互转换</strong>，精准得到 <strong>3L</strong> 的水。  </p>
<hr>
<h3 id="方法-1：使用-6L-容器倒入-5L-容器"><a href="#方法-1：使用-6L-容器倒入-5L-容器" class="headerlink" title="方法 1：使用 6L 容器倒入 5L 容器"></a><strong>方法 1：使用 6L 容器倒入 5L 容器</strong></h3><ol>
<li><strong>6L 装满</strong>（6L 容器有 6L 水）。</li>
<li><strong>把水倒入 5L 容器</strong>，5L 容器装满，6L 还剩 <strong>1L</strong>（6L → 1L，5L → 5L）。</li>
<li><strong>倒掉 5L 容器的水</strong>（6L → 1L，5L → 0L）。</li>
<li><strong>把 6L 容器的 1L 倒入 5L 容器</strong>（6L → 0L，5L → 1L）。</li>
<li><strong>再次装满 6L 容器</strong>（6L → 6L，5L → 1L）。</li>
<li><strong>将 6L 容器的水倒入 5L 容器</strong>，直到 5L 容器装满（6L 倒 <strong>4L</strong> 进去）。<ul>
<li>此时 6L 还剩 <strong>3L</strong>（✅ <strong>成功得到 3L</strong>！）</li>
</ul>
</li>
</ol>
<hr>
<h3 id="方法-2：使用-5L-容器倒入-6L-容器"><a href="#方法-2：使用-5L-容器倒入-6L-容器" class="headerlink" title="方法 2：使用 5L 容器倒入 6L 容器"></a><strong>方法 2：使用 5L 容器倒入 6L 容器</strong></h3><ol>
<li><strong>5L 容器装满</strong>（5L → 5L，6L → 0L）。</li>
<li><strong>把 5L 容器的水倒入 6L 容器</strong>（5L → 0L，6L → 5L）。</li>
<li><strong>再次装满 5L 容器</strong>（5L → 5L，6L → 5L）。</li>
<li><strong>往 6L 容器倒水</strong>，<strong>只倒 1L</strong>（因为 6L 只能装 1L）。<ul>
<li>此时 6L 容器变成 <strong>6L</strong>（满了），5L 容器剩 <strong>4L</strong>。</li>
</ul>
</li>
<li><strong>倒掉 6L 容器的水</strong>（5L → 4L，6L → 0L）。</li>
<li><strong>把 5L 容器中的 4L 倒入 6L 容器</strong>（5L → 0L，6L → 4L）。</li>
<li><strong>再次装满 5L 容器</strong>（5L → 5L，6L → 4L）。</li>
<li><strong>把 5L 容器的水倒入 6L 容器</strong>，只倒 <strong>2L</strong>，此时 6L 容器装满，5L 还剩 <strong>3L</strong>（✅ <strong>成功得到 3L</strong>！）。</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>方法 1</strong>（6L 容器倒 5L 容器）：更直接，6L 只剩 3L 时停止。</li>
<li><strong>方法 2</strong>（5L 倒 6L）：依靠不断装满倒水的方式，最终剩 3L。</li>
</ul>
<p>这两种方法都可以 <strong>精准获得 3L 水</strong>！💡</p>
]]></content>
  </entry>
  <entry>
    <title>自建git服务器</title>
    <url>/2025/01/08/%E8%87%AA%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>自建 Git 服务器是一种很好的方式，可以控制代码托管、提升安全性，并满足定制化需求。以下是详细的自建服务器步骤，包括两种常用方法：使用专业 Git 管理平台（如 GitLab&#x2F;Gitea）和简单搭建裸仓库。</p>
<blockquote>
<p>为什么使用自建服务器</p>
</blockquote>
<ol>
<li><p>安全性和隐私</p>
<ul>
<li>代码存储在公司或组织内部，不会暴露到公网上。</li>
</ul>
</li>
<li><p>成本考虑</p>
<ul>
<li>自建服务器无需支付第三方托管平台（如 GitHub、GitLab.com）的订阅费用。</li>
</ul>
</li>
<li><p>定制化需求</p>
<ul>
<li>可以根据团队需要调整服务配置，例如自定义权限、专属插件等。</li>
</ul>
</li>
<li><p>局域网环境</p>
<ul>
<li>如果服务器部署在内网，访问速度更快，适合没有外网需求的项目。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="方案-1：使用-GitLab-Gitea-搭建服务器"><a href="#方案-1：使用-GitLab-Gitea-搭建服务器" class="headerlink" title="方案 1：使用 GitLab&#x2F;Gitea 搭建服务器"></a><strong>方案 1：使用 GitLab&#x2F;Gitea 搭建服务器</strong></h2><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a><strong>1. 环境准备</strong></h3><ol>
<li><p><strong>硬件要求</strong></p>
<ul>
<li>一台服务器（物理机或云服务器），推荐配置：<ul>
<li><strong>GitLab</strong>：<ul>
<li>CPU：双核及以上。</li>
<li>内存：4GB 及以上。</li>
<li>磁盘：100GB（视代码量增加）。</li>
</ul>
</li>
<li><strong>Gitea</strong>：<ul>
<li>CPU：单核即可。</li>
<li>内存：512MB~1GB。</li>
<li>磁盘：10GB（小型项目）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>操作系统</strong>：Ubuntu、CentOS、Debian 或 Windows Server。</li>
</ul>
</li>
<li><p><strong>网络环境</strong></p>
<ul>
<li>固定的局域网或公网 IP 地址。</li>
<li>开放必要的端口（如 HTTP 的 <code>80</code> 或 <code>8989</code>）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-搭建-GitLab"><a href="#2-搭建-GitLab" class="headerlink" title="2. 搭建 GitLab"></a><strong>2. 搭建 GitLab</strong></h3><ol>
<li><p><strong>安装依赖</strong></p>
<ul>
<li>以 Ubuntu 为例：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y curl openssh-server ca-certificates</span><br><span class="line"><span class="built_in">sudo</span> apt install -y tzdata</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>下载 GitLab 安装包</strong></p>
<ul>
<li>添加 GitLab 仓库：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | <span class="built_in">sudo</span> bash</span><br></pre></td></tr></table></figure></li>
<li>安装 GitLab 社区版（免费）：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> EXTERNAL_URL=<span class="string">&quot;http://&lt;your_server_ip&gt;&quot;</span> apt install gitlab-ee</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>配置 GitLab</strong></p>
<ul>
<li>修改配置文件 <code>/etc/gitlab/gitlab.rb</code>：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">external_url &#x27;http://&lt;your_server_ip&gt;:8989&#x27;</span><br></pre></td></tr></table></figure></li>
<li>重新加载配置：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>访问 GitLab</strong></p>
<ul>
<li>打开浏览器访问 <code>http://&lt;your_server_ip&gt;:8989</code>，完成初始化设置。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-搭建-Gitea"><a href="#3-搭建-Gitea" class="headerlink" title="3. 搭建 Gitea"></a><strong>3. 搭建 Gitea</strong></h3><ol>
<li><p><strong>安装依赖</strong></p>
<ul>
<li>Ubuntu 为例：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y git sqlite3</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>下载并运行 Gitea</strong></p>
<ul>
<li>下载 Gitea：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O gitea https://dl.gitea.io/gitea/1.20.3/gitea-1.20.3-linux-amd64</span><br><span class="line"><span class="built_in">chmod</span> +x gitea</span><br></pre></td></tr></table></figure></li>
<li>创建运行目录：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /var/lib/gitea/&#123;custom,data,<span class="built_in">log</span>&#125;</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R git:git /var/lib/gitea</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> -R 750 /var/lib/gitea</span><br></pre></td></tr></table></figure></li>
<li>启动 Gitea：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./gitea web</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>访问 Gitea</strong></p>
<ul>
<li>打开浏览器访问 <code>http://&lt;your_server_ip&gt;:3000</code>，进行初始设置。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-配置用户和权限"><a href="#4-配置用户和权限" class="headerlink" title="4. 配置用户和权限"></a><strong>4. 配置用户和权限</strong></h3><ul>
<li>添加团队成员账号。</li>
<li>配置项目组和分支权限。</li>
<li>使用 HTTPS 或 SSH 进行安全访问。</li>
</ul>
<hr>
<h2 id="方案-2：搭建裸仓库（适合小型团队）"><a href="#方案-2：搭建裸仓库（适合小型团队）" class="headerlink" title="方案 2：搭建裸仓库（适合小型团队）"></a><strong>方案 2：搭建裸仓库（适合小型团队）</strong></h2><h3 id="1-创建裸仓库"><a href="#1-创建裸仓库" class="headerlink" title="1. 创建裸仓库"></a><strong>1. 创建裸仓库</strong></h3><ul>
<li>在服务器上初始化一个裸仓库（无工作区，专供远程管理）。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /srv/git/myproject.git</span><br><span class="line"><span class="built_in">cd</span> /srv/git/myproject.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-配置访问权限"><a href="#2-配置访问权限" class="headerlink" title="2. 配置访问权限"></a><strong>2. 配置访问权限</strong></h3><ul>
<li>添加用户账号（如 <code>git</code> 用户）：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> adduser git</span><br></pre></td></tr></table></figure></li>
<li>修改仓库权限：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R git:git /srv/git/myproject.git</span><br><span class="line"><span class="built_in">chmod</span> -R 755 /srv/git/myproject.git</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-提供远程访问"><a href="#3-提供远程访问" class="headerlink" title="3. 提供远程访问"></a><strong>3. 提供远程访问</strong></h3><ol>
<li><p><strong>通过 SSH 访问</strong></p>
<ul>
<li>用户需要将 SSH 公钥上传到服务器。</li>
<li>示例克隆命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@&lt;your_server_ip&gt;:/srv/git/myproject.git</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>通过 HTTP&#x2F;HTTPS 访问</strong></p>
<ul>
<li>配置 Apache&#x2F;Nginx 提供 HTTP 访问：<ul>
<li>Nginx 示例：<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> &lt;your_server_ip&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /myproject.git &#123;</span><br><span class="line">        <span class="attribute">root</span> /srv/git;</span><br><span class="line">        git_http_backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>克隆示例：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> http://&lt;your_server_ip&gt;/myproject.git</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h2 id="如何选择方案"><a href="#如何选择方案" class="headerlink" title="如何选择方案"></a><strong>如何选择方案</strong></h2><table>
<thead>
<tr>
<th>特点</th>
<th>GitLab</th>
<th>Gitea</th>
<th>裸仓库</th>
</tr>
</thead>
<tbody><tr>
<td><strong>功能</strong></td>
<td>全功能：代码审查、CI&#x2F;CD</td>
<td>轻量：代码管理为主</td>
<td>基本：代码托管</td>
</tr>
<tr>
<td><strong>部署难度</strong></td>
<td>较高</td>
<td>低</td>
<td>非常低</td>
</tr>
<tr>
<td><strong>团队规模</strong></td>
<td>大型团队</td>
<td>中小型团队</td>
<td>小型团队或个人</td>
</tr>
<tr>
<td><strong>性能需求</strong></td>
<td>高</td>
<td>低</td>
<td>极低</td>
</tr>
<tr>
<td><strong>自定义能力</strong></td>
<td>高</td>
<td>中</td>
<td>低</td>
</tr>
</tbody></table>
<hr>
<h2 id="后续管理与优化"><a href="#后续管理与优化" class="headerlink" title="后续管理与优化"></a><strong>后续管理与优化</strong></h2><ol>
<li><p><strong>备份</strong></p>
<ul>
<li>定期备份 Git 数据库（GitLab 提供工具，裸仓库可用 <code>rsync</code>）。</li>
</ul>
</li>
<li><p><strong>安全</strong></p>
<ul>
<li>配置防火墙（如 <code>ufw</code>）和 SSH 密钥登录。</li>
<li>如果需要外网访问，配置 HTTPS。</li>
</ul>
</li>
<li><p><strong>扩展功能</strong></p>
<ul>
<li>在 GitLab&#x2F;Gitea 中启用 Webhooks，集成自动化流程（如代码测试、部署）。</li>
</ul>
</li>
</ol>
<hr>
<p>如果你不确定如何选择或具体操作细节，可以告诉我你的团队规模和需求，我可以给出更适合的建议！</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>跨境电商</title>
    <url>/2025/02/11/%E8%B7%A8%E5%A2%83%E7%94%B5%E5%95%86/</url>
    <content><![CDATA[<p>店铺类型：</p>
<ul>
<li>铺货</li>
<li>精铺</li>
<li>品牌（精品）</li>
</ul>
<p>物流</p>
<ul>
<li>FBA：亚马逊仓发货</li>
<li>FBM(商家自发货)</li>
</ul>
<p>形式：</p>
<ul>
<li>海</li>
<li>铁</li>
<li>空</li>
</ul>
<p>工具：</p>
<p>谷歌趋势： Google Trends  关键词搜索 </p>
<ul>
<li>相关主题  趋势变化判断是不是和开发该品类</li>
<li>订阅关键词</li>
</ul>
<p>ads - 关键词规划师 </p>
<ul>
<li>转换率</li>
<li>获客成本</li>
<li></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>转产品经理</title>
    <url>/2025/02/11/%E8%BD%AC%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/</url>
    <content><![CDATA[<h1 id="产品专员岗位的晋升空间和难度"><a href="#产品专员岗位的晋升空间和难度" class="headerlink" title="产品专员岗位的晋升空间和难度"></a>产品专员岗位的晋升空间和难度</h1><p><strong>晋升路径</strong>：</p>
<ol>
<li><strong>产品专员</strong> → <strong>产品经理</strong> → <strong>高级产品经理</strong> → <strong>产品总监</strong> → <strong>VP&#x2F;CPO</strong></li>
<li><strong>产品专员</strong> → <strong>产品运营经理</strong> → <strong>产品运营总监</strong></li>
</ol>
<p><strong>难度</strong>：</p>
<ul>
<li><strong>综合能力要求高</strong>：需具备市场分析、用户研究、项目管理等多方面能力。</li>
<li><strong>沟通协调重要</strong>：需与多个部门协作，沟通和协调能力是关键。</li>
<li><strong>结果导向</strong>：晋升依赖于产品成功和业绩表现。</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>综合发展</strong>：适合具备商业思维和领导力的人，晋升路径清晰。</li>
<li><strong>跨行业机会多</strong>：产品管理技能适用于多个行业，职业选择广泛。</li>
</ul>
<h1 id="转行产品经理–职业规划路线"><a href="#转行产品经理–职业规划路线" class="headerlink" title="转行产品经理–职业规划路线"></a>转行产品经理–职业规划路线</h1><h3 id="转行做产品经理"><a href="#转行做产品经理" class="headerlink" title="转行做产品经理"></a><strong>转行做产品经理</strong></h3><p><strong>优势</strong>：</p>
<ul>
<li><strong>综合能力</strong>：产品经理更注重综合能力，如市场分析、用户研究、项目管理等，技术门槛相对较低。</li>
<li><strong>跨行业机会</strong>：产品经理技能适用于多个行业，职业选择更广。</li>
<li><strong>年龄优势</strong>：30岁转行做产品经理并不算晚，且产品经理职业生命周期较长。</li>
</ul>
<p><strong>劣势</strong>：</p>
<ul>
<li><strong>学习曲线</strong>：需学习新的知识和技能，如市场分析、用户研究、项目管理等。</li>
<li><strong>经验积累</strong>：初期可能缺乏相关经验，需从初级岗位做起。</li>
</ul>
<h3 id="职业规划路线设计"><a href="#职业规划路线设计" class="headerlink" title="职业规划路线设计"></a>职业规划路线设计</h3><p><strong>短期目标（1-2年）</strong>：</p>
<ul>
<li><strong>学习产品经理知识</strong>：通过在线课程、书籍等学习产品经理相关知识，如市场分析、用户研究、项目管理等。</li>
<li><strong>积累项目经验</strong>：尝试参与公司内部的产品项目，积累产品管理经验。</li>
<li><strong>考取相关证书</strong>：如PMP（项目管理专业人士）认证，提升竞争力。</li>
</ul>
<p><strong>中期目标（3-5年）</strong>：</p>
<ul>
<li><strong>初级产品经理</strong>：从初级产品经理做起，积累实际工作经验。</li>
<li><strong>提升综合能力</strong>：提升市场分析、用户研究、项目管理等综合能力。</li>
</ul>
<p><strong>长期目标（5年以上）</strong>：</p>
<ul>
<li><strong>高级产品经理&#x2F;产品总监</strong>：成为产品团队的核心领导者，负责产品战略和团队管理。</li>
</ul>
<h1 id="什么样的人适合做产品经理"><a href="#什么样的人适合做产品经理" class="headerlink" title="什么样的人适合做产品经理"></a>什么样的人适合做产品经理</h1><h3 id="1-沟通能力强"><a href="#1-沟通能力强" class="headerlink" title="1. 沟通能力强"></a>1. <strong>沟通能力强</strong></h3><ul>
<li><strong>跨部门协作</strong>：产品经理需要与开发、设计、市场、销售等多个部门协作，沟通能力至关重要。</li>
<li><strong>用户沟通</strong>：与用户沟通，理解用户需求，反馈用户意见。</li>
</ul>
<h3 id="2-商业敏感度高"><a href="#2-商业敏感度高" class="headerlink" title="2. 商业敏感度高"></a>2. <strong>商业敏感度高</strong></h3><ul>
<li><strong>市场分析</strong>：能够分析市场趋势，识别商业机会。</li>
<li><strong>竞争分析</strong>：了解竞争对手，制定竞争策略。</li>
</ul>
<h3 id="3-用户导向"><a href="#3-用户导向" class="headerlink" title="3. 用户导向"></a>3. <strong>用户导向</strong></h3><ul>
<li><strong>用户研究</strong>：能够进行用户研究，理解用户需求和行为。</li>
<li><strong>用户体验</strong>：关注用户体验，设计用户友好的产品。</li>
</ul>
<h3 id="4-项目管理能力"><a href="#4-项目管理能力" class="headerlink" title="4. 项目管理能力"></a>4. <strong>项目管理能力</strong></h3><ul>
<li><strong>项目规划</strong>：能够制定项目计划，分配资源，管理进度。</li>
<li><strong>风险管理</strong>：识别项目风险，制定应对措施。</li>
</ul>
<h3 id="5-数据分析能力"><a href="#5-数据分析能力" class="headerlink" title="5. 数据分析能力"></a>5. <strong>数据分析能力</strong></h3><ul>
<li><strong>数据驱动决策</strong>：能够通过数据分析，做出数据驱动的决策。</li>
<li><strong>数据解读</strong>：能够解读数据，发现数据背后的洞察。</li>
</ul>
<h3 id="6-创新思维"><a href="#6-创新思维" class="headerlink" title="6. 创新思维"></a>6. <strong>创新思维</strong></h3><ul>
<li><strong>创新意识</strong>：能够提出创新想法，推动产品创新。</li>
<li><strong>解决问题</strong>：能够解决复杂问题，找到创新的解决方案。</li>
</ul>
<h3 id="7-抗压能力强"><a href="#7-抗压能力强" class="headerlink" title="7. 抗压能力强"></a>7. <strong>抗压能力强</strong></h3><ul>
<li><strong>应对挑战</strong>：能够在高压环境下工作，应对各种挑战。</li>
<li><strong>情绪管理</strong>：能够管理情绪，保持冷静和专注。</li>
</ul>
<h3 id="8-学习能力强"><a href="#8-学习能力强" class="headerlink" title="8. 学习能力强"></a>8. <strong>学习能力强</strong></h3><ul>
<li><strong>快速学习</strong>：能够快速学习新知识，适应新环境。</li>
<li><strong>持续学习</strong>：保持持续学习的态度，不断提升自己。</li>
</ul>
<h3 id="9-领导力"><a href="#9-领导力" class="headerlink" title="9. 领导力"></a>9. <strong>领导力</strong></h3><ul>
<li><strong>团队管理</strong>：能够领导团队，激励团队成员。</li>
<li><strong>决策能力</strong>：能够做出决策，并承担决策后果。</li>
</ul>
<h3 id="10-技术理解力"><a href="#10-技术理解力" class="headerlink" title="10. 技术理解力"></a>10. <strong>技术理解力</strong></h3><ul>
<li><strong>技术背景</strong>：虽然不是必须，但具备一定的技术背景有助于与技术团队沟通。</li>
<li><strong>技术趋势</strong>：了解技术趋势，能够将技术与产品结合。</li>
</ul>
<h1 id="喜欢“捣鼓”的人通常具有以下特点："><a href="#喜欢“捣鼓”的人通常具有以下特点：" class="headerlink" title="喜欢“捣鼓”的人通常具有以下特点："></a>喜欢“捣鼓”的人通常具有以下特点：</h1><ul>
<li><strong>好奇心强</strong>：喜欢探索新事物，尝试不同的方法和工具。</li>
<li><strong>动手能力强</strong>：喜欢亲自动手实践，解决问题。</li>
<li><strong>创新意识</strong>：喜欢尝试新思路，创造新东西。</li>
<li><strong>耐心和专注</strong>：能够长时间专注于某个问题，直到找到解决方案。</li>
</ul>
<h3 id="适合产品经理岗"><a href="#适合产品经理岗" class="headerlink" title="适合产品经理岗"></a><strong>适合产品经理岗</strong></h3><p>喜欢捣鼓的人也可以适合产品经理岗，但需要满足以下条件：</p>
<ul>
<li><strong>对用户行为和市场趋势感兴趣</strong>：喜欢捣鼓的人如果对用户需求、市场趋势有好奇心，可以尝试从用户行为中挖掘创新点。</li>
<li><strong>喜欢尝试新工具和方法</strong>：产品经理需要不断尝试新的工具（如数据分析工具、原型设计工具）和方法（如用户调研、A&#x2F;B测试），这与喜欢捣鼓的特点相符。</li>
<li><strong>创新思维</strong>：产品经理需要提出创新的产品想法，并推动其实现，适合喜欢尝试新思路的人。</li>
</ul>
<p><strong>适合的点</strong>：</p>
<ul>
<li>如果你喜欢研究用户行为、市场趋势，并愿意尝试新的工具和方法，产品经理岗可能适合你。</li>
<li>如果你更喜欢从宏观角度思考问题，而不是深入技术细节，产品经理岗会更适合。</li>
</ul>
<h1 id="那么，如何转行做产品经理呢？以下是一些建议"><a href="#那么，如何转行做产品经理呢？以下是一些建议" class="headerlink" title="那么，如何转行做产品经理呢？以下是一些建议"></a>那么，如何转行做产品经理呢？以下是一些建议</h1><ol>
<li><strong>学习产品经理相关知识：</strong><ul>
<li>阅读产品经理相关书籍，了解产品经理的工作职责、技能要求和工作流程。</li>
<li>参加产品经理培训课程，系统学习产品经理知识体系。</li>
<li>关注产品经理相关的公众号、博客和社区，了解行业动态和发展趋势。</li>
</ul>
</li>
<li><strong>积累产品经理实践经验：</strong><ul>
<li>参与公司内部的产品项目，主动承担一些产品经理助理或实习生的工作。</li>
<li>参与一些开源项目或个人项目，尝试从0到1打造一款产品。</li>
<li>在工作中，有意识地培养自己的沟通、协调、逻辑思维和表达能力。</li>
</ul>
</li>
<li><strong>准备产品经理面试：</strong><ul>
<li>准备自我介绍，突出自己的优势和特点，表达对产品经理工作的兴趣和热情。</li>
<li>准备产品经理面试常问的问题，如：<ul>
<li>你对产品经理的理解是什么？</li>
<li>你认为一个好的产品经理应该具备哪些素质？</li>
<li>你如何分析用户需求？</li>
<li>你如何设计一款产品？</li>
<li>你在工作中遇到的最大挑战是什么？你是如何解决的？</li>
</ul>
</li>
<li>准备一些自己参与过的产品案例，展示自己的产品能力。</li>
</ul>
</li>
</ol>
<h1 id="产品经理转型规划"><a href="#产品经理转型规划" class="headerlink" title="产品经理转型规划"></a><strong>产品经理转型规划</strong></h1><h4 id="📌-短期（0-6个月）：探索方向"><a href="#📌-短期（0-6个月）：探索方向" class="headerlink" title="📌 短期（0-6个月）：探索方向"></a><strong>📌 短期（0-6个月）：探索方向</strong></h4><ul>
<li>学习<strong>产品管理核心技能</strong>（用户研究、需求分析、PRD文档撰写）  </li>
<li>研究市场需求，确定自己是否适合产品经理岗位  </li>
<li>了解<strong>游戏行业的产品管理</strong>，如游戏策划、数据分析、商业化运营  </li>
<li>学习<strong>Axure、SQL、数据分析</strong>等基础工具</li>
</ul>
<h4 id="📌-中期（6个月-2年）：积累经验"><a href="#📌-中期（6个月-2年）：积累经验" class="headerlink" title="📌 中期（6个月-2年）：积累经验"></a><strong>📌 中期（6个月-2年）：积累经验</strong></h4><ul>
<li>先从<strong>游戏策划、数据分析、运营</strong>等相关岗位切入，过渡到产品岗  </li>
<li>参与公司内部<strong>产品优化、用户数据分析、商业化设计</strong>等工作  </li>
<li>尝试<strong>内部转岗</strong>，或者通过副业积累产品经验</li>
</ul>
<h4 id="📌-长期（2-5年）：稳固职业发展"><a href="#📌-长期（2-5年）：稳固职业发展" class="headerlink" title="📌 长期（2-5年）：稳固职业发展"></a><strong>📌 长期（2-5年）：稳固职业发展</strong></h4><ul>
<li>争取进入<strong>产品负责人</strong>岗位，具备完整的产品规划与管理能力  </li>
<li>扩展到更广泛的产品领域，如<strong>互联网、移动应用、SaaS工具</strong>等  </li>
<li>学习更多管理与商业策略，向<strong>产品总监</strong>或<strong>创业方向</strong>发展</li>
</ul>
<p><strong>🚀 关键行动点：</strong><br>✅ 学习产品经理核心知识（需求分析、PRD、数据分析）<br>✅ 结合游戏经验，从策划、数据分析、商业化方向切入<br>✅ 尝试内部转岗或寻找相关实习&#x2F;副业，积累实际产品经验<br>✅ 长期目标是成为游戏或互联网行业的<strong>产品负责人</strong></p>
<p>从其他岗位（如开发、设计、运营等）转型为产品经理是一个常见的职业发展路径。以下是一个详细的产品经理转型规划，帮助你顺利过渡并在这个岗位上取得成功。</p>
<hr>
<h3 id="1-明确转型动机"><a href="#1-明确转型动机" class="headerlink" title="1. 明确转型动机"></a><strong>1. 明确转型动机</strong></h3><p>在开始转型之前，先明确自己为什么要转型为产品经理：</p>
<ul>
<li><strong>兴趣驱动</strong>：是否对用户需求、市场趋势、产品设计有浓厚兴趣？</li>
<li><strong>职业发展</strong>：是否认为产品经理的职业发展空间更大？</li>
<li><strong>技能匹配</strong>：是否认为自己具备或愿意培养产品经理所需的核心能力？</li>
</ul>
<p>明确动机后，才能更有针对性地制定转型计划。</p>
<hr>
<h3 id="2-了解产品经理的核心能力"><a href="#2-了解产品经理的核心能力" class="headerlink" title="2. 了解产品经理的核心能力"></a><strong>2. 了解产品经理的核心能力</strong></h3><p>产品经理需要具备以下核心能力：</p>
<ul>
<li><strong>用户研究</strong>：理解用户需求，分析用户行为。</li>
<li><strong>市场分析</strong>：研究市场趋势，分析竞争对手。</li>
<li><strong>产品设计</strong>：设计产品功能，绘制原型。</li>
<li><strong>项目管理</strong>：制定项目计划，协调资源，推动项目落地。</li>
<li><strong>数据分析</strong>：通过数据驱动决策，优化产品。</li>
<li><strong>沟通协调</strong>：与开发、设计、运营、市场等多部门协作。</li>
</ul>
<hr>
<h3 id="3-转型规划步骤"><a href="#3-转型规划步骤" class="headerlink" title="3. 转型规划步骤"></a><strong>3. 转型规划步骤</strong></h3><h4 id="阶段一：学习与准备（3-6个月）"><a href="#阶段一：学习与准备（3-6个月）" class="headerlink" title="阶段一：学习与准备（3-6个月）"></a><strong>阶段一：学习与准备（3-6个月）</strong></h4><ol>
<li><p><strong>学习产品经理基础知识</strong>：</p>
<ul>
<li>通过书籍（如《启示录》、《用户体验要素》）、在线课程（如Coursera、Udemy）学习产品经理的基础知识。</li>
<li>了解产品生命周期、需求分析、原型设计、项目管理等核心概念。</li>
</ul>
</li>
<li><p><strong>掌握工具</strong>：</p>
<ul>
<li><strong>原型设计工具</strong>：Axure、Sketch、Figma。</li>
<li><strong>项目管理工具</strong>：Jira、Trello、Asana。</li>
<li><strong>数据分析工具</strong>：Excel、SQL、Google Analytics。</li>
</ul>
</li>
<li><p><strong>积累行业知识</strong>：</p>
<ul>
<li>关注行业动态，阅读行业报告（如艾瑞咨询、易观分析）。</li>
<li>研究竞品，分析其产品逻辑和用户体验。</li>
</ul>
</li>
<li><p><strong>参与实际项目</strong>：</p>
<ul>
<li>在公司内部寻找机会，参与产品相关的项目（如需求分析、用户调研）。</li>
<li>如果没有机会，可以通过实习、兼职或 freelance 项目积累经验。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="阶段二：实践与积累（6-12个月）"><a href="#阶段二：实践与积累（6-12个月）" class="headerlink" title="阶段二：实践与积累（6-12个月）"></a><strong>阶段二：实践与积累（6-12个月）</strong></h4><ol>
<li><p><strong>从辅助岗位开始</strong>：</p>
<ul>
<li>申请公司内部的产品助理、产品运营等岗位，逐步接触产品管理工作。</li>
<li>如果没有内部机会，可以考虑跳槽到初级产品经理岗位。</li>
</ul>
</li>
<li><p><strong>参与完整产品生命周期</strong>：</p>
<ul>
<li>从需求分析到产品上线，全程参与一个或多个项目，积累实战经验。</li>
<li>学习如何撰写需求文档（PRD）、设计产品原型、协调开发团队。</li>
</ul>
</li>
<li><p><strong>培养用户思维</strong>：</p>
<ul>
<li>多与用户沟通，了解他们的痛点和需求。</li>
<li>通过用户反馈和数据优化产品。</li>
</ul>
</li>
<li><p><strong>提升数据分析能力</strong>：</p>
<ul>
<li>学习如何通过数据分析发现问题，提出优化方案。</li>
<li>掌握基本的 SQL 查询和数据分析工具。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="阶段三：提升与突破（1-2年）"><a href="#阶段三：提升与突破（1-2年）" class="headerlink" title="阶段三：提升与突破（1-2年）"></a><strong>阶段三：提升与突破（1-2年）</strong></h4><ol>
<li><p><strong>独立负责产品模块</strong>：</p>
<ul>
<li>从辅助岗位逐步过渡到独立负责某个产品模块或功能。</li>
<li>学习如何制定产品策略，推动项目落地。</li>
</ul>
</li>
<li><p><strong>提升沟通与协调能力</strong>：</p>
<ul>
<li>与开发、设计、运营等部门紧密合作，提升跨部门沟通能力。</li>
<li>学习如何平衡各方需求，推动项目顺利进行。</li>
</ul>
</li>
<li><p><strong>学习高级技能</strong>：</p>
<ul>
<li><strong>商业分析</strong>：学习如何通过产品实现商业目标。</li>
<li><strong>用户体验设计</strong>：深入理解用户体验设计原则，提升产品设计能力。</li>
<li><strong>技术理解</strong>：了解基本的技术原理，与技术团队更好地沟通。</li>
</ul>
</li>
<li><p><strong>建立个人品牌</strong>：</p>
<ul>
<li>在行业社区（如知乎、人人都是产品经理）分享经验，建立个人影响力。</li>
<li>参加行业会议、沙龙，拓展人脉。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="阶段四：进阶与发展（2年以上）"><a href="#阶段四：进阶与发展（2年以上）" class="headerlink" title="阶段四：进阶与发展（2年以上）"></a><strong>阶段四：进阶与发展（2年以上）</strong></h4><ol>
<li><p><strong>成为高级产品经理</strong>：</p>
<ul>
<li>独立负责整个产品或产品线，制定产品战略。</li>
<li>带领团队完成产品目标，提升团队效率。</li>
</ul>
</li>
<li><p><strong>向产品总监&#x2F;VP发展</strong>：</p>
<ul>
<li>负责多个产品线，制定公司级产品战略。</li>
<li>参与公司高层决策，推动业务增长。</li>
</ul>
</li>
<li><p><strong>持续学习与创新</strong>：</p>
<ul>
<li>关注行业前沿技术（如AI、区块链）和趋势（如元宇宙、Web3）。</li>
<li>不断学习新知识，保持竞争力。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-转型中的关键建议"><a href="#4-转型中的关键建议" class="headerlink" title="4. 转型中的关键建议"></a><strong>4. 转型中的关键建议</strong></h3><ul>
<li><strong>利用现有优势</strong>：如果你有技术背景，可以转型为技术型产品经理；如果有设计背景，可以专注于用户体验设计。</li>
<li><strong>从小公司或初创公司开始</strong>：小公司对产品经理的要求相对较低，适合积累经验。</li>
<li><strong>多与产品经理交流</strong>：向有经验的产品经理请教，了解他们的工作内容和挑战。</li>
<li><strong>保持耐心</strong>：转型是一个长期过程，需要不断学习和积累经验。</li>
</ul>
<hr>
<h3 id="5-推荐学习资源"><a href="#5-推荐学习资源" class="headerlink" title="5. 推荐学习资源"></a><strong>5. 推荐学习资源</strong></h3><ul>
<li><strong>书籍</strong>：<ul>
<li>《启示录》：产品经理必读书籍。</li>
<li>《用户体验要素》：深入理解用户体验设计。</li>
<li>《精益创业》：学习如何快速验证产品想法。</li>
</ul>
</li>
<li><strong>在线课程</strong>：<ul>
<li>Coursera：Google 产品经理课程。</li>
<li>Udemy：产品经理实战课程。</li>
</ul>
</li>
<li><strong>社区</strong>：<ul>
<li>人人都是产品经理：行业资讯、经验分享。</li>
<li>PMCAFF：产品经理交流社区。</li>
</ul>
</li>
</ul>
<h4 id="知识星球"><a href="#知识星球" class="headerlink" title="知识星球"></a>知识星球</h4><ul>
<li>基本理论<ul>
<li>（竞品分析 需求分析 需求管理 产品设计 技术相关知识）</li>
<li>《幕后产品》产品的基础理论知识</li>
<li>《设计心理学》设计原则及审美</li>
<li>b站课程，up某江鱼-觉【产品经理的技术必修课】</li>
</ul>
</li>
<li>数据分析能力<ul>
<li>b站课程，up主阿宁的产品数据小屋【数据分析只需3小时，从入门到进阶】</li>
<li>《精益数据分析》微信读书，入门书籍</li>
</ul>
</li>
<li>逻辑思维能力<ul>
<li>《麦肯锡的结构化战略思维》</li>
<li>《金字塔原理》</li>
</ul>
</li>
<li>商业洞察力<ul>
<li>《创新者的窘境》</li>
<li>《零售的哲学》</li>
<li>《商业模式新生代》</li>
<li>《从0到1开启商业与未来的秘密》</li>
</ul>
</li>
<li>写作能力<ul>
<li>《写作是门手艺》</li>
</ul>
</li>
<li>沟通能力<ul>
<li>《非暴力沟通》</li>
<li>《沟通的方法》</li>
<li>《学会提问》</li>
</ul>
</li>
<li>工具（拿现有产品倒推）<ul>
<li>原型工具：墨刀：码前</li>
<li>功能结构图工具：x-mind</li>
<li>业务流程图工具：processon</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>学会输入与输出</li>
<li>读书学习笔记或产品分析与行业分析</li>
<li>行业分析可找行业报告通读</li>
<li>产品可找行业头部，腰部，或新颖的产品做分析</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>软件、工具推荐</title>
    <url>/2025/05/01/%E8%BD%AF%E4%BB%B6%E3%80%81%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h1 id="电脑软件"><a href="#电脑软件" class="headerlink" title="电脑软件"></a>电脑软件</h1><p>开发软件</p>
<table>
<thead>
<tr>
<th>num</th>
<th>软件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Markdown Monster</td>
<td>Markdown文本编辑器</td>
</tr>
<tr>
<td>2</td>
<td>FileZilla</td>
<td>文件传输工具，主要用于在本地计算机与远程服务器之间高效、安全地上传、下载和管理文件</td>
</tr>
</tbody></table>
<p>系统软件</p>
<hr>
<table>
<thead>
<tr>
<th>num</th>
<th>软件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>WinDirStat</td>
<td>扫描磁盘或文件夹，以图形化区块显示文件和文件夹大小</td>
</tr>
<tr>
<td>2</td>
<td>Snipaste</td>
<td>截图贴图软件</td>
</tr>
</tbody></table>
<p>开源工程</p>
<table>
<thead>
<tr>
<th>num</th>
<th>工程</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TEngine</td>
<td>扫描磁盘或文件夹，以图形化区块显示文件和文件夹大小</td>
</tr>
<tr>
<td>2</td>
<td>UnityGameFramework</td>
<td>EllanJiang<a href="https://gameframework.cn/">官网</a>,<a href="https://github.com/EllanJiang/UnityGameFramework">git</a></td>
</tr>
<tr>
<td>2</td>
<td>WebGLInput</td>
<td><a href="https://github.com/kou-yeung/WebGLInput">支持TMP,支持“复制粘贴”支持“tab”和“shift+tab”切换焦点到其他InputField支持移动设备</a></td>
</tr>
<tr>
<td>2</td>
<td>TowerDefense-GameFramework</td>
<td><a href="https://github.com/DrFlower/TowerDefense-GameFramework-Demo">花桑</a></td>
</tr>
<tr>
<td>2</td>
<td>StarForce</td>
<td><a href="https://github.com/EllanJiang/StarForce">EllanJiang游戏演示</a></td>
</tr>
<tr>
<td>2</td>
<td>QFramework</td>
<td><a href="https://github.com/liangxiegame/QFramework">凉鞋</a></td>
</tr>
<tr>
<td>2</td>
<td>hybridclr_unity</td>
<td><a href="https://github.com/focus-creative-games/hybridclr_unity">华佗</a></td>
</tr>
<tr>
<td>2</td>
<td>hybridclr_trial</td>
<td><a href="https://github.com/focus-creative-games/hybridclr_trial">框架</a></td>
</tr>
<tr>
<td>2</td>
<td>GameFramework</td>
<td>框架工程<a href="https://github.com/EllanJiang/GameFramework">EllanJiang</a></td>
</tr>
<tr>
<td>2</td>
<td>ET-release9.0</td>
<td><a href="https://github.com/egametang/ET">egametang</a></td>
</tr>
<tr>
<td>2</td>
<td>Deer_GameFramework_Wolong</td>
<td>wolong热更新框架 <a href="https://github.com/It-Life/Deer_GameFramework_Wolong">基于GameFrame+HybridCLR</a></td>
</tr>
<tr>
<td>2</td>
<td>HybridCLR</td>
<td>文件传输工具，主要用于在本地计算机与远程服务器之间高效、安全地上传、下载和管理文件</td>
</tr>
<tr>
<td>2</td>
<td>LuaFramework_UGUI</td>
<td><a href="https://github.com/jarjin/LuaFramework_UGUI">lua开源框架</a></td>
</tr>
<tr>
<td>2</td>
<td>GameFramework-Next</td>
<td><a href="https://github.com/Alex-Rachel/GameFramework-Next">GameFramework、YooAsset、UniTask、luban、hybridclr</a></td>
</tr>
</tbody></table>
]]></content>
  </entry>
</search>
