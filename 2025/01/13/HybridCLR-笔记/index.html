<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>HybridCLR 笔记 | LiuCheng's Blog</title><meta name="author" content="LiuCheng"><meta name="copyright" content="LiuCheng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="hybridclr Package手册最佳实践不支持特性AOT泛型热更新程序集的 auto reference 如果你们项目把Assembly-CSharp作为AOT程序集，强烈建议关闭热更新程序集的auto reference选项。因为Assembly-CSharp是最顶层assembly，开启此选项后会自动引用剩余所有assembly，包括热更新程序集，很容易就出现失误引用热更新程序集导致打包">
<meta property="og:type" content="article">
<meta property="og:title" content="HybridCLR 笔记">
<meta property="og:url" content="https://mr-liu-cheng.github.io/2025/01/13/HybridCLR-%E7%AC%94%E8%AE%B0/">
<meta property="og:site_name" content="LiuCheng&#39;s Blog">
<meta property="og:description" content="hybridclr Package手册最佳实践不支持特性AOT泛型热更新程序集的 auto reference 如果你们项目把Assembly-CSharp作为AOT程序集，强烈建议关闭热更新程序集的auto reference选项。因为Assembly-CSharp是最顶层assembly，开启此选项后会自动引用剩余所有assembly，包括热更新程序集，很容易就出现失误引用热更新程序集导致打包">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mr-liu-cheng.github.io/img/favicon.png">
<meta property="article:published_time" content="2025-01-13T18:47:33.000Z">
<meta property="article:modified_time" content="2025-01-13T18:47:33.000Z">
<meta property="article:author" content="LiuCheng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mr-liu-cheng.github.io/img/favicon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mr-liu-cheng.github.io/2025/01/13/HybridCLR-%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-1389699351715193',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HybridCLR 笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa-solid fa-book"></i><span> Doc</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa-solid fa-timeline"></i><span> Archives</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tag</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa-solid fa-folder-tree"></i><span> Categories</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/game/"><i class="fa-fw fa-solid fa-gamepad"></i><span> Game</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/About/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa-regular fa-pen-to-square"></i><span> More</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/musicPage/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/%E5%BD%B1%E8%A7%86%E5%88%86%E4%BA%AB/"><i class="fa-fw fa-solid fa-film"></i><span> Vidio Sharing</span></a></li><li><a class="site-page child" href="/%E7%BE%8E%E9%A3%9F/"><i class="fa-fw fa-solid fa-mug-hot"></i><span> Delicious</span></a></li><li><a class="site-page child" href="/%E6%B8%B8%E8%AE%B0/"><i class="fa-fw fa-solid fa-person-hiking"></i><span> Tourist</span></a></li><li><a class="site-page child" href="/Photos/"><i class="fa-fw fas fa-images"></i><span> Photos</span></a></li><li><a class="site-page child" href="/Calendar/"><i class="fa-fw fa-regular fa-calendar-check"></i><span> Calendar</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/favicon.png" alt="Logo"><span class="site-name">LiuCheng's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">HybridCLR 笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa-solid fa-book"></i><span> Doc</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa-solid fa-timeline"></i><span> Archives</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tag</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa-solid fa-folder-tree"></i><span> Categories</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/game/"><i class="fa-fw fa-solid fa-gamepad"></i><span> Game</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/About/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa-regular fa-pen-to-square"></i><span> More</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/musicPage/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/%E5%BD%B1%E8%A7%86%E5%88%86%E4%BA%AB/"><i class="fa-fw fa-solid fa-film"></i><span> Vidio Sharing</span></a></li><li><a class="site-page child" href="/%E7%BE%8E%E9%A3%9F/"><i class="fa-fw fa-solid fa-mug-hot"></i><span> Delicious</span></a></li><li><a class="site-page child" href="/%E6%B8%B8%E8%AE%B0/"><i class="fa-fw fa-solid fa-person-hiking"></i><span> Tourist</span></a></li><li><a class="site-page child" href="/Photos/"><i class="fa-fw fas fa-images"></i><span> Photos</span></a></li><li><a class="site-page child" href="/Calendar/"><i class="fa-fw fa-regular fa-calendar-check"></i><span> Calendar</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">HybridCLR 笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-13T18:47:33.000Z" title="发表于 2025-01-13 18:47:33">2025-01-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-13T18:47:33.000Z" title="更新于 2025-01-13 18:47:33">2025-01-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h2 id="hybridclr-Package手册"><a href="#hybridclr-Package手册" class="headerlink" title="hybridclr Package手册"></a><a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/com.code-philosophy.hybridclr">hybridclr Package手册</a></h2><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/bestpractice">最佳实践</a></h2><h2 id="不支持特性"><a href="#不支持特性" class="headerlink" title="不支持特性"></a><a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/notsupportedfeatures">不支持特性</a></h2><h2 id="AOT泛型"><a href="#AOT泛型" class="headerlink" title="AOT泛型"></a><a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/aotgeneric">AOT泛型</a></h2><h2 id="热更新程序集的-auto-reference"><a href="#热更新程序集的-auto-reference" class="headerlink" title="热更新程序集的 auto reference"></a>热更新程序集的 auto reference</h2><blockquote>
<p>如果你们项目把Assembly-CSharp作为AOT程序集，强烈建议关闭热更新程序集的auto reference选项。因为Assembly-CSharp是最顶层assembly，开启此选项后会自动引用剩余所有assembly，包括热更新程序集，很容易就出现失误引用热更新程序集导致打包失败的情况。</p>
</blockquote>
<p>这段话的核心是提醒开发者避免在 Unity 项目中意外地让 <code>Assembly-CSharp</code>（默认的主程序集）引用到热更新程序集，以防止打包或运行时出现问题。以下是详细解释：</p>
<hr>
<h3 id="1-什么是-auto-reference-选项？"><a href="#1-什么是-auto-reference-选项？" class="headerlink" title="1. 什么是 auto reference 选项？"></a>1. 什么是 <code>auto reference</code> 选项？</h3><ul>
<li>Unity 中的 <code>auto reference</code> 是一个程序集配置选项，控制是否让其他程序集（如 <code>Assembly-CSharp</code>）自动引用当前程序集。</li>
<li>默认情况下，这个选项是 <strong>开启</strong> 的，意味着该程序集会被自动引用，无需手动配置。</li>
</ul>
<hr>
<h3 id="2-Assembly-CSharp-是什么？"><a href="#2-Assembly-CSharp-是什么？" class="headerlink" title="2. Assembly-CSharp 是什么？"></a><strong>2. Assembly-CSharp 是什么？</strong></h3><ul>
<li><code>Assembly-CSharp</code> 是 Unity 项目的主程序集，包含了大部分代码逻辑，是一个 <strong>AOT（Ahead-of-Time）程序集</strong>。</li>
<li>因为 AOT 编译模式在构建时需要提前生成机器代码，所以不能直接加载和运行 JIT（Just-In-Time）模式的热更新程序集。</li>
</ul>
<hr>
<h3 id="3-热更新程序集是什么？"><a href="#3-热更新程序集是什么？" class="headerlink" title="3. 热更新程序集是什么？"></a><strong>3. 热更新程序集是什么？</strong></h3><ul>
<li><strong>热更新程序集</strong>（如 <code>Hotfix.dll</code>）通常是为实现动态更新功能而编写的代码，采用 JIT 模式运行，支持在运行时加载。</li>
<li>它们是 Unity 中独立于 <code>Assembly-CSharp</code> 的额外程序集。</li>
</ul>
<hr>
<h3 id="4-问题的本质"><a href="#4-问题的本质" class="headerlink" title="4. 问题的本质"></a><strong>4. 问题的本质</strong></h3><ul>
<li><code>Assembly-CSharp</code> 自动引用热更新程序集的问题：<ul>
<li><strong>错误引用</strong>：如果 <code>Assembly-CSharp</code> 中的代码错误地依赖了热更新程序集的内容，那么 Unity 打包工具会尝试将热更新程序集内容一起打包到构建结果中。</li>
<li><strong>冲突</strong>：由于热更新程序集需要在运行时加载，而不是在构建时被编译到应用中，错误的引用会导致 <strong>打包失败</strong> 或 <strong>运行时错误</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-为什么建议关闭热更新程序集的-auto-reference？"><a href="#5-为什么建议关闭热更新程序集的-auto-reference？" class="headerlink" title="5. 为什么建议关闭热更新程序集的 auto reference？"></a>5. 为什么建议关闭热更新程序集的 <code>auto reference</code>？</h3><ul>
<li><p><strong>关闭后效果</strong>：</p>
<ul>
<li>防止 Unity 自动将热更新程序集添加为 <code>Assembly-CSharp</code> 的依赖项。</li>
<li>强制开发者在代码中显式引用热更新程序集，避免误用。</li>
</ul>
</li>
<li><p><strong>示例问题</strong>：</p>
<ul>
<li>假如你在 <code>Assembly-CSharp</code> 中调用了热更新程序集中的方法（例如 <code>Hotfix.SomeMethod()</code>），Unity 会尝试将 <code>Hotfix.dll</code> 包含到主程序集的依赖中。</li>
<li>这种错误的引用可能导致：<ul>
<li>打包失败（热更新程序集不支持 AOT 编译）。</li>
<li>热更新失效（运行时无法正确加载动态程序集）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-如何关闭-auto-reference？"><a href="#6-如何关闭-auto-reference？" class="headerlink" title="6. 如何关闭 auto reference？"></a>6. 如何关闭 <code>auto reference</code>？</h3><p>在 Unity 项目的 <code>Assembly Definition File (.asmdef)</code> 中，关闭 <code>auto reference</code> 选项：</p>
<ol>
<li>找到热更新程序集的 <code>.asmdef</code> 文件。</li>
<li>打开并编辑该文件。</li>
<li>确保以下选项关闭：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;autoReferenced&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br></pre></td></tr></table></figure></li>
<li>保存更改，重新编译项目。</li>
</ol>
<hr>
<h3 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项"></a><strong>7. 注意事项</strong></h3><ul>
<li><p><strong>依赖管理</strong>：</p>
<ul>
<li>关闭 <code>auto reference</code> 后，如果 <code>Assembly-CSharp</code> 需要访问热更新程序集中的代码，你需要手动在 <code>Assembly Definition References</code> 中显式引用。</li>
<li>推荐将热更新逻辑和主逻辑隔离，避免 <code>Assembly-CSharp</code> 直接依赖热更新程序集。</li>
</ul>
</li>
<li><p><strong>模块化设计</strong>：</p>
<ul>
<li>将热更新逻辑放在独立的命名空间和文件夹下，确保开发过程中不会意外引用。</li>
</ul>
</li>
<li><p><strong>打包验证</strong>：</p>
<ul>
<li>在打包前，检查主程序集是否存在对热更新程序集的依赖，确保热更新功能可以正常运行。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>这段建议的目的是防止主程序集 <code>Assembly-CSharp</code> 中误引用热更新程序集，避免因为编译模式冲突（AOT 和 JIT）导致打包失败或运行时问题。关闭热更新程序集的 <code>auto reference</code> 可以帮助你更好地控制依赖关系，避免无意的错误引用。</p>
<h2 id="Assembly-CSharp-程序集"><a href="#Assembly-CSharp-程序集" class="headerlink" title="Assembly-CSharp 程序集"></a>Assembly-CSharp 程序集</h2><p><strong><code>Assembly-CSharp</code></strong> 是 Unity 项目的主程序集，通常是 Unity 的默认代码文件（例如 <code>Assets</code> 文件夹中的脚本）编译后生成的程序集。如果你的项目中仍然依赖它，**通常不能删除 <code>Assembly-CSharp</code>**，但可以通过以下方式避免直接使用它或完全移除它：</p>
<hr>
<h3 id="1-Assembly-CSharp-的作用"><a href="#1-Assembly-CSharp-的作用" class="headerlink" title="1. Assembly-CSharp 的作用"></a><strong>1. Assembly-CSharp 的作用</strong></h3><ul>
<li><strong>默认代码程序集</strong>：Unity 会将 <code>Assets</code> 文件夹中不属于任何自定义 Assembly Definition（<code>*.asmdef</code>）文件的代码编译到 <code>Assembly-CSharp</code> 中。</li>
<li><strong>主逻辑存储</strong>：如果你没有使用自定义 <code>asmdef</code> 文件，<code>Assembly-CSharp</code> 会包含你的大部分业务逻辑。</li>
</ul>
<hr>
<h3 id="2-什么时候可以删除-Assembly-CSharp？"><a href="#2-什么时候可以删除-Assembly-CSharp？" class="headerlink" title="2. 什么时候可以删除 Assembly-CSharp？"></a><strong>2. 什么时候可以删除 <code>Assembly-CSharp</code>？</strong></h3><p>你可以通过以下步骤实现移除 <code>Assembly-CSharp</code>：</p>
<p> <strong>方法 1：全部使用 Assembly Definition</strong></p>
<ol>
<li><p><strong>创建自定义程序集</strong>：</p>
<ul>
<li>在项目中为所有代码文件创建 <code>*.asmdef</code> 文件，分离每个模块或子系统。</li>
<li>每个 <code>*.asmdef</code> 文件会生成一个独立的程序集。</li>
</ul>
</li>
<li><p><strong>移动脚本到自定义程序集</strong>：</p>
<ul>
<li>将项目中的所有脚本文件移动到有 <code>*.asmdef</code> 文件的目录下。</li>
<li>确保所有代码都属于自定义程序集。</li>
</ul>
</li>
<li><p><strong>验证引用关系</strong>：</p>
<ul>
<li>检查 <code>*.asmdef</code> 文件的依赖关系，确保模块之间的依赖正确配置。</li>
</ul>
</li>
<li><p><strong>删除 Assembly-CSharp</strong>：</p>
<ul>
<li>如果 <code>Assets</code> 根目录下没有脚本文件，Unity 将不会生成 <code>Assembly-CSharp</code>，从而实现移除。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-为什么通常不建议删除？"><a href="#3-为什么通常不建议删除？" class="headerlink" title="3. 为什么通常不建议删除？"></a><strong>3. 为什么通常不建议删除？</strong></h3><p> <strong>性能影响</strong>：</p>
<ul>
<li><strong>额外开销</strong>：使用多个自定义程序集（<code>*.asmdef</code> 文件）可能增加编译时间，尤其是小型项目中，直接使用 <code>Assembly-CSharp</code> 会更简单且高效。</li>
</ul>
<p> <strong>兼容性问题</strong>：</p>
<ul>
<li><strong>第三方插件</strong>：许多第三方插件默认使用 <code>Assembly-CSharp</code>，完全移除可能需要对这些插件做大量修改。</li>
</ul>
<p> <strong>维护成本</strong>：</p>
<ul>
<li><strong>依赖管理复杂</strong>：多个 <code>*.asmdef</code> 文件增加了项目的复杂性，尤其是在多人协作时，可能会引入额外的依赖管理问题。</li>
</ul>
<hr>
<h3 id="4-推荐的实践"><a href="#4-推荐的实践" class="headerlink" title="4. 推荐的实践"></a><strong>4. 推荐的实践</strong></h3><p> <strong>小型项目</strong></p>
<ul>
<li>保留 <code>Assembly-CSharp</code>，只需确保代码组织清晰即可。</li>
<li>如果需要动态加载或热更新，将热更新逻辑移到单独的程序集。</li>
</ul>
<p> <strong>中大型项目</strong></p>
<ul>
<li><p>使用 <code>*.asmdef</code> 文件分离模块：</p>
<ul>
<li>核心模块（例如网络、UI、热更新）使用独立程序集。</li>
<li>非核心逻辑可以保留在 <code>Assembly-CSharp</code> 中，逐步迁移。</li>
</ul>
</li>
<li><p>最终目标：移除 <code>Assembly-CSharp</code> 或只保留最基本的功能代码。</p>
</li>
</ul>
<hr>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><ul>
<li><strong>可以删除</strong>：只要你通过 <code>*.asmdef</code> 文件将所有脚本移动到自定义程序集，就可以完全移除 <code>Assembly-CSharp</code>。</li>
<li><strong>不建议删除</strong>：对于简单或中等规模的项目，保留 <code>Assembly-CSharp</code> 可以减少管理复杂性。</li>
<li><strong>推荐方案</strong>：逐步将核心模块从 <code>Assembly-CSharp</code> 中剥离，通过自定义程序集实现模块化管理，但无需过度追求完全移除。</li>
</ul>
<h2 id="Scripting-Backend-IL2CPP"><a href="#Scripting-Backend-IL2CPP" class="headerlink" title="Scripting Backend -&gt; IL2CPP"></a>Scripting Backend -&gt; IL2CPP</h2><p>在使用 <strong>HybridCLR</strong> 进行热更新时，构建项目时将 <strong>Scripting Backend</strong> 切换为 <strong>IL2CPP</strong> 是出于以下原因：</p>
<hr>
<h3 id="1-IL2CPP-的作用"><a href="#1-IL2CPP-的作用" class="headerlink" title="1. IL2CPP 的作用"></a><strong>1. IL2CPP 的作用</strong></h3><ul>
<li><strong>IL2CPP（Intermediate Language To C++）</strong> 是 Unity 提供的一种脚本编译方式，用于将 C# 脚本的 IL 代码转换为 C++ 代码，再通过平台的原生编译器（如 Clang）生成机器代码。</li>
<li><strong>AOT（Ahead-Of-Time）编译</strong> 是 IL2CPP 的核心特点，它会提前将代码编译为目标平台的二进制代码，而不是像 Mono 那样依赖 JIT（Just-In-Time）编译。</li>
</ul>
<hr>
<h3 id="2-为什么要使用-IL2CPP"><a href="#2-为什么要使用-IL2CPP" class="headerlink" title="2. 为什么要使用 IL2CPP"></a><strong>2. 为什么要使用 IL2CPP</strong></h3><p> <strong>支持 AOT 和热更新并存</strong><br>HybridCLR 的核心是实现 AOT 和 JIT 的混合运行：</p>
<ul>
<li><strong>AOT 部分</strong>：IL2CPP 编译器会提前将 Assembly-CSharp 等固定程序集编译为二进制代码（.so、.dll 等），确保性能和稳定性。</li>
<li><strong>JIT 部分</strong>：HybridCLR 允许运行时加载和执行动态热更新程序集（如 <code>Hotfix.dll</code>），这些代码在运行时解析并执行 IL 指令。</li>
</ul>
<p> <strong>解决 Mono 的限制</strong></p>
<ul>
<li>Mono 支持 JIT，但在移动平台（如 Android 和 iOS）上只能运行 AOT 编译的代码，不支持动态加载新程序集。</li>
<li>IL2CPP 提供更高效、更安全的运行时环境，同时通过 HybridCLR 增加了对 JIT 的支持，突破了 IL2CPP 默认不支持动态程序集的限制。</li>
</ul>
<p> <strong>性能和安全性</strong></p>
<ul>
<li>IL2CPP 的运行效率比 Mono 更高，因为其生成的 C++ 代码经过了更优化的原生编译器处理。</li>
<li>更高的安全性：IL2CPP 将 C# 代码转换为本地机器码，反编译难度更高，适合发布对安全性要求高的项目（如手游）。</li>
</ul>
<hr>
<h3 id="3-IL2CPP-与-HybridCLR-的协作"><a href="#3-IL2CPP-与-HybridCLR-的协作" class="headerlink" title="3. IL2CPP 与 HybridCLR 的协作"></a><strong>3. IL2CPP 与 HybridCLR 的协作</strong></h3><p>HybridCLR 的热更新方案依赖 IL2CPP 的 AOT 特性，同时扩展了 IL2CPP 的功能：</p>
<ol>
<li><p><strong>AOT 编译的主程序集</strong>：</p>
<ul>
<li>Unity 的默认程序集（如 <code>Assembly-CSharp</code>）和一些基础库通过 IL2CPP 编译为机器代码，保证核心功能的高性能和稳定性。</li>
</ul>
</li>
<li><p><strong>JIT 执行的热更新程序集</strong>：</p>
<ul>
<li>HybridCLR 在运行时加载未编译的 IL 指令（如热更新 DLL），并在托管环境中解析和执行这些指令。</li>
<li>HybridCLR 会接管 IL2CPP 的一些功能（如 IL 解释器），实现动态程序集的加载和执行。</li>
</ul>
</li>
<li><p><strong>自动生成桥接代码</strong>：</p>
<ul>
<li>HybridCLR 通过生成元数据和补丁，解决 AOT 和 JIT 混合模式下的调用问题，确保热更新逻辑可以无缝调用 AOT 编译的代码。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h3><p>将 <strong>Scripting Backend</strong> 切换为 <strong>IL2CPP</strong> 是 HybridCLR 的一个核心需求，原因包括：</p>
<ol>
<li><strong>支持 AOT 模式</strong>，提供高性能和跨平台兼容性。</li>
<li><strong>增强安全性</strong>，通过机器代码降低反编译的可能性。</li>
<li><strong>兼容性要求</strong>，Mono 不支持动态热更新程序集的加载，而 IL2CPP 在 HybridCLR 的扩展下支持这一功能。</li>
</ol>
<p>因此，在 HybridCLR 构建过程中，切换到 <strong>IL2CPP</strong> 是实现热更新功能的必要步骤，同时也能保证项目的运行效率和安全性。</p>
<h2 id="Api-Compatibility-Level-NET-Framework"><a href="#Api-Compatibility-Level-NET-Framework" class="headerlink" title="Api Compatibility Level -&gt; .NET Framework"></a>Api Compatibility Level -&gt; .NET Framework</h2><p>在使用 <strong>HybridCLR</strong> 或实现热更新时，通常需要将 <strong>Api Compatibility Level</strong> 切换为 <strong>.NET 4.x</strong>（Unity 2019-2020）或 <strong>.NET Framework</strong>（Unity 2021+）。这是因为：</p>
<hr>
<h3 id="1-API-Compatibility-Level-的作用"><a href="#1-API-Compatibility-Level-的作用" class="headerlink" title="1. API Compatibility Level 的作用"></a><strong>1. API Compatibility Level 的作用</strong></h3><ul>
<li><strong>定义了 Unity 项目的运行时 API 集合版本</strong>，控制了 C# 语言功能、类库功能以及第三方依赖支持的范围。</li>
<li>Unity 提供两种主要的 API Compatibility Level：<ol>
<li><strong>.NET Standard 2.0</strong>：一种跨平台的精简子集，支持最基本的 .NET API。</li>
<li><strong>.NET 4.x（或 .NET Framework in Unity 2021+）</strong>：包含更全面的 .NET API，支持更多高级特性和库。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-为什么要选择-NET-4-x-或-NET-Framework"><a href="#2-为什么要选择-NET-4-x-或-NET-Framework" class="headerlink" title="2. 为什么要选择 .NET 4.x 或 .NET Framework"></a><strong>2. 为什么要选择 .NET 4.x 或 .NET Framework</strong></h3><p> <strong>更广泛的 API 支持</strong></p>
<ul>
<li><strong>.NET Standard 2.0 的限制</strong>：精简版 API 会导致许多常用的 .NET 类库无法使用（例如部分反射功能、泛型类型扩展等）。</li>
<li><strong>.NET 4.x 的优势</strong>：提供完整的 .NET Framework 功能，如高级的反射机制、动态加载程序集、<code>System.IO</code> 等功能模块。</li>
<li>HybridCLR 需要在运行时加载和执行热更新的 DLL，通常需要依赖 <strong>完整反射功能</strong> 和其他高级特性，因此需要更高版本的 API 支持。</li>
</ul>
<p> <strong>兼容性与功能性</strong></p>
<ul>
<li>热更新逻辑中，动态加载的 DLL 可能会依赖于完整的 .NET Framework API。</li>
<li>HybridCLR 和许多第三方插件（如 Json.NET、各种 ORM 框架）也往往依赖于 .NET 4.x 的特性。</li>
</ul>
<p> <strong>编译支持</strong></p>
<ul>
<li>.NET 4.x 可以更好地支持现代 C# 语言特性（如异步流、元组、多模式匹配等），使开发和维护更加便捷。</li>
<li>对于 Unity 项目中的热更新模块，切换到 .NET 4.x 可以减少潜在的兼容性问题。</li>
</ul>
<hr>
<h3 id="3-Unity-版本的变化"><a href="#3-Unity-版本的变化" class="headerlink" title="3. Unity 版本的变化"></a><strong>3. Unity 版本的变化</strong></h3><ul>
<li><strong>Unity 2019-2020</strong>：仍然将 .NET 4.x 和 .NET Standard 2.0 并列提供。</li>
<li>**Unity 2021+**：将 <strong>.NET Framework</strong>（等效于 .NET 4.x）替代了 .NET Standard 2.0，成为推荐选项。</li>
</ul>
<blockquote>
<p>Unity 2021 起，Unity 逐步向 <strong>.NET Core&#x2F;.NET 5</strong> 方向迁移，因此 API 层级有所变化。</p>
</blockquote>
<hr>
<h3 id="4-为什么不选择-NET-Standard-2-0？"><a href="#4-为什么不选择-NET-Standard-2-0？" class="headerlink" title="4. 为什么不选择 .NET Standard 2.0？"></a><strong>4. 为什么不选择 .NET Standard 2.0？</strong></h3><p> <strong>功能不足</strong></p>
<ul>
<li><strong>限制反射功能</strong>：<code>System.Reflection.Emit</code> 等特性在 .NET Standard 2.0 中受到限制。</li>
<li><strong>API 缺失</strong>：许多成熟的类库（如高级的 LINQ 查询、数据操作库）需要 .NET 4.x 的支持。</li>
</ul>
<p> <strong>第三方依赖问题</strong></p>
<ul>
<li>许多第三方库没有完全支持 .NET Standard 2.0，而是为 .NET Framework 或更高版本设计。</li>
</ul>
<p> <strong>不适合热更新</strong></p>
<ul>
<li>热更新需要动态加载和解释运行程序集（DLL），这对反射、动态类型支持、程序集加载有较高要求，.NET Standard 2.0 无法满足。</li>
</ul>
<hr>
<h3 id="5-如何切换-API-Compatibility-Level"><a href="#5-如何切换-API-Compatibility-Level" class="headerlink" title="5. 如何切换 API Compatibility Level"></a><strong>5. 如何切换 API Compatibility Level</strong></h3><p> <strong>Unity 2019-2020</strong></p>
<ol>
<li>打开 <strong>Edit &gt; Project Settings &gt; Player &gt; Other Settings</strong>。</li>
<li>找到 <strong>Api Compatibility Level</strong>。</li>
<li>选择 <strong>.NET 4.x</strong>。</li>
</ol>
<p> <strong>Unity 2021+</strong></p>
<ol>
<li>同样在 <strong>Player &gt; Other Settings</strong>。</li>
<li>将 <strong>Api Compatibility Level</strong> 切换为 <strong>.NET Framework</strong>。</li>
</ol>
<hr>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h3><p>将 <strong>Api Compatibility Level</strong> 切换为 <strong>.NET 4.x</strong>（或 Unity 2021+ 中的 <strong>.NET Framework</strong>）的原因：</p>
<ol>
<li><strong>支持更丰富的 .NET API</strong>，如高级反射、动态加载等功能，满足热更新需求。</li>
<li><strong>提高兼容性</strong>，使项目能够使用现代 C# 特性及第三方类库。</li>
<li><strong>解决热更新的技术需求</strong>，尤其是在 HybridCLR 或其他动态加载框架中。</li>
</ol>
<blockquote>
<p>如果你的项目使用热更新，或者依赖于复杂的第三方库，这是必要的一步。</p>
</blockquote>
<h2 id="C-Compiler-Configuration-Debug"><a href="#C-Compiler-Configuration-Debug" class="headerlink" title="C++ Compiler Configuration: Debug"></a>C++ Compiler Configuration: Debug</h2><p><strong>C++ Compiler Configuration: Debug</strong> 是一个配置选项，通常出现在项目的编译环境设置中（如 Unity、Visual Studio 或其他开发工具）。它的作用是指定 <strong>C++ 编译器的调试配置</strong>，用于生成方便调试的二进制文件。以下是关于这个配置的详细解释：</p>
<hr>
<h3 id="1-Debug-配置的主要用途"><a href="#1-Debug-配置的主要用途" class="headerlink" title="1. Debug 配置的主要用途"></a><strong>1. Debug 配置的主要用途</strong></h3><ul>
<li><strong>调试优化</strong>：生成的二进制文件包含调试符号，允许你在调试器（如 Visual Studio 或 Unity Profiler）中查看变量值、调用栈和程序执行流。</li>
<li><strong>更低的优化级别</strong>：为了方便调试，编译器会降低或禁用某些代码优化，这使得生成的代码结构更接近源代码。</li>
<li><strong>额外信息嵌入</strong>：会嵌入调试信息，例如源文件的路径、行号和符号表，以便与调试器协同工作。</li>
</ul>
<hr>
<h3 id="2-Debug-与-Release-的区别"><a href="#2-Debug-与-Release-的区别" class="headerlink" title="2. Debug 与 Release 的区别"></a><strong>2. Debug 与 Release 的区别</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>Debug 配置</th>
<th>Release 配置</th>
</tr>
</thead>
<tbody><tr>
<td><strong>优化级别</strong></td>
<td>较低或无优化，保留完整源代码结构</td>
<td>高度优化，删除无用代码</td>
</tr>
<tr>
<td><strong>调试符号</strong></td>
<td>包含完整调试符号</td>
<td>通常不包含调试符号</td>
</tr>
<tr>
<td><strong>运行时性能</strong></td>
<td>较低（因优化级别低）</td>
<td>高效（因高度优化）</td>
</tr>
<tr>
<td><strong>文件大小</strong></td>
<td>较大（包含调试信息和未优化代码）</td>
<td>较小</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>开发和调试阶段</td>
<td>产品发布阶段</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-在-Unity-中的应用"><a href="#3-在-Unity-中的应用" class="headerlink" title="3. 在 Unity 中的应用"></a><strong>3. 在 Unity 中的应用</strong></h3><p>在 Unity 项目中，使用 <strong>C++ Compiler Configuration: Debug</strong> 的场景通常与底层插件开发或 IL2CPP 编译有关。</p>
<p> <strong>IL2CPP 和 Debug 配置</strong></p>
<ul>
<li><strong>IL2CPP</strong>（Intermediate Language to C++）：Unity 会将 C# 脚本转译为中间语言（IL），然后通过 IL2CPP 转换为 C++ 代码，最后编译为目标平台的二进制文件。</li>
<li>当你选择 Debug 配置时，Unity 会为生成的 C++ 代码启用调试符号，从而更容易在开发工具中调试底层代码。</li>
</ul>
<hr>
<h3 id="4-配置-Debug-的好处"><a href="#4-配置-Debug-的好处" class="headerlink" title="4. 配置 Debug 的好处"></a><strong>4. 配置 Debug 的好处</strong></h3><ol>
<li><strong>调试能力增强</strong>：<ul>
<li>能够设置断点、逐步执行代码，排查运行时问题。</li>
<li>支持查看复杂数据结构、对象状态。</li>
</ul>
</li>
<li><strong>快速发现问题</strong>：<ul>
<li>错误信息更准确（例如指向具体的源代码行）。</li>
<li>更容易重现和分析程序中的崩溃或异常。</li>
</ul>
</li>
<li><strong>适合开发阶段</strong>：<ul>
<li>调试配置允许开发人员专注于功能的正确性，而不必担心性能问题。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-配置-Debug-的缺点"><a href="#5-配置-Debug-的缺点" class="headerlink" title="5. 配置 Debug 的缺点"></a><strong>5. 配置 Debug 的缺点</strong></h3><ol>
<li><strong>性能较低</strong>：由于禁用了某些优化，运行速度可能明显慢于 Release 配置。</li>
<li><strong>文件较大</strong>：包含调试符号和未优化的代码，生成的文件体积较大。</li>
<li><strong>发布不可用</strong>：Debug 配置的二进制文件通常不适合作为最终产品发布。</li>
</ol>
<hr>
<h3 id="6-如何切换到-Debug-配置"><a href="#6-如何切换到-Debug-配置" class="headerlink" title="6. 如何切换到 Debug 配置"></a><strong>6. 如何切换到 Debug 配置</strong></h3><p> <strong>在 Unity 中</strong></p>
<ol>
<li><strong>编辑器设置</strong>：<ul>
<li>打开 <strong>Edit &gt; Preferences &gt; External Tools</strong>。</li>
<li>在 <strong>C++ Compiler Configuration</strong> 中选择 <strong>Debug</strong>。</li>
</ul>
</li>
<li><strong>Build Settings</strong>：<ul>
<li>在 Unity 的 <strong>Build Settings</strong> 中选择 <strong>Development Build</strong>，会启用调试模式。</li>
</ul>
</li>
</ol>
<p> <strong>在 Visual Studio 或其他工具中</strong></p>
<ol>
<li>在解决方案配置中，选择 <strong>Debug</strong> 配置。</li>
<li>检查编译器选项，确保启用了调试符号（如 <code>/DEBUG</code> 标志）。</li>
</ol>
<hr>
<h3 id="7-适用场景"><a href="#7-适用场景" class="headerlink" title="7. 适用场景"></a><strong>7. 适用场景</strong></h3><ul>
<li><strong>开发和调试阶段</strong>：需要验证逻辑、排查 Bug 或分析运行时问题。</li>
<li><strong>测试复杂逻辑</strong>：如自定义 Native 插件、复杂算法或与平台相关的代码。</li>
<li><strong>集成第三方库</strong>：调试与第三方库的交互问题。</li>
</ul>
<hr>
<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a><strong>8. 总结</strong></h3><p><strong>C++ Compiler Configuration: Debug</strong> 是为开发和调试阶段准备的编译配置，提供了强大的调试能力，但牺牲了一定的性能和文件体积。它适合在项目开发阶段使用，而最终发布阶段应该切换到 <strong>Release 配置</strong> 以获得最佳的性能和较小的文件体积。</p>
<h2 id="Use-Incremental-GC-true"><a href="#Use-Incremental-GC-true" class="headerlink" title="Use Incremental GC: true"></a>Use Incremental GC: true</h2><p><strong>Use Incremental GC: true</strong> 是 Unity 中的一项配置，用于启用 <strong>增量垃圾回收（Incremental Garbage Collection）</strong>，以改善游戏运行时的性能表现，特别是在内存管理方面。</p>
<hr>
<h3 id="1-什么是垃圾回收（Garbage-Collection-GC）？"><a href="#1-什么是垃圾回收（Garbage-Collection-GC）？" class="headerlink" title="1. 什么是垃圾回收（Garbage Collection, GC）？"></a><strong>1. 什么是垃圾回收（Garbage Collection, GC）？</strong></h3><p>垃圾回收是 Unity（和许多其他运行时环境）用来自动管理内存的一种机制。它会回收那些不再被引用的对象所占用的内存，从而避免内存泄漏。然而，传统的垃圾回收机制可能会导致性能问题：</p>
<ul>
<li><strong>传统 GC</strong> 是全暂停式的（Stop-the-World）：当垃圾回收运行时，游戏的所有逻辑都会暂停，直到回收完成。</li>
<li>如果内存分配量较大或对象复杂，可能会导致显著的帧率下降（卡顿）。</li>
</ul>
<hr>
<h3 id="2-增量垃圾回收（Incremental-GC）"><a href="#2-增量垃圾回收（Incremental-GC）" class="headerlink" title="2. 增量垃圾回收（Incremental GC）"></a><strong>2. 增量垃圾回收（Incremental GC）</strong></h3><p>增量垃圾回收是传统垃圾回收的优化版本，它将回收工作分为多个小的步骤，而不是一次性完成。这些步骤分散在多帧中执行，从而避免了长时间的暂停。</p>
<p> <strong>工作原理</strong>：</p>
<ul>
<li>将垃圾回收的工作拆分成更小的任务块。</li>
<li>在每一帧中执行一部分任务，而不是整个回收过程。</li>
<li>减少垃圾回收对帧率的影响，提高游戏的流畅性。</li>
</ul>
<hr>
<h3 id="3-启用-Use-Incremental-GC-的好处"><a href="#3-启用-Use-Incremental-GC-的好处" class="headerlink" title="3. 启用 Use Incremental GC 的好处"></a><strong>3. 启用 Use Incremental GC 的好处</strong></h3><ol>
<li><strong>减少卡顿</strong>：<ul>
<li>垃圾回收不再集中发生，暂停时间减少，帧率更加稳定。</li>
</ul>
</li>
<li><strong>适合大型项目</strong>：<ul>
<li>对于使用大量动态对象或频繁分配内存的项目（如开放世界、模拟类游戏），增量垃圾回收更能提升用户体验。</li>
</ul>
</li>
<li><strong>平滑性能</strong>：<ul>
<li>提高低端设备上的性能表现，避免内存回收造成的长时间卡顿。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a><strong>4. 使用场景</strong></h3><ul>
<li><strong>大型游戏</strong>：如开放世界游戏、大型多人在线游戏。</li>
<li><strong>频繁内存分配的项目</strong>：如实时生成内容的游戏、动态创建 UI 元素的应用。</li>
<li><strong>目标平台是移动设备</strong>：尤其是低端设备，对性能敏感时，启用增量垃圾回收可以改善运行表现。</li>
</ul>
<hr>
<h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a><strong>5. 注意事项</strong></h3><ol>
<li><strong>增量垃圾回收不是万能的</strong>：<ul>
<li>虽然它减少了暂停时间，但回收总时间可能会比传统 GC 更长（因为回收被分摊到了多帧中）。</li>
</ul>
</li>
<li><strong>可能引入额外的性能开销</strong>：<ul>
<li>如果项目本身对 GC 依赖较少，可能无法显著受益。</li>
</ul>
</li>
<li><strong>需要配合优化内存分配</strong>：<ul>
<li>减少大对象分配和频繁分配内存的操作，仍是优化性能的关键。</li>
</ul>
</li>
<li><strong>与某些功能冲突</strong>：<ul>
<li>某些 Unity 功能或插件可能对增量 GC 的行为不兼容，需测试。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="6-如何启用-Incremental-GC"><a href="#6-如何启用-Incremental-GC" class="headerlink" title="6. 如何启用 Incremental GC"></a><strong>6. 如何启用 Incremental GC</strong></h3><p> 在 Unity 编辑器中：</p>
<ol>
<li>打开 <strong>Edit &gt; Project Settings &gt; Player</strong>。</li>
<li>找到 <strong>Other Settings</strong>。</li>
<li>勾选 <strong>Use Incremental GC</strong>。</li>
</ol>
<p> 代码中检测增量 GC：<br>你可以在代码中检查或设置是否启用了增量垃圾回收：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug.Log(<span class="string">$&quot;Incremental GC Enabled: <span class="subst">&#123;UnityEngine.Scripting.GarbageCollector.isIncremental&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h3><p>启用 <strong>Incremental GC</strong> 是一种平衡性能和垃圾回收开销的解决方案，特别适用于复杂和内存密集型的游戏场景。它减少了游戏中因垃圾回收导致的明显卡顿，提升了玩家体验。不过，要确保你的项目确实需要它，并在启用后测试性能表现，以避免引入不必要的额外开销。</p>
<h2 id="不支持的特性"><a href="#不支持的特性" class="headerlink" title="不支持的特性"></a><a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/notsupportedfeatures">不支持的特性</a></h2><h2 id="代码裁剪"><a href="#代码裁剪" class="headerlink" title="代码裁剪"></a>代码裁剪</h2><blockquote>
<p>问题：<br>由于上一次的代码中完全没有用到例如GameObject，导致GameObject类型的部分函数在打包时被裁剪。（这只是个假设，目前GameObject是不会被裁剪掉的，但是其他非核心代码会存在这个问题）</p>
</blockquote>
<blockquote>
<p>解决方案：<br>HybridCLR&#x2F;Generate&#x2F;All命令会重新扫描热更新程序集，生成link.xml以保留热更新代码中用到的类型。请运行完该命令后重新构建一次新包，否则运行下一步的热更新代码时会出现GameObject::.ctor函数找不到的错误。</p>
</blockquote>
<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>在 Unity 中，<strong>代码裁剪</strong> 是指通过 IL2CPP 或 Mono 的 <code>Managed Stripping Level</code> 设置，在构建过程中剔除未使用的代码和类型，以减小包体积。然而，这种优化可能会错误地移除在代码中未直接引用的类型或成员，但它们可能通过反射或其他动态调用方式在运行时需要使用。</p>
<p>你提到的问题是：</p>
<ol>
<li>未使用 <code>GameObject</code> 类的代码路径被裁剪：由于在热更新程序集（通常是指通过 HybridCLR 等热更新解决方案的管理代码）中没有显式引用 <code>GameObject</code> 类型及其构造函数，Unity 在打包过程中将其裁剪。</li>
<li><strong>热更新运行时报错</strong>：当热更新逻辑试图动态创建 <code>GameObject</code>（例如调用 <code>new GameObject()</code>）时，会抛出 <code>GameObject::.ctor</code> 找不到的错误。</li>
</ol>
<p>为了解决这个问题，HybridCLR 提供了一种方式来扫描热更新程序集并生成 <code>link.xml</code> 文件，该文件用于显式声明哪些类型或成员需要保留，防止被裁剪。</p>
<hr>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>以下是对 HybridCLR 解决方案以及相关步骤的详细讲解：</p>
<h4 id="1-HybridCLR-Generate-All-命令"><a href="#1-HybridCLR-Generate-All-命令" class="headerlink" title="1. HybridCLR&#x2F;Generate&#x2F;All 命令"></a>1. <strong>HybridCLR&#x2F;Generate&#x2F;All 命令</strong></h4><p>此命令的作用是扫描你的热更新程序集，分析代码中动态使用的类型和成员，生成一个 <code>link.xml</code> 文件。<br><code>link.xml</code> 是 Unity 提供的一个配置文件，用于手动指定哪些类型或成员需要在裁剪过程中保留。</p>
<ul>
<li><strong>HybridCLR 特性</strong>：它可以更智能地分析热更新程序集，自动添加需要的类型。</li>
<li><strong>生成后的内容</strong>：<code>link.xml</code> 会包含类似以下内容：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">linker</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">&quot;UnityEngine&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">&quot;UnityEngine.GameObject&quot;</span> <span class="attr">preserve</span>=<span class="string">&quot;all&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">linker</span>&gt;</span></span><br></pre></td></tr></table></figure>
这表明 <code>GameObject</code> 类型及其所有成员都不会被裁剪。</li>
</ul>
<h4 id="2-重新构建包"><a href="#2-重新构建包" class="headerlink" title="2. 重新构建包"></a>2. <strong>重新构建包</strong></h4><p>生成 <code>link.xml</code> 后，重新构建一次项目：</p>
<ul>
<li>构建的过程会读取 <code>link.xml</code> 文件，确保裁剪器不会移除你在热更新代码中需要的类型和方法。</li>
<li>如果不重新构建，旧包中依然会存在被裁剪的问题。</li>
</ul>
<h4 id="3-动态调用的类型声明"><a href="#3-动态调用的类型声明" class="headerlink" title="3. 动态调用的类型声明"></a>3. <strong>动态调用的类型声明</strong></h4><p>即使你的代码没有直接使用 <code>GameObject</code>，比如通过反射或字符串名称创建实例（<code>Activator.CreateInstance(&quot;GameObject&quot;)</code>），<code>link.xml</code> 也能确保这些动态调用所需的类型不会被移除。</p>
<hr>
<h3 id="运行步骤"><a href="#运行步骤" class="headerlink" title="运行步骤"></a>运行步骤</h3><ol>
<li>确保你的热更新代码中显式或隐式引用了需要保留的类型。例如：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> GameObject(); <span class="comment">// 确保 GameObject 被显式使用</span></span><br></pre></td></tr></table></figure></li>
<li>运行 <code>HybridCLR/Generate/All</code>：<ul>
<li>打开 Unity 菜单：<code>HybridCLR</code> &gt; <code>Generate</code> &gt; <code>All</code>。</li>
<li>等待生成完成。</li>
</ul>
</li>
<li>检查生成的 <code>link.xml</code> 文件：<ul>
<li>路径通常位于 <code>Assets/HybridCLR/Linker/link.xml</code>。</li>
<li>确认文件中包含类似以下内容：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">&quot;UnityEngine.GameObject&quot;</span> <span class="attr">preserve</span>=<span class="string">&quot;all&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>构建新包：<ul>
<li>通过 <code>File</code> &gt; <code>Build Settings</code> &gt; <code>Build</code> 或者运行构建脚本，生成新的包。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ol>
<li><p><strong>动态调用的预防措施</strong>：<br>如果你的热更新代码通过反射、字符串或其他方式调用 <code>GameObject</code>，需要确保这些类型明确添加到 <code>link.xml</code>，否则仍然可能被裁剪。</p>
</li>
<li><p><strong>测试热更新逻辑</strong>：<br>在构建包后，测试是否能正确运行热更新逻辑。建议在开发模式下运行热更新代码进行验证。</p>
</li>
<li><p><strong>裁剪级别设置</strong>：<br>如果你不希望裁剪器过于激进，可以降低 <code>Managed Stripping Level</code> 设置：</p>
<ul>
<li>路径：<code>Edit</code> &gt; <code>Project Settings</code> &gt; <code>Player</code> &gt; <code>Other Settings</code> &gt; <code>Managed Stripping Level</code>。</li>
<li>设置为 <code>Low</code>，确保更多类型保留。</li>
</ul>
</li>
</ol>
<p>通过这些步骤，你可以有效避免热更新中 <code>GameObject</code> 类型丢失的问题。</p>
<h3 id="代码裁剪相关问题"><a href="#代码裁剪相关问题" class="headerlink" title="代码裁剪相关问题"></a>代码裁剪相关问题</h3><p>Unity使用了代码裁剪技术来帮助减少il2cpp backend的包体大小。如果未做防裁剪处理，由于AOT主工程里的代码一般不多，大量的C#类型和函数被 裁剪，导致热更新中调用这些被裁剪类或函数出现如下异常：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型缺失错误</span></span><br><span class="line">Unity: TypeLoadException: Could <span class="keyword">not</span> load type <span class="string">&#x27;Xxx&#x27;</span> <span class="keyword">from</span> assembly <span class="string">&#x27;yyy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数缺失错误</span></span><br><span class="line">MissingMethodException: xxxx</span><br></pre></td></tr></table></figure>
<p>解决办法:</p>
<blockquote>
<p>根据日志错误日志确定哪个类型或函数被裁减，在link.xml里保留这个类型或函数，或者在主工程里显式地加上对这些类或函数的调用。 如果不熟悉如何在link.xml保留这个类型或函数，请参阅代码裁剪。</p>
</blockquote>
<p>但这种办法终究很麻烦，实际项目中有大量被裁剪的类型，你一遍遍地进行”打包-类型缺失-补充-打包”的操作， 浪费了太多时间。 com.code-philosophy.hybridclr 包提供了一个便捷的菜单命令HybridCLR&#x2F;Generate&#x2F;LinkXml， 能一键生成热更新工程里的所有AOT类型及函数引用。</p>
<p>警告:</p>
<blockquote>
<p>注意，如果你主工程中没有引用过某个程序集的任何代码，即使在link.xml中保留，该程序集也会被完全裁剪。因此对于每个要保留的AOT程序集， 请确保在主工程代码中显式引用过它的某个类或函数。</p>
</blockquote>
<h4 id="AOT类型及函数预留"><a href="#AOT类型及函数预留" class="headerlink" title="AOT类型及函数预留"></a>AOT类型及函数预留</h4><p>com.code-philosophy.hybridclr的HybridCLR&#x2F;Generate&#x2F;LinkXml命令虽然可以智能地扫描出你当前引用的AOT类型，却不能预知你未来将来使用的 类型。因此你仍然需要有规划地提前在 Assets&#x2F;link.xml(注意！不是自动生成的那个link.xml)预留你将来 可能用到的类型。切记不要疏漏，免得出现上线后某次更新使用的类型被裁剪的尴尬状况！</p>
<h2 id="增量构建"><a href="#增量构建" class="headerlink" title="增量构建"></a><a target="_blank" rel="noopener" href="https://docs.unity3d.com/2022.3/Documentation/Manual/incremental-build-pipeline.html">增量构建</a></h2><p>支持版本</p>
<ul>
<li>2021.3</li>
<li>2022.3</li>
<li>Unity 6</li>
</ul>
<h2 id="将脚本挂载到热更新资源"><a href="#将脚本挂载到热更新资源" class="headerlink" title="将脚本挂载到热更新资源"></a>将脚本挂载到热更新资源</h2><p>由于Unity资源管理系统的限制，热更新脚本所挂载的资源（prefab、scene、ScriptableObject资源）必须打成assetbundle，从ab包中实例化资源，才能正确还原脚本。</p>
<blockquote>
<p>如果将热更新脚本挂载到Resources等随主包的资源上，会发生scripting missing的错误！但如果先打成assetbundle包，再放到Resources下，运行时加载该随包assetbundle则没有问题。</p>
</blockquote>
<blockquote>
<p>挂载热更新脚本的资源（场景或prefab）必须打包成ab，在实例化资源前先加载热更新dll即可（这个要求是显然的！）。</p>
</blockquote>
<h2 id="热更代码中使用AOT中定义的泛型类或函数【方案】（补充元数据）"><a href="#热更代码中使用AOT中定义的泛型类或函数【方案】（补充元数据）" class="headerlink" title="热更代码中使用AOT中定义的泛型类或函数【方案】（补充元数据）"></a>热更代码中使用AOT中定义的泛型类或函数【方案】<a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/beginner/generic">（补充元数据）</a></h2><p>参考手册：<a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/aotgeneric#%E4%BC%98%E5%8C%96%E8%A1%A5%E5%85%85%E5%85%83%E6%95%B0%E6%8D%AEdll%E5%A4%A7%E5%B0%8F">AOT 泛型</a></p>
<blockquote>
<p>补充元数据技术的缺陷是增大了包体或者需要额外下载补充元数据dll，导致工作流复杂一些，另外还多占用了内存。</p>
</blockquote>
<h3 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h3><p><strong>背景：</strong> 如果AOT中没有实例化过某个AOT泛型类或者函数，泛型参数有可能是热更新类型，不可能在AOT中提前实例化。例如你在热更新代码中定义了 struct MyVector3 {int x, y, z;}，你不可能在AOT中提前实例化List<MyVector3>。</MyVector3></p>
<p>以下是一个示例，通过代码展示了在 <strong>AOT 模式下</strong>，如果未提前实例化泛型类或函数，当泛型参数为热更新代码定义的类型时会出现问题，以及如何通过 <strong>HybridCLR</strong> 解决这个问题。</p>
<p><strong>为什么泛型类在 AOT 中定义？</strong></p>
<blockquote>
<p>在 AOT 编译模式下，泛型类型的处理与普通类型不同。泛型类型（如 List<T> 或自定义的 MyVector3）是 参数化类型，它们的实际类型（例如 List<MyVector3>）需要在编译时确定。由于 AOT 编译 是提前进行的，因此在代码编译阶段，AOT 编译器需要知道所有泛型类型的完整定义。</MyVector3></T></p>
</blockquote>
<p><strong>具体原因：</strong></p>
<ul>
<li><p>泛型类型的元数据必须预先定义：AOT 编译的目标是生成机器代码，因此所有的类型和类型参数必须在编译时完全确定。由于泛型类型在运行时可能会有不同的类型参数（例如 List<MyVector3>），AOT 编译器必须提前知道每种类型的结构，以便生成正确的机器码。</MyVector3></p>
</li>
<li><p>热更新程序集中的泛型类型需要在 AOT 中补充元数据：假设你在热更新程序集中使用了 List<MyVector3> 和 MyVector3，虽然你在热更新程序集里声明了这些类型，但它们本身是 依赖于AOT编译时的泛型类型定义 的。为了保证在热更新过程中这些类型能够正确识别和操作，必须将它们的元数据（例如类型信息、泛型参数等）传递给 AOT 编译器，以便它能够为不同的类型生成代码和元数据。</MyVector3></p>
</li>
</ul>
<hr>
<h3 id="示例问题描述"><a href="#示例问题描述" class="headerlink" title="示例问题描述"></a><strong>示例问题描述</strong></h3><p>假设我们在 <strong>AOT 项目代码</strong> 中未显式实例化泛型类 <code>List&lt;T&gt;</code>，而在热更新代码中定义了一个新类型 <code>MyVector3</code>，并尝试使用 <code>List&lt;MyVector3&gt;</code>。因为 <strong>AOT 编译器</strong>无法预测 <code>MyVector3</code> 的存在，运行时会报错或崩溃。</p>
<hr>
<h3 id="AOT-项目代码（主工程代码）"><a href="#AOT-项目代码（主工程代码）" class="headerlink" title="AOT 项目代码（主工程代码）"></a><strong>AOT 项目代码（主工程代码）</strong></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Main Program Running&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟加载热更新代码</span></span><br><span class="line">        LoadHotfixCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadHotfixCode</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 假设这是热更新代码的入口，动态加载并执行热更新逻辑</span></span><br><span class="line">        HotfixEntry.Execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="热更新代码（需要-HybridCLR-支持）"><a href="#热更新代码（需要-HybridCLR-支持）" class="headerlink" title="热更新代码（需要 HybridCLR 支持）"></a><strong>热更新代码（需要 HybridCLR 支持）</strong></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyVector3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyVector3</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span> z</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span> =&gt; <span class="string">$&quot;(<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>, <span class="subst">&#123;z&#125;</span>)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HotfixEntry</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hotfix Code Running&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义热更新类型 MyVector3</span></span><br><span class="line">        List&lt;MyVector3&gt; myVectorList = <span class="keyword">new</span> List&lt;MyVector3&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试向 List&lt;MyVector3&gt; 中添加数据</span></span><br><span class="line">        myVectorList.Add(<span class="keyword">new</span> MyVector3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        myVectorList.Add(<span class="keyword">new</span> MyVector3(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> vec <span class="keyword">in</span> myVectorList)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Vector: <span class="subst">&#123;vec&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p><strong>报错：</strong></p>
<blockquote>
<p>MissingMethodException: AOT generic method not instantiated in aot. assembly:mscorlib.dll, method:System.Void System.Collections.Generic.List&#96;1[MyVector3]::Add(MyVector3)</p>
</blockquote>
<p><code>注意</code>:<br><strong>AOT 程序集通过反射加载过的类，AOT 会提前生成该类的泛型代码，故这种情况不受影响。</strong></p>
<h2 id="配置热更新程序集"><a href="#配置热更新程序集" class="headerlink" title="配置热更新程序集"></a>配置热更新程序集</h2><h3 id="HybridCLR-中的这三个程序集列表"><a href="#HybridCLR-中的这三个程序集列表" class="headerlink" title="HybridCLR 中的这三个程序集列表"></a><code>HybridCLR</code> 中的这三个程序集列表</h3><ol>
<li><p><strong>Hot Update Assembly Definitions</strong><br>这个列表通常是用于配置哪些 <strong>程序集定义（Assembly Definitions）</strong> 被标记为 <strong>热更新程序集</strong>。在 Unity 中，<strong>程序集定义</strong> 是用于组织和管理脚本程序集的资源。热更新程序集是指那些你希望通过 <code>HybridCLR</code> 框架进行动态加载和热更新的程序集。</p>
<ul>
<li><strong>作用</strong>：你可以在这里指定哪些程序集定义需要参与热更新。通常，你会在这些程序集定义中包含热更新代码（例如，游戏的业务逻辑代码）。</li>
</ul>
</li>
<li><p><strong>Hot Update Assemblies</strong><br>这个列表用于列出需要通过 <strong>热更新机制</strong> 加载的实际 <strong>程序集</strong>。这些程序集会包含你游戏的更新代码，并且通过 <code>HybridCLR</code> 可以在运行时加载。你可能会使用这些程序集来改变游戏的行为、修复 bug 或新增功能，而不需要重新构建整个游戏。</p>
<ul>
<li><strong>作用</strong>：列出你所有的热更新程序集。你会将包含热更新代码的 DLL 文件添加到这个列表，以便在游戏运行时进行动态加载和更新。</li>
</ul>
</li>
<li><p><strong>Preserve Hot Update Assemblies</strong><br>这个列表是用来列出那些 <strong>需要保留的热更新程序集</strong>。保留的热更新程序集通常是指那些需要在热更新过程中始终保留的程序集，可能包含关键的基础功能代码或在更新后不需要改变的部分。</p>
<ul>
<li><strong>作用</strong>：确保这些程序集在热更新过程中不被修改或删除。一般来说，这些程序集包含的是核心功能，确保它们不被意外删除或替换。</li>
</ul>
</li>
</ol>
<h3 id="配置程序集"><a href="#配置程序集" class="headerlink" title="配置程序集"></a>配置程序集</h3><p>一般来说，必须将热更新代码独立为assembly，才能方便地进行热更新。</p>
<h4 id="程序集分类"><a href="#程序集分类" class="headerlink" title="程序集分类"></a>程序集分类</h4><ol>
<li><p>Assembly Definition定义的程序集<br>这是Unity推荐的程序集方式。将一个大的Unity项目代码拆分为多个程序集模块，便于管理，缩短编译时间。</p>
</li>
<li><p>Assembly-CSharp 程序集</p>
</li>
</ol>
<p>这是Unity的默认全局程序集。它可以像普通dll一样当作热更新程序集。</p>
<ol>
<li>普通的dll程序集<br>一些代码被提前编译成dll文件，再移到项目中。</li>
</ol>
<h4 id="划分程序集"><a href="#划分程序集" class="headerlink" title="划分程序集"></a>划分程序集</h4><p>很显然，项目代码必须合理拆分为AOT（即编译到游戏主包内）程序集 和 热更新程序集，才能进行热更新。HybridCLR对于 怎么拆分程序集并无任何限制，甚至可以把第三方工程中的代码作为热更新程序集。一般来说，游戏刚启动时，至少需要一个AOT程序集来负责启动及热更新相关工作。</p>
<p>常见的拆分方式有几种：</p>
<ul>
<li>Assembly-CSharp作为AOT程序集。剩余代码自己拆分为N个AOT程序集和M个热更新程序集。</li>
<li>Assembly-CSharp作为热更新程序集。剩余代码自己拆分为N个AOT程序集和M个热更新程序集。</li>
</ul>
<p>无论哪种拆分方式，正确设置好程序集之间的引用关系即可。请不要在AOT程序集中引用热更新程序集，这会导致打包出错。如果 你们项目把Assembly-CSharp作为AOT程序集，强烈建议关闭热更新程序集的auto reference选项。因为Assembly-CSharp是最顶层assembly，它会自动引用剩余所有assembly，很容易就出现失误引用热更新程序集的情况。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>点击菜单 HybridCLR&#x2F;Settings 打开配置界面。</p>
<ul>
<li>如果是Assembly Definition(asmdef)方式定义的程序集，加入hotUpdateAssemblyDefinitions</li>
<li>如果是普通dll或者Assembly-CSharp.dll，则将程序集名字（不包含’.dll’后缀，如Main、Assembly-CSharp）加入hotUpdateAssemblies。</li>
</ul>
<p>hotUpdateAssemblyDefinitions和hotUpdateAssemblies列表是等价的，不要重复添加，否则会报错。</p>
<h2 id="关闭-Automatic-References-属性"><a href="#关闭-Automatic-References-属性" class="headerlink" title="关闭 Automatic References 属性"></a>关闭 <strong>Automatic References 属性</strong></h2><p>在 <strong>HybridCLR</strong> 的环境中，<strong>热更新程序集</strong>（Hotfix Assembly）关闭 <strong><code>Automatic References</code> 属性</strong> 主要是为了避免某些潜在的问题和确保热更新模块的正确性与独立性。这里的原因可以从多个角度来分析：</p>
<h3 id="1-避免不必要的程序集引用"><a href="#1-避免不必要的程序集引用" class="headerlink" title="1. 避免不必要的程序集引用"></a>1. <strong>避免不必要的程序集引用</strong></h3><ul>
<li><strong>热更新程序集</strong> 本身是为了动态更新程序中的部分逻辑而设计的。其目的是提供灵活的修改和补充功能，而不是依赖于编辑时的静态程序集（例如 <code>Assembly-CSharp.dll</code>）。</li>
<li>如果开启 <code>Automatic References</code>，热更新程序集可能会自动引入一些不必要的引用（例如 Unity 的核心引擎程序集或其他不需要的程序集），这会导致热更新代码与编辑时程序集产生依赖关系，从而影响热更新的独立性和模块化。</li>
</ul>
<h3 id="2-防止与AOT代码的冲突"><a href="#2-防止与AOT代码的冲突" class="headerlink" title="2. 防止与AOT代码的冲突"></a>2. <strong>防止与AOT代码的冲突</strong></h3><ul>
<li><strong>HybridCLR</strong> 中的热更新代码通常是通过 IL2CPP 和 AOT（Ahead Of Time Compilation）编译的。在这种环境下，AOT 编译时要求所有热更新程序集（例如脚本中的类和方法）在编译时能够被解析和实例化。</li>
<li>如果启用 <code>Automatic References</code>，热更新程序集可能会依赖于一些 AOT 编译的程序集（例如 <code>UnityEngine.dll</code>），这些程序集在编译时可能已经包含了大量的代码和类型信息，这会导致热更新程序集在运行时无法正确解析，甚至引发 <code>MissingMethodException</code> 或类型冲突。</li>
</ul>
<h3 id="3-控制热更新程序集的引用"><a href="#3-控制热更新程序集的引用" class="headerlink" title="3. 控制热更新程序集的引用"></a>3. <strong>控制热更新程序集的引用</strong></h3><ul>
<li>热更新程序集应该是一个相对独立的模块，只依赖于最基本的运行时环境和一些必要的外部程序集（例如 <code>mscorlib</code> 或者 Unity 的基本组件），而不是直接依赖于 Unity 编辑器中的程序集。</li>
<li>关闭 <code>Automatic References</code> 可以帮助开发者更好地控制热更新程序集所依赖的内容，确保它只依赖于真正需要的程序集，而不会误引入不必要的依赖，保持热更新代码的轻量性和灵活性。</li>
</ul>
<h3 id="4-解决程序集大小与热更新性能问题"><a href="#4-解决程序集大小与热更新性能问题" class="headerlink" title="4. 解决程序集大小与热更新性能问题"></a>4. <strong>解决程序集大小与热更新性能问题</strong></h3><ul>
<li>通过关闭 <code>Automatic References</code>，可以避免自动引用一些不必要的程序集，这有助于减小热更新程序集的大小，提高热更新代码的加载和执行效率。</li>
<li>如果 <code>Automatic References</code> 被启用，Unity 会尝试自动为热更新程序集添加大量的引用，可能会导致程序集膨胀，从而增加热更新时加载和反射的开销。</li>
</ul>
<h3 id="5-避免热更新与编辑时环境的耦合"><a href="#5-避免热更新与编辑时环境的耦合" class="headerlink" title="5. 避免热更新与编辑时环境的耦合"></a>5. <strong>避免热更新与编辑时环境的耦合</strong></h3><ul>
<li>热更新程序集应该是可以独立于编辑时环境进行更新和运行的。启用 <code>Automatic References</code> 会使热更新程序集与 Unity 编辑器及其工具链产生耦合，使得它们在运行时也依赖于编辑时的程序集，这会限制热更新的灵活性和可移植性。</li>
<li>关闭 <code>Automatic References</code> 可以保证热更新程序集的独立性，不会受到编辑时环境的影响，确保它在不同平台、不同构建环境下的兼容性。</li>
</ul>
<h3 id="6-避免潜在的热更新类型与-AOT-类型冲突"><a href="#6-避免潜在的热更新类型与-AOT-类型冲突" class="headerlink" title="6. 避免潜在的热更新类型与 AOT 类型冲突"></a>6. <strong>避免潜在的热更新类型与 AOT 类型冲突</strong></h3><ul>
<li>由于热更新程序集中的类型可能会被编译为 AOT 类型，若这些类型与 <code>Automatic References</code> 自动引入的程序集中的类型存在冲突或重名，可能会导致运行时错误。</li>
<li>通过关闭 <code>Automatic References</code>，开发者可以避免这类潜在冲突，确保热更新代码与 AOT 环境中的类型完全隔离。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在 <strong>HybridCLR</strong> 环境中，关闭热更新程序集的 <strong><code>Automatic References</code></strong> 属性有助于：</p>
<ol>
<li><strong>提高热更新代码的独立性</strong>，避免与编辑时环境的程序集产生依赖关系。</li>
<li><strong>避免不必要的程序集引用</strong>，减小热更新程序集的大小和加载开销。</li>
<li><strong>确保与 AOT 代码的兼容性</strong>，避免因引用冲突或类型实例化问题导致的运行时错误。</li>
<li><strong>提升热更新的性能</strong>，减少不必要的反射和程序集加载时间。</li>
</ol>
<p>因此，关闭 <code>Automatic References</code> 是一种确保热更新模块在 <strong>HybridCLR</strong> 环境中能够正确、独立运行的做法，能够保证热更新系统的稳定性和灵活性。</p>
<h2 id="加载更新assembly"><a href="#加载更新assembly" class="headerlink" title="加载更新assembly"></a><a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/runhotupdatecodes">加载更新assembly</a></h2><ul>
<li>通过反射直接运行热更新函数</li>
<li>通过反射创造出Delegate后运行</li>
<li>通过反射创建出对象后，再调用接口函数</li>
<li>通过动态AddComponent运行脚本代码</li>
<li><code>推荐</code> 通过初始化从打包成assetbundle的prefab或者scene还原挂载的热更新脚本(这种方法不需要借助任何反射，而且跟原生的启动流程相同，推荐使用这种方式<strong>初始化热更新入口代码</strong>！)</li>
</ul>
<h2 id="打包工作流"><a href="#打包工作流" class="headerlink" title="打包工作流"></a>打包工作流</h2><p>由于热更新本身的要求以及Unity资源管理的一些限制，对打包工作流需要一些特殊处理，主要分为几部分：</p>
<ul>
<li>设置UNITY_IL2CPP_PATH环境变量</li>
<li>打包时自动排除热更新assembly</li>
<li>打包时将热更新dll名添加到assembly列表</li>
<li>将打包过程中生成的裁剪后的aot dll拷贝出来，供补充元数据使用</li>
<li>编译热更新dll</li>
<li>生成一些打包需要的文件和代码</li>
<li>iOS平台的特殊处理</li>
</ul>
<h3 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h3><ul>
<li>运行菜单 HybridCLR&#x2F;Generate&#x2F;All 一键执行必要的生成操作</li>
<li>将HybridCLRData&#x2F;HotUpdateDlls下的热更新dll添加到项目的热更新资源管理系统</li>
<li>将HybridCLRData&#x2F;AssembliesPostIl2CppStrip下的补充元数据 dll添加到项目的热更新资源管理系统</li>
<li>根据你项目原来的打包流程打包</li>
</ul>
<h2 id="安卓打包流程优化（耗时）"><a href="#安卓打包流程优化（耗时）" class="headerlink" title="安卓打包流程优化（耗时）"></a>安卓打包流程优化（耗时）</h2><ul>
<li>运行 HybridCLR&#x2F;Generate&#x2F;LinkXml</li>
<li>导出工程</li>
<li>运行 HybridCLR&#x2F;Generate&#x2F;Il2cppDef</li>
<li>运行 HybridCLR&#x2F;Generate&#x2F;MethodBridge生成桥接函数</li>
<li>运行 HybridCLR&#x2F;Generate&#x2F;PReverseInvokeWrapper。 不需要与lua之类交互的项目可跳过此步。</li>
<li>将 {proj}\HybridCLRData\LocalIl2CppData-{platform}\il2cpp\libil2cpp\hybridclr\generated目录 替换导出工程中的此目录。</li>
<li>在导出工程上执行build</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/buildpipeline#ios%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86">ios处理参考该链接</a></p>
<p><a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/basic/buildwebgl">build webgl</a></p>
<h3 id="脚本后端"><a href="#脚本后端" class="headerlink" title="脚本后端"></a><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/scripting-backends.html">脚本后端</a></h3><p> “后端” 并不是指服务器端，而是指 Unity 引擎中的编译和执行环境。在 Unity 中，尤其是在涉及到 IL2CPP 和 HybridCLR 的开发时，”后端” 是指你应用程序代码的 <strong>编译方式</strong> 和 <strong>执行方式</strong>。“后端” 指的其实是你选择的 C# 代码运行的环境。具体来说：</p>
<ul>
<li>IL2CPP（Intermediate Language to C++） 是 Unity 的一个脚本后端，它将 C# 脚本代码转换成 C++ 代码，再通过 C++ 编译器生成原生机器码。</li>
<li>Mono 是另一种脚本后端，它直接通过 Mono 虚拟机运行 C# 代码。</li>
</ul>
<h3 id="1-什么是“导出工程”？"><a href="#1-什么是“导出工程”？" class="headerlink" title="1. 什么是“导出工程”？"></a>1. <strong>什么是“导出工程”？</strong></h3><p>“导出工程”在这里指的是从 Unity 编辑器生成的项目文件（或者构建出的本地工程）的一部分。在 Unity 中使用 <strong>HybridCLR</strong> 时，尤其是在 IL2CPP 后端模式下，通常需要与 Unity 的原生代码交互，生成相应的工程文件，以便进行后续的构建和修改。</p>
<p>具体来说，<strong>导出工程</strong> 就是使用 <strong>IL2CPP</strong> 脚本后端编译时，Unity 会生成一份包含 C++ 代码和相关文件的工程，这个工程是你用来编译和生成最终的原生平台（如 iOS 或 Android）程序的基础。</p>
<h3 id="2-具体流程解释"><a href="#2-具体流程解释" class="headerlink" title="2. 具体流程解释"></a>2. <strong>具体流程解释</strong></h3><h4 id="2-1-运行-HybridCLR-Generate-LinkXml"><a href="#2-1-运行-HybridCLR-Generate-LinkXml" class="headerlink" title="2.1 运行 HybridCLR/Generate/LinkXml"></a>2.1 <strong>运行 <code>HybridCLR/Generate/LinkXml</code></strong></h4><p><code>LinkXml</code> 生成的作用是 <strong>生成 IL2CPP 的链接配置</strong>，它用于指示 IL2CPP 编译器哪些类、方法和属性需要保留下来。在 IL2CPP 构建过程中，IL2CPP 会进行代码裁剪（linking），只保留实际使用到的代码。<code>LinkXml</code> 允许你保留特定的代码段（例如热更新相关的代码）。</p>
<ul>
<li><strong>目的</strong>：确保热更新的代码（如热更新 DLL 中的类和方法）不会在 IL2CPP 编译时被裁剪掉。</li>
<li><strong>输出</strong>：生成一个 <code>link.xml</code> 文件，里面定义了需要保留的类和方法。</li>
</ul>
<h4 id="2-2-导出工程"><a href="#2-2-导出工程" class="headerlink" title="2.2 导出工程"></a>2.2 <strong>导出工程</strong></h4><p>“导出工程”通常指的是从 Unity 项目中 <strong>构建出一个原生的工程文件</strong>，通常是 <strong>C++ 工程</strong>，用于 iOS 或 Android 等平台，依赖于 IL2CPP 编译后生成的代码。这个步骤通过 Unity 编辑器构建项目，生成适合平台的本地工程文件。</p>
<ul>
<li><strong>Unity 编辑器操作</strong>：选择适合的平台（如 iOS、Android），然后执行 <strong>Build</strong> 或 <strong>Export</strong> 操作，生成一个本地平台的工程文件（如 iOS 的 Xcode 工程或 Android 的 CMake 工程）。</li>
</ul>
<h4 id="2-3-运行-HybridCLR-Generate-Il2cppDef"><a href="#2-3-运行-HybridCLR-Generate-Il2cppDef" class="headerlink" title="2.3 运行 HybridCLR/Generate/Il2cppDef"></a>2.3 <strong>运行 <code>HybridCLR/Generate/Il2cppDef</code></strong></h4><p><code>Il2cppDef</code> 主要的作用是生成与 IL2CPP 后端相关的代码定义文件。这些定义文件将帮助 HybridCLR 在 IL2CPP 编译的过程中与原生代码进行桥接。</p>
<ul>
<li><strong>目的</strong>：生成一些 C++ 定义，确保 HybridCLR 可以通过 IL2CPP 后端正确地与 C# 热更新代码进行交互。</li>
<li><strong>输出</strong>：生成 C++ 文件和定义，可能会被包含在后续的构建工程中。</li>
</ul>
<h4 id="2-4-运行-HybridCLR-Generate-MethodBridge"><a href="#2-4-运行-HybridCLR-Generate-MethodBridge" class="headerlink" title="2.4 运行 HybridCLR/Generate/MethodBridge"></a>2.4 <strong>运行 <code>HybridCLR/Generate/MethodBridge</code></strong></h4><p><code>MethodBridge</code> 会生成所谓的 <strong>桥接函数</strong>，这些桥接函数用于连接 IL2CPP 后端的 C++ 代码与 Unity 的 C# 代码。</p>
<ul>
<li><strong>目的</strong>：生成桥接函数代码，确保 C# 代码与原生 C++ 代码之间可以通过 IL2CPP 后端进行正确的调用。特别是 HybridCLR 使用这些桥接函数来调用热更新程序集中的方法。</li>
<li><strong>输出</strong>：生成 C++ 桥接函数文件，通常包括函数声明和实现。</li>
</ul>
<h4 id="2-5-运行-HybridCLR-Generate-PReverseInvokeWrapper（如果需要）"><a href="#2-5-运行-HybridCLR-Generate-PReverseInvokeWrapper（如果需要）" class="headerlink" title="2.5 运行 HybridCLR/Generate/PReverseInvokeWrapper（如果需要）"></a>2.5 <strong>运行 <code>HybridCLR/Generate/PReverseInvokeWrapper</code>（如果需要）</strong></h4><p><code>PReverseInvokeWrapper</code> 是用于生成 <strong>反向调用的包装函数</strong>。如果你的项目需要与如 Lua 等脚本语言交互（例如 Lua 调用 C# 代码），你需要这一步生成的代码。如果项目中不需要与 Lua 等脚本引擎交互，可以跳过这一步。</p>
<ul>
<li><strong>目的</strong>：生成允许脚本语言（如 Lua）调用 C# 热更新代码的包装函数。</li>
<li><strong>输出</strong>：生成 C++ 包装函数文件，这些文件通常会作为脚本语言与 C# 代码交互的中间桥梁。</li>
</ul>
<h4 id="2-6-替换生成的目录"><a href="#2-6-替换生成的目录" class="headerlink" title="2.6 替换生成的目录"></a>2.6 <strong>替换生成的目录</strong></h4><p>你需要将生成的文件替换到 <strong>导出工程</strong> 中的相应目录，这些文件是由 HybridCLR 的生成工具（如 <code>MethodBridge</code> 和 <code>PReverseInvokeWrapper</code>）生成的。具体步骤如下：</p>
<ul>
<li>找到 <code>HybridCLRData/LocalIl2CppData-&#123;platform&#125;/il2cpp/libil2cpp/hybridclr/generated</code> 目录。</li>
<li>将该目录中的文件复制到导出工程中的相应目录中。</li>
</ul>
<p>这一步的目的是确保 HybridCLR 生成的代码（如桥接函数、反向调用包装函数等）已经被包含在导出工程中，以便后续的编译和构建。</p>
<h4 id="2-7-在导出工程上执行-build"><a href="#2-7-在导出工程上执行-build" class="headerlink" title="2.7 在导出工程上执行 build"></a>2.7 <strong>在导出工程上执行 build</strong></h4><p>最后一步是 <strong>在导出工程中进行构建</strong>。你需要通过构建工具（如 Xcode 或 Android Studio）编译并生成最终的应用程序。这一步将会使用 HybridCLR 生成的代码与热更新 DLL 进行链接，构建出最终的原生应用。</p>
<ul>
<li><strong>构建操作</strong>：使用 Xcode（对于 iOS）或 Android Studio（对于 Android）对导出的工程进行编译和构建，生成最终的 APK 或 IPA 文件。</li>
<li><strong>输出</strong>：最终的应用程序包（如 APK 文件或 IPA 文件），该文件包含了 IL2CPP 后端生成的本地代码和 HybridCLR 的热更新功能。</li>
</ul>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. <strong>总结</strong></h3><p>整个流程大致上是为了支持在 IL2CPP 构建环境下的热更新功能，特别是在 Unity 使用 HybridCLR 进行热更新时，涉及到以下几个关键步骤：</p>
<ol>
<li><strong>生成 IL2CPP 配置和定义文件</strong>，确保热更新代码不被裁剪。</li>
<li><strong>导出本地工程</strong>，生成适合目标平台的 C++ 工程。</li>
<li><strong>生成桥接函数和反向调用包装函数</strong>，让 C# 热更新代码与原生代码正确交互。</li>
<li><strong>替换和整合生成的文件</strong>，确保生成的代码被正确集成到导出的工程中。</li>
<li><strong>编译和构建</strong>，生成最终的应用程序包，支持热更新功能。</li>
</ol>
<p>“导出工程”是指生成适用于目标平台的 C++ 工程文件，这个文件在后续的构建和部署过程中起到至关重要的作用。</p>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a><a target="_blank" rel="noopener" href="https://hybridclr.doc.code-philosophy.com/docs/help/commonerrors">常见错误</a></h2><h2 id="在GameObject上Add热更新脚本或者在资源上直接挂载-热更新脚本"><a href="#在GameObject上Add热更新脚本或者在资源上直接挂载-热更新脚本" class="headerlink" title="在GameObject上Add热更新脚本或者在资源上直接挂载 热更新脚本"></a>在GameObject上Add热更新脚本或者在资源上直接挂载 热更新脚本</h2><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>AddComponent<T>()或者AddComponent(Type type)任何时候都是完美支持的。只需要提前通过Assembly.Load将热更新dll加载到运行时 内即可。</T></p>
<h3 id="在资源上挂载热更新脚本"><a href="#在资源上挂载热更新脚本" class="headerlink" title="在资源上挂载热更新脚本"></a>在资源上挂载热更新脚本</h3><p>Unity资源管理系统在反序列化资源中的热更新脚本时，需要满足以下条件：</p>
<ul>
<li>脚本所在的dll已经加载到运行时中</li>
<li>必须是使用AssetBundle打包的资源（addressable之类间接使用了ab的框架也可以）</li>
<li>你需要把项目中的热更新assembly添加到HybridCLRSettings配置的HotUpdateAssemblyDefinitions或HotUpdateAssemblies 字段中。</li>
</ul>
<p>只限制了热更新资源以ab包形式打包，热更新dll打包方式没有限制。你可以按照项目需求自由选择热更新方式，可以将dll打包到ab中，或者裸数据 文件，或者加密压缩等等。只要能保证在加载热更新资源前使用Assembly.Load将其加载即可。</p>
<p><strong>危险</strong></p>
<blockquote>
<p>如果将热更新脚本挂载到Resources等随主包的资源上，会发生scripting missing的错误！但如果先打成assetbundle包，再放到Resources下，运行时加载该随包assetbundle则没有问题。</p>
</blockquote>
<h3 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h3><h4 id="主线程AddComponent及其他资源加载线程加载包含热更新脚本的资源同时进行时偶发的崩溃问题"><a href="#主线程AddComponent及其他资源加载线程加载包含热更新脚本的资源同时进行时偶发的崩溃问题" class="headerlink" title="主线程AddComponent及其他资源加载线程加载包含热更新脚本的资源同时进行时偶发的崩溃问题"></a>主线程AddComponent及其他资源加载线程加载包含热更新脚本的资源同时进行时偶发的崩溃问题</h4><p>此问题来自issue报告。</p>
<p>在第一次使用某热更新类型时（主线程AddComponent或者资源线程加载含脚本的资源）会触发引擎创建MonoScript数据，然而此操作并非线程安全。由于未接入hybridclr时，所有脚本都在启动时已经初始化，因此不会有线程安全问题。当接入hybridclr后，在偶然情况下（尤其是加载包含大量脚本的资源）会触发这个问题。</p>
<blockquote>
<p><strong>解决办法如下：</strong></p>
</blockquote>
<p><strong>执行时机：</strong></p>
<p>该解决方案应该在 热更新程序集加载之后 执行，确保所有热更新类型已经被加载到内存中，但还没有被主线程或资源线程使用。具体来说，它应该在以下几个时机执行：</p>
<ul>
<li>热更新程序集加载完成之后，即热更新相关的脚本已经被加载到内存，但并没有立即被用于 AddComponent 或者其他操作。</li>
<li>加载包含热更新脚本的资源之前，以确保在加载资源时，所有的 MonoBehaviour 类型已经在主线程上完成初始化，避免在其他线程上并发调用这些脚本时发生崩溃。<br>加载完热更新程序集后，通过临时创建的GameObject,把所有热更新脚本都添加一遍，类似这样：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> go = <span class="keyword">new</span> GameObject();</span><br><span class="line"><span class="comment">// 我们不希望挂载到这个GameObject上的脚本执行</span></span><br><span class="line">go.Active = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> type <span class="keyword">in</span> hotUpdateAss.GetTypes())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span>(MonoBehaviour).IsAssignFrom(type))</span><br><span class="line">    &#123;</span><br><span class="line">        go.AddComponent(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">GameObject.Destroy(go);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="建议打AB时不要禁用TypeTree"><a href="#建议打AB时不要禁用TypeTree" class="headerlink" title="建议打AB时不要禁用TypeTree"></a>建议打AB时不要禁用TypeTree</h4><p>需要被挂到资源上的脚本所在dll名称上线后勿修改，因为assembly列表文件打包后无法修改。</p>
<p>建议打AB时不要禁用TypeTree，否则普通的AB加载方式会失败。（原因是对于禁用TypeTree的脚本，Unity为了防止二进制不匹配导致反序列化MonoBehaviour过程中进程Crash，会对脚本的签名进行校验，签名的内容是脚本FullName及TypeTree数据生成的Hash, 但由于我们的热更脚本信息不存在于打包后的安装包中，因此校验必定会失败）</p>
<p>如果必须要禁用TypeTree，一个变通的方法是禁止脚本的Hash校验, 此种情况下用户必须保证打包时代码与资源版本一致，否则可能会导致Crash，示例代码</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AssetBundleCreateRequest req = AssetBundle.LoadFromFileAsync(path);</span><br><span class="line">req.SetEnableCompatibilityChecks(<span class="literal">false</span>); <span class="comment">// 非public，需要通过反射调用</span></span><br></pre></td></tr></table></figure>


<p>禁用 <code>TypeTree</code> 的行为是一个比较敏感的操作，特别是在 Asset Bundle（AB）打包和热更新的场景中。<code>TypeTree</code> 是 Unity 用于确保反序列化过程中的类型匹配性和安全性的工具，而禁用它可能会导致一些潜在的反序列化错误或崩溃，尤其是在更新脚本时。因此，禁用 <code>TypeTree</code> 需要特别小心。</p>
<h3 id="如何禁用-TypeTree"><a href="#如何禁用-TypeTree" class="headerlink" title="如何禁用 TypeTree"></a>如何禁用 TypeTree</h3><p>根据您的需求，禁用 <code>TypeTree</code> 的一个常见方法是通过 <strong>AssetBundleCreateRequest</strong> 的 <code>SetEnableCompatibilityChecks</code> 方法。这实际上是禁用 Unity 对于脚本的签名校验，从而跳过了 <code>TypeTree</code> 的检查。</p>
<h4 id="示例代码：通过反射禁用-TypeTree-校验"><a href="#示例代码：通过反射禁用-TypeTree-校验" class="headerlink" title="示例代码：通过反射禁用 TypeTree 校验"></a>示例代码：通过反射禁用 TypeTree 校验</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DisableTypeTreeExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> path = <span class="string">&quot;path/to/your/assetbundle&quot;</span>; <span class="comment">// 你的AB包路径</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载AB包</span></span><br><span class="line">        AssetBundleCreateRequest req = AssetBundle.LoadFromFileAsync(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用反射禁用脚本的Hash校验</span></span><br><span class="line">        MethodInfo setEnableCompatibilityChecks = <span class="keyword">typeof</span>(AssetBundleCreateRequest).GetMethod(<span class="string">&quot;SetEnableCompatibilityChecks&quot;</span>, BindingFlags.NonPublic | BindingFlags.Instance);</span><br><span class="line">        <span class="keyword">if</span> (setEnableCompatibilityChecks != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            setEnableCompatibilityChecks.Invoke(req, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="literal">false</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们通过反射调用了 <code>AssetBundleCreateRequest.SetEnableCompatibilityChecks(false)</code> 来禁用 <code>TypeTree</code> 校验。这意味着您可以绕过类型校验和 <code>TypeTree</code> 校验，但这样做的风险在于如果后续资源和代码的版本不一致，可能会导致 <strong>崩溃</strong> 或 <strong>错误加载</strong>。</p>
<h3 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h3><ol>
<li><p><strong>热更新中的问题</strong>：<br>如果您使用热更新机制（比如 IL2CPP 编译的程序集），禁用 <code>TypeTree</code> 校验可能导致 Unity 在加载和反序列化脚本时无法匹配类型。这是因为禁用 <code>TypeTree</code> 后，Unity 无法验证加载的脚本的类型信息，从而可能会导致加载错误或进程崩溃。</p>
</li>
<li><p><strong>资源和脚本版本一致性</strong>：<br>禁用 <code>TypeTree</code> 校验后，必须确保您打包的资源与实际运行的脚本版本一致。否则，当脚本和资源版本不匹配时，Unity 会在加载时崩溃。特别是对于热更新项目，您需要手动确保脚本的版本与 AB 包中包含的资源一致。</p>
</li>
<li><p><strong>适用场景</strong>：<br>禁用 <code>TypeTree</code> 通常是在一些特殊情况下使用，比如当您无法确保资源和脚本版本一致时，但如果您的热更新脚本没有包含在 AB 包中，这会导致校验失败。除非有很强的需求，否则一般不推荐在生产环境中禁用 <code>TypeTree</code>。</p>
</li>
</ol>
<h3 id="如何查看-TypeTree-是否被禁用"><a href="#如何查看-TypeTree-是否被禁用" class="headerlink" title="如何查看 TypeTree 是否被禁用"></a>如何查看 <code>TypeTree</code> 是否被禁用</h3><p>Unity 并没有提供直接查看 <code>TypeTree</code> 是否被禁用的界面，您只能通过以下方式间接判断：</p>
<ol>
<li><p><strong>日志检查</strong>：<br>如果禁用了 <code>TypeTree</code> 校验，并且存在版本不匹配的情况，Unity 会在加载 AB 包时抛出错误或者崩溃。因此，可以通过查看 Unity 的日志文件（<code>Editor.log</code> 或 <code>Player.log</code>）来确定是否发生了类型不匹配的错误。</p>
</li>
<li><p><strong>Asset Bundle 加载失败</strong>：<br>如果 <code>TypeTree</code> 校验被禁用，且脚本与资源版本不匹配，加载 AB 包时可能会导致反序列化错误。您可以通过在加载时检查 <code>AssetBundle</code> 是否加载成功来推测是否存在 <code>TypeTree</code> 校验问题。</p>
</li>
</ol>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**禁用 <code>TypeTree</code>**：通过调用 <code>AssetBundleCreateRequest.SetEnableCompatibilityChecks(false)</code> 来禁用校验，但这会导致脚本与资源版本不一致时可能崩溃，且通常不推荐在生产环境中使用。</li>
<li><strong>风险</strong>：禁用 <code>TypeTree</code> 校验会导致加载脚本时无法检查类型匹配，可能会引发反序列化错误。</li>
<li><strong>使用场景</strong>：一般仅在确保代码和资源版本完全一致的情况下使用，或在特定的热更新流程中使用。</li>
</ul>
<p>如果您决定使用这种方式禁用 <code>TypeTree</code> 校验，请务必保证脚本和资源的版本严格同步，以避免加载失败或崩溃。</p>
<h2 id="Unity打包AB时禁用TypeTree的优缺点"><a href="#Unity打包AB时禁用TypeTree的优缺点" class="headerlink" title="Unity打包AB时禁用TypeTree的优缺点"></a>Unity打包AB时禁用TypeTree的优缺点</h2><p><strong>禁用TypeTree</strong> 是 Unity 打包 AssetBundle 时一个常用的优化选项，它可以有效减小包体大小，提升加载速度。但同时也会带来一些限制和潜在问题。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li><strong>减小包体大小：</strong> TypeTree 存储了资源的类型信息，禁用它可以显著减小 AssetBundle 的体积，从而加快下载和加载速度。</li>
<li><strong>提升加载速度：</strong> 由于 TypeTree 信息的缺失，Unity 在加载 AssetBundle 时不需要解析 TypeTree，从而减少了 CPU 消耗，提高了加载速度。</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><strong>兼容性问题：</strong><ul>
<li><strong>不同 Unity 版本：</strong> 在不同版本的 Unity 中，TypeTree 的结构可能会有变化。如果禁用 TypeTree，高版本 Unity 可能无法正确加载低版本打包的 AssetBundle。</li>
<li><strong>自定义类型：</strong> 如果项目中使用了自定义类型，禁用 TypeTree 后，这些自定义类型的序列化和反序列化可能会出现问题。</li>
</ul>
</li>
<li><strong>调试困难：</strong> 在没有 TypeTree 的情况下，调试 AssetBundle 加载问题会变得更加困难。</li>
<li><strong>无法热更新脚本：</strong> 禁用 TypeTree 后，Unity 在加载 AssetBundle 时会对脚本进行签名校验，如果脚本内容发生变化，就无法热更新。</li>
<li><strong>Editor 下使用受限：</strong> 在 Editor 环境下，如果 AssetBundle 禁用了 TypeTree，有些功能可能无法正常工作，比如使用 AssetDatabase 加载 AssetBundle。</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li><strong>移动端游戏：</strong> 对于移动端游戏来说，包体大小和加载速度是至关重要的。如果项目对包体大小要求较高，并且不涉及频繁的热更新，可以考虑禁用 TypeTree。</li>
<li><strong>静态资源：</strong> 对于一些不会经常更新的静态资源，禁用 TypeTree 可以有效减小包体大小。</li>
</ul>
<h3 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h3><ul>
<li><strong>频繁热更新的项目：</strong> 如果项目需要频繁地热更新脚本或资源，禁用 TypeTree 会带来很大的限制。</li>
<li><strong>自定义类型较多的项目：</strong> 如果项目中使用了大量的自定义类型，禁用 TypeTree 后可能会导致序列化和反序列化问题。</li>
<li><strong>对调试要求较高的项目：</strong> 如果项目需要频繁地调试 AssetBundle 加载问题，禁用 TypeTree 会增加调试难度。</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>禁用 TypeTree 可以有效减小包体大小和提升加载速度，但同时也带来了一些限制和潜在问题。在决定是否禁用 TypeTree 时，需要综合考虑项目的具体情况，权衡优缺点。</p>
<p><strong>建议：</strong></p>
<ul>
<li><strong>谨慎使用：</strong> 在正式发布之前，一定要对禁用 TypeTree 的 AssetBundle 进行充分的测试，确保其在目标平台上能够正常运行。</li>
<li><strong>分包处理：</strong> 可以将经常更新的资源和静态资源分开放到不同的 AssetBundle 中，对于经常更新的资源可以保留 TypeTree，而对于静态资源可以禁用 TypeTree。</li>
<li><strong>考虑其他优化方式：</strong> 除了禁用 TypeTree，还可以通过压缩纹理、优化模型、减少冗余资源等方式来减小包体大小。</li>
</ul>
<p><strong>总结来说，禁用 TypeTree 是一项需要谨慎使用的优化手段，并不是适用于所有项目。</strong></p>
<h2 id="桥接函数"><a href="#桥接函数" class="headerlink" title="桥接函数"></a>桥接函数</h2><p><code>HybridCLR</code> 是一个为 Unity 提供的跨平台热更新框架，它允许在 Unity 中动态加载和执行 C# 代码。其核心目标是支持游戏在运行时进行热更新，而无需重新编译或重新启动游戏应用。在此框架中，桥接函数（Bridge Functions）扮演着非常关键的角色。</p>
<h3 id="桥接函数的作用"><a href="#桥接函数的作用" class="headerlink" title="桥接函数的作用"></a>桥接函数的作用</h3><p>在 HybridCLR 的上下文中，桥接函数主要用于以下目的：</p>
<ol>
<li><p><strong>跨平台调用管理</strong>：在 Unity 的不同平台（如 Android、iOS、Windows 等）之间进行桥接，确保可以在不同平台上调用并执行相同的代码。由于每个平台对底层操作系统的访问方式不同，桥接函数提供了一种通用接口，将平台特定的操作抽象化，从而使代码更具可移植性。</p>
</li>
<li><p><strong>C# 与原生代码的交互</strong>：游戏中的部分原生功能（如底层的性能优化、平台特定的 API）需要调用 C++ 或其他原生代码，而桥接函数则充当了 C# 和原生代码之间的桥梁。这种桥接使得 C# 代码可以通过 <code>P/Invoke</code> 或其他类似的机制与 C++ 代码进行交互，避免了传统开发中可能出现的复杂性。</p>
</li>
<li><p><strong>热更新时的接口绑定</strong>：当进行热更新时，Unity 项目中的 C# 代码会被动态加载和执行。为了使热更新后的代码能够正确与 Unity 引擎或其他底层系统交互，桥接函数负责在运行时动态绑定和调用接口，使得热更新代码能够在新的环境中顺利运行。</p>
</li>
<li><p><strong>优化性能</strong>：桥接函数有助于将一些高频调用或资源密集型的操作迁移到更底层的原生代码中处理，而不是全部依赖于 C# 代码，从而提高性能。</p>
</li>
</ol>
<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>通过桥接函数，HybridCLR 解决了以下几个问题：</p>
<ol>
<li><p><strong>平台兼容性</strong>：通过提供一个统一的桥接层，解决了不同平台之间因调用底层 API 的差异所带来的问题，使得热更新代码能够跨平台运行。</p>
</li>
<li><p><strong>C# 与底层代码的交互</strong>：原生代码和 C# 代码之间的交互是 Unity 开发中的一个挑战。桥接函数简化了这部分操作，允许开发者在热更新中无缝调用底层系统。</p>
</li>
<li><p><strong>避免重新编译</strong>：通过热更新机制，可以动态加载修改后的 C# 代码，而无需重新编译整个项目。桥接函数确保修改后的代码与底层系统仍然能够正常交互。</p>
</li>
</ol>
<p>总之，桥接函数是 HybridCLR 提供的一个重要机制，它使得 Unity 开发者能够在热更新过程中保持对底层系统的访问，并且解决了平台差异和性能优化等问题。</p>
<p><code>HybridCLR</code> 的桥接函数是实现 Unity 热更新的一个关键技术，能够使得 C# 代码和原生代码（如 C++）之间进行高效的交互。它的工作原理和流程涉及到一些复杂的技术，尤其是在动态加载、平台兼容性和性能优化方面。下面我会详细解释它是如何参与这些工作、背后的原理，以及整个工作流程。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li><p><strong>C# 和原生代码之间的桥接</strong><br>在 Unity 中，游戏项目通常使用 C# 编写业务逻辑，但有时需要与底层的原生代码（例如 C++ 或平台特定的原生库）进行交互。传统上，这种交互通过平台调用（P&#x2F;Invoke）或 <code>DllImport</code> 来完成，但这在动态加载和热更新的场景中会变得非常复杂。<code>HybridCLR</code> 桥接函数通过以下方式来解决这一问题：</p>
<ul>
<li><strong>原生函数封装</strong>：HybridCLR 会将原生函数封装为统一的桥接接口。这样，无论是热更新时调用的 C# 代码，还是 Unity 本身的 C++ 引擎代码，都能通过这个桥接函数进行通信。</li>
<li><strong>动态链接</strong>：当热更新代码被加载时，桥接函数会动态地加载和链接原生代码库，以确保 C# 代码能与原生代码进行正确的调用。</li>
</ul>
</li>
<li><p><strong>运行时绑定与反射</strong></p>
<ul>
<li><strong>动态绑定</strong>：桥接函数通常通过反射机制在运行时绑定方法。比如，当某个热更新的 C# 代码尝试调用一个底层的原生函数时，<code>HybridCLR</code> 会查找相应的桥接函数并在运行时将它与原生代码的实现连接起来。这样就避免了在编译时必须静态绑定的问题。</li>
<li><strong>元数据生成</strong>：在热更新过程中，HybridCLR 会生成一些元数据，用来描述 C# 代码和原生代码之间的映射关系。这个元数据在桥接过程中非常重要，它帮助系统动态地将 C# 方法与底层的原生方法进行映射。</li>
</ul>
</li>
<li><p><strong>跨平台支持</strong></p>
<ul>
<li><strong>统一接口</strong>：HybridCLR 为不同的平台提供了统一的桥接接口。即使在不同平台上，底层代码可能会有所不同，但通过桥接函数，C# 代码始终可以通过相同的接口进行调用，<code>HybridCLR</code> 会根据目标平台的不同加载不同的底层实现。</li>
<li><strong>平台适配</strong>：当热更新代码运行在不同的平台时，桥接函数能够根据平台的不同适配不同的原生接口或函数，确保跨平台兼容性。</li>
</ul>
</li>
<li><p><strong>性能优化</strong></p>
<ul>
<li><strong>原生调用</strong>：有些性能要求高的操作可能需要通过原生代码来实现，这时桥接函数允许 C# 代码通过调用原生代码来实现性能优化。</li>
<li><strong>减少开销</strong>：桥接函数在调用原生代码时会尽量减少开销。例如，减少不必要的参数传递，避免频繁的反射调用，或者将一些调用迁移到异步线程来避免阻塞主线程。</li>
</ul>
</li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li><p><strong>热更新代码加载</strong><br>在热更新过程中，<code>HybridCLR</code> 会加载修改后的 C# 程序集，并将其加载到 Unity 引擎中。这些程序集可以是动态编译的，通常使用 <code>DLL</code> 文件的形式。当这些代码加载后，系统会扫描并生成相应的元数据和映射表。</p>
</li>
<li><p><strong>桥接函数注册</strong><br>在加载过程中，<code>HybridCLR</code> 会注册所有需要桥接的函数。例如，C# 代码中的某个方法需要调用底层 C++ 函数，那么这个方法就会通过桥接函数与相应的原生方法进行关联。此时，<code>HybridCLR</code> 会为这些桥接函数建立一对一的映射。</p>
</li>
<li><p><strong>热更新中的方法调用</strong><br>一旦热更新代码加载并注册了桥接函数，当 C# 代码执行时，如果需要调用原生方法，<code>HybridCLR</code> 会通过运行时反射和动态链接来调用相应的桥接函数。这些桥接函数会根据需要将请求转发给底层的原生实现，确保原生代码正确执行并返回结果。</p>
</li>
<li><p><strong>跨平台切换</strong><br>如果你的游戏在多个平台上运行（如 Android、iOS、Windows 等），<code>HybridCLR</code> 会根据当前运行的平台选择适当的桥接实现。例如，Android 可能通过 JNI 调用 C++ 代码，而 iOS 可能通过 Objective-C 桥接与 C++ 交互。<code>HybridCLR</code> 会根据平台自动加载和切换这些不同的实现，确保跨平台兼容。</p>
</li>
<li><p><strong>性能监控与优化</strong><br><code>HybridCLR</code> 的桥接函数还可以参与性能监控。当系统检测到某些原生代码的调用耗时过长，或者需要进行性能优化时，桥接函数会在运行时进行优化，减少性能开销，确保热更新和底层代码交互时的高效性。</p>
</li>
</ol>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>HybridCLR</code> 桥接函数的核心原理是通过动态链接、反射和跨平台适配技术，使得 C# 代码能够与底层原生代码高效、安全地交互。它提供了一个统一的接口来管理不同平台间的差异，使得热更新后的 C# 代码可以在各种设备上平稳运行，而无需进行复杂的编译和部署。桥接函数的动态绑定、元数据生成和性能优化策略使得 <code>HybridCLR</code> 成为一个强大的热更新工具。</p>
<h2 id="资源更新判断"><a href="#资源更新判断" class="headerlink" title="资源更新判断"></a>资源更新判断</h2><p>在游戏热更新过程中，判断客户端是否拥有最新代码和资源是关键的一步。通常会通过以下步骤实现版本检查和更新机制：</p>
<hr>
<h3 id="1-使用版本号或版本文件进行比较"><a href="#1-使用版本号或版本文件进行比较" class="headerlink" title="1. 使用版本号或版本文件进行比较"></a><strong>1. 使用版本号或版本文件进行比较</strong></h3><h4 id="资源版本管理"><a href="#资源版本管理" class="headerlink" title="资源版本管理"></a><strong>资源版本管理</strong></h4><ul>
<li><p>每次更新代码或资源时，生成一个 <strong>版本号</strong>（如 <code>v1.0</code>、<code>v1.1</code>）或 <strong>版本文件</strong>。</p>
</li>
<li><p>版本文件通常是一个 JSON 或 TXT 文件，记录当前资源的版本号或资源的文件校验信息，例如：</p>
<p><strong>版本文件示例（<code>version.json</code>）：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;assetBundles&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;character_assets.ab&quot;</span><span class="punctuation">:</span> <span class="string">&quot;f2a29d0c08f2c4a3d1d7ec5b6e8b8a34&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;environment_assets.ab&quot;</span><span class="punctuation">:</span> <span class="string">&quot;e1d4f7600c1f7b4a9e5f9e2b123f9a8d&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>流程：</strong></p>
<ol>
<li>客户端在启动时，向服务器请求最新的 <code>version.json</code>。</li>
<li>比较本地的版本号和服务器的版本号：<ul>
<li>如果版本号相同，则无需更新。</li>
<li>如果版本号不同，则需要下载新的资源。</li>
</ul>
</li>
<li>对于每个资源文件，可以通过文件名或校验值（如 MD5&#x2F;SHA256）来确认文件是否需要更新。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-文件校验（哈希值校验）"><a href="#2-文件校验（哈希值校验）" class="headerlink" title="2. 文件校验（哈希值校验）"></a><strong>2. 文件校验（哈希值校验）</strong></h3><p>通过计算文件的校验值（如 MD5、SHA256），判断本地资源是否和服务器上的一致：</p>
<h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a><strong>服务器端</strong></h4><ul>
<li>每次打包后，计算每个资源文件的 MD5 哈希值，并将这些值记录到版本文件中：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;character_assets.ab&quot;</span><span class="punctuation">:</span> <span class="string">&quot;f2a29d0c08f2c4a3d1d7ec5b6e8b8a34&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;environment_assets.ab&quot;</span><span class="punctuation">:</span> <span class="string">&quot;e1d4f7600c1f7b4a9e5f9e2b123f9a8d&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><strong>客户端</strong></h4><ul>
<li>客户端计算本地资源文件的 MD5 值，与服务器的值进行对比：<ul>
<li>如果一致，则无需更新。</li>
<li>如果不一致，则需要下载对应资源。</li>
</ul>
</li>
</ul>
<p><strong>C# 示例：计算文件的 MD5</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Security.Cryptography;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetMD5Hash</span>(<span class="params"><span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> md5 = MD5.Create())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> stream = File.OpenRead(filePath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> hash = md5.ComputeHash(stream);</span><br><span class="line">            <span class="keyword">return</span> BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLowerInvariant();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-热更新流程"><a href="#3-热更新流程" class="headerlink" title="3. 热更新流程"></a><strong>3. 热更新流程</strong></h3><p>以下是一个完整的热更新流程设计：</p>
<h4 id="1-检查版本文件"><a href="#1-检查版本文件" class="headerlink" title="1. 检查版本文件"></a><strong>1. 检查版本文件</strong></h4><ul>
<li>客户端在启动时请求服务器的版本文件（如 <code>version.json</code>）。</li>
</ul>
<h4 id="2-比较版本号"><a href="#2-比较版本号" class="headerlink" title="2. 比较版本号"></a><strong>2. 比较版本号</strong></h4><ul>
<li>如果客户端的版本号小于服务器的版本号：<ul>
<li>下载新的资源列表文件或版本文件。</li>
</ul>
</li>
</ul>
<h4 id="3-校验资源"><a href="#3-校验资源" class="headerlink" title="3. 校验资源"></a><strong>3. 校验资源</strong></h4><ul>
<li>对每个需要更新的资源文件进行哈希值比较。</li>
<li>如果资源文件不一致，下载对应文件并替换本地版本。</li>
</ul>
<h4 id="4-下载资源"><a href="#4-下载资源" class="headerlink" title="4. 下载资源"></a><strong>4. 下载资源</strong></h4><ul>
<li>客户端从服务器下载需要更新的资源（如 <code>.ab</code> 文件）。</li>
</ul>
<h4 id="5-替换资源"><a href="#5-替换资源" class="headerlink" title="5. 替换资源"></a><strong>5. 替换资源</strong></h4><ul>
<li>将下载的资源存储到指定路径，覆盖旧版本文件。</li>
<li>更新本地的版本文件。</li>
</ul>
<hr>
<h3 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a><strong>4. 示例代码</strong></h3><p>以下是一个热更新版本检查的示例代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Networking;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HotUpdateManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> serverVersionUrl = <span class="string">&quot;https://example.com/version.json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> localVersionPath = Application.persistentDataPath + <span class="string">&quot;/version.json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> serverAssetBaseUrl = <span class="string">&quot;https://example.com/assets/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Step 1: 获取服务器版本文件</span></span><br><span class="line">        UnityWebRequest request = UnityWebRequest.Get(serverVersionUrl);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> request.SendWebRequest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.result != UnityWebRequest.Result.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;Failed to fetch version.json: &quot;</span> + request.error);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> serverVersionContent = request.downloadHandler.text;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Server Version: &quot;</span> + serverVersionContent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 2: 检查本地版本文件</span></span><br><span class="line">        <span class="keyword">if</span> (!File.Exists(localVersionPath))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Local version.json not found, downloading all assets...&quot;</span>);</span><br><span class="line">            StartCoroutine(DownloadAllAssets(serverVersionContent));</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> localVersionContent = File.ReadAllText(localVersionPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 3: 比较版本号或文件哈希值</span></span><br><span class="line">        <span class="keyword">if</span> (serverVersionContent != localVersionContent)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Version mismatch, updating assets...&quot;</span>);</span><br><span class="line">            StartCoroutine(DownloadAllAssets(serverVersionContent));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Assets are up-to-date.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">DownloadAllAssets</span>(<span class="params"><span class="built_in">string</span> serverVersionContent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 假设服务器版本文件包含资源列表</span></span><br><span class="line">        <span class="keyword">var</span> versionData = JsonUtility.FromJson&lt;VersionData&gt;(serverVersionContent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> asset <span class="keyword">in</span> versionData.assetBundles)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> assetUrl = serverAssetBaseUrl + asset.Key;</span><br><span class="line">            <span class="built_in">string</span> localPath = Path.Combine(Application.persistentDataPath, asset.Key);</span><br><span class="line"></span><br><span class="line">            UnityWebRequest assetRequest = UnityWebRequest.Get(assetUrl);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> assetRequest.SendWebRequest();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (assetRequest.result == UnityWebRequest.Result.Success)</span><br><span class="line">            &#123;</span><br><span class="line">                File.WriteAllBytes(localPath, assetRequest.downloadHandler.data);</span><br><span class="line">                Debug.Log(<span class="string">$&quot;Downloaded: <span class="subst">&#123;asset.Key&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(<span class="string">$&quot;Failed to download: <span class="subst">&#123;asset.Key&#125;</span>, Error: <span class="subst">&#123;assetRequest.error&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存最新版本文件到本地</span></span><br><span class="line">        File.WriteAllText(localVersionPath, serverVersionContent);</span><br><span class="line">        Debug.Log(<span class="string">&quot;Assets updated successfully.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VersionData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> version;</span><br><span class="line">    <span class="keyword">public</span> System.Collections.Generic.Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; assetBundles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-注意事项-1"><a href="#5-注意事项-1" class="headerlink" title="5. 注意事项"></a><strong>5. 注意事项</strong></h3><ol>
<li><p><strong>CDN 缓存问题</strong>：</p>
<ul>
<li>如果资源托管在 CDN 上，确保启用强缓存控制（如 ETag 或版本号后缀）。</li>
</ul>
</li>
<li><p><strong>断点续传</strong>：</p>
<ul>
<li>对于大文件下载，可以实现断点续传功能，以防网络中断。</li>
</ul>
</li>
<li><p><strong>资源替换时机</strong>：</p>
<ul>
<li>确保在游戏加载完成或空闲时替换资源，避免资源被占用导致更新失败。</li>
</ul>
</li>
<li><p><strong>安全性</strong>：</p>
<ul>
<li>对下载的资源文件进行校验，防止中间人攻击或恶意篡改文件。</li>
</ul>
</li>
</ol>
<hr>
<p>通过这种方式，可以高效地判断客户端是否需要热更新，并确保资源和代码是最新版本。</p>
<h1 id="HybridCLR-是如何删除弃用的业务逻辑"><a href="#HybridCLR-是如何删除弃用的业务逻辑" class="headerlink" title="HybridCLR 是如何删除弃用的业务逻辑"></a>HybridCLR 是如何删除弃用的业务逻辑</h1><p>在 <strong>HybridCLR</strong> 的热更新机制下，C# 代码的更新是通过<strong>替换 DLL</strong> 来实现的，而不是像 Lua 那样直接修改脚本文件。因此，在<strong>删除废弃的业务逻辑</strong>时，需要从<strong>逻辑层面</strong>和<strong>文件层面</strong>两部分处理。</p>
<hr>
<h1 id="1-逻辑层面：卸载废弃的代码"><a href="#1-逻辑层面：卸载废弃的代码" class="headerlink" title="1. 逻辑层面：卸载废弃的代码"></a><strong>1. 逻辑层面：卸载废弃的代码</strong></h1><p>即使热更新加载了新版本的 DLL，旧版本的类、方法仍可能<strong>被引用或驻留在内存中</strong>，需要确保：</p>
<ol>
<li><strong>不再调用旧代码</strong></li>
<li><strong>清理旧 DLL 占用的资源</strong></li>
<li><strong>避免旧代码仍在运行</strong>（例如事件监听、线程、静态变量等）</li>
</ol>
<h3 id="（1）移除已加载的废弃类"><a href="#（1）移除已加载的废弃类" class="headerlink" title="（1）移除已加载的废弃类"></a><strong>（1）移除已加载的废弃类</strong></h3><p>HybridCLR 通过 <strong>Assembly.Load()</strong> 加载新的 DLL，默认情况下，<strong>已加载的类不会自动卸载</strong>。所以要确保：</p>
<ul>
<li><strong>不再引用废弃代码</strong></li>
<li><strong>手动移除相关的对象</strong></li>
</ul>
<p><strong>示例：清理废弃类</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让 C# 运行时不再持有旧逻辑的引用</span></span><br><span class="line">OldLogic.Instance = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="（2）清理静态变量-事件监听"><a href="#（2）清理静态变量-事件监听" class="headerlink" title="（2）清理静态变量 &amp; 事件监听"></a><strong>（2）清理静态变量 &amp; 事件监听</strong></h3><p>如果有<strong>静态变量</strong>持有废弃类的实例，必须手动清理：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OldLogic.StaticInstance = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>如果有<strong>事件监听</strong>，需要取消：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventManager.OnEvent -= OldLogic.HandleEvent;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="（3）释放旧-DLL"><a href="#（3）释放旧-DLL" class="headerlink" title="（3）释放旧 DLL"></a><strong>（3）释放旧 DLL</strong></h3><p>.NET Core&#x2F;Mono <strong>不支持卸载单个 DLL</strong>，但可以<strong>更换 AppDomain</strong> 来隔离和卸载：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 彻底卸载 HybridCLR 加载的所有热更 DLL</span></span><br><span class="line">HybridCLR.RuntimeApi.UnloadHotUpdateAssemblies();</span><br></pre></td></tr></table></figure>
<p>但 HybridCLR 目前 <strong>不支持完全卸载 DLL</strong>，如果有大版本更新，建议直接<strong>重启进程</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application.Quit();</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="2-文件层面：删除废弃的-DLL"><a href="#2-文件层面：删除废弃的-DLL" class="headerlink" title="2. 文件层面：删除废弃的 DLL"></a><strong>2. 文件层面：删除废弃的 DLL</strong></h1><p>HybridCLR 的热更 DLL 一般存放在 <strong>PersistentDataPath</strong> 目录，需要手动删除：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> oldDllPath = Path.Combine(Application.persistentDataPath, <span class="string">&quot;HotUpdate.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (File.Exists(oldDllPath))</span><br><span class="line">&#123;</span><br><span class="line">    File.Delete(oldDllPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 DLL 是从 <strong>远程服务器下载的</strong>，可以在更新时<strong>只下载新版本的 DLL</strong>，同时清理旧 DLL。</p>
<p><strong>示例：删除所有旧 DLL</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> hotfixPath = Path.Combine(Application.persistentDataPath, <span class="string">&quot;hotfix&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (Directory.Exists(hotfixPath))</span><br><span class="line">&#123;</span><br><span class="line">    Directory.Delete(hotfixPath, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="3-如何彻底卸载旧业务逻辑"><a href="#3-如何彻底卸载旧业务逻辑" class="headerlink" title="3. 如何彻底卸载旧业务逻辑"></a><strong>3. 如何彻底卸载旧业务逻辑</strong></h1><p><strong>如果 HybridCLR 不能卸载 DLL，怎样才能彻底移除旧代码？</strong></p>
<h3 id="方案-1：重启进程"><a href="#方案-1：重启进程" class="headerlink" title="方案 1：重启进程"></a><strong>方案 1：重启进程</strong></h3><p>由于 .NET 运行时不能单独卸载某个 DLL，<strong>最干净的做法</strong>是<strong>更新完成后，直接重启游戏</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application.Quit();  <span class="comment">// 退出游戏</span></span><br></pre></td></tr></table></figure>
<p>然后下次启动时，加载最新的 DLL，而不会保留旧逻辑。</p>
<hr>
<h3 id="方案-2：使用不同-Assembly-加载-DLL"><a href="#方案-2：使用不同-Assembly-加载-DLL" class="headerlink" title="方案 2：使用不同 Assembly 加载 DLL"></a><strong>方案 2：使用不同 Assembly 加载 DLL</strong></h3><p>HybridCLR <strong>支持加载多个版本的 DLL</strong>，可以：</p>
<ol>
<li><strong>每次热更加载不同的 DLL（如 <code>HotUpdate_v2.dll</code>）</strong></li>
<li><strong>旧 DLL 永远不会被新代码访问</strong></li>
<li><strong>新 DLL 替换旧逻辑后，旧 DLL 文件可删除</strong></li>
</ol>
<p>示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assembly = Assembly.Load(File.ReadAllBytes(<span class="string">&quot;HotUpdate_v2.dll&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>然后把旧 DLL 从 <code>PersistentDataPath</code> 中删除。</p>
<hr>
<h1 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a><strong>总结</strong></h1><table>
<thead>
<tr>
<th>操作</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>停止旧逻辑运行</strong></td>
<td>解除引用 (<code>OldLogic.Instance = null</code>)，取消事件监听</td>
</tr>
<tr>
<td><strong>清理静态变量</strong></td>
<td><code>OldLogic.StaticInstance = null;</code></td>
</tr>
<tr>
<td><strong>卸载热更 DLL</strong></td>
<td><code>HybridCLR.RuntimeApi.UnloadHotUpdateAssemblies();</code></td>
</tr>
<tr>
<td><strong>删除旧 DLL 文件</strong></td>
<td><code>File.Delete(path)</code></td>
</tr>
<tr>
<td><strong>彻底清除</strong></td>
<td><strong>重启游戏 (<code>Application.Quit()</code>)</strong></td>
</tr>
</tbody></table>
<p><strong>推荐方案</strong></p>
<ul>
<li><strong>小版本热更</strong>：用 <code>UnloadHotUpdateAssemblies()</code> 释放旧 DLL，并删除旧文件。</li>
<li><strong>大版本更新</strong>：直接 <code>Application.Quit()</code> 重启游戏，确保所有旧代码彻底清除。</li>
</ul>
<hr>
<p>你目前是想<strong>小规模热修</strong>（尽量不停游戏），还是<strong>大版本更新</strong>（可以重启）？</p>
<h1 id="划分程序集-1"><a href="#划分程序集-1" class="headerlink" title="划分程序集"></a>划分程序集</h1><p>在你的 <strong>游戏厅（Game Hub）</strong> 项目中，每个小游戏都可能是<strong>独立的业务模块</strong>，为了<strong>支持随时下架、更新或新增游戏</strong>，你需要合理划分 <strong>Assembly</strong> 并采用 <strong>插件式架构</strong>，使得每个游戏都可以<strong>独立加载、卸载</strong>，从而实现灵活管理。  </p>
<hr>
<h1 id="1-Assembly-划分方案"><a href="#1-Assembly-划分方案" class="headerlink" title="1. Assembly 划分方案"></a><strong>1. Assembly 划分方案</strong></h1><p>建议将项目拆分成多个 <strong>Assembly</strong>（DLL），核心划分如下：  </p>
<h3 id="（1）主程序-Assembly（GameHub-dll）"><a href="#（1）主程序-Assembly（GameHub-dll）" class="headerlink" title="（1）主程序 Assembly（GameHub.dll）"></a><strong>（1）主程序 Assembly（GameHub.dll）</strong></h3><ul>
<li>负责 <strong>游戏大厅的管理</strong>（UI、网络、用户数据、支付等）</li>
<li><strong>不会变动</strong>，不随小游戏更新而修改</li>
<li>只负责 <strong>加载&#x2F;卸载 子游戏 DLL</strong></li>
</ul>
<h3 id="（2）小游戏-Assembly（GameA-dll、GameB-dll…）"><a href="#（2）小游戏-Assembly（GameA-dll、GameB-dll…）" class="headerlink" title="（2）小游戏 Assembly（GameA.dll、GameB.dll…）"></a><strong>（2）小游戏 Assembly（GameA.dll、GameB.dll…）</strong></h3><ul>
<li><strong>每个游戏单独一个 DLL</strong>，如 <code>GameA.dll</code>、<code>GameB.dll</code></li>
<li>游戏代码、资源、逻辑<strong>完全封装</strong>在该 DLL 中</li>
<li>可以<strong>单独卸载、更新或删除</strong></li>
</ul>
<h3 id="（3）公共-Assembly（Common-dll）"><a href="#（3）公共-Assembly（Common-dll）" class="headerlink" title="（3）公共 Assembly（Common.dll）"></a><strong>（3）公共 Assembly（Common.dll）</strong></h3><ul>
<li>存放 <strong>共享逻辑、工具方法</strong></li>
<li>避免每个小游戏重复代码</li>
<li>例如：<ul>
<li><strong>网络通信模块</strong></li>
<li><strong>UI 基础组件</strong></li>
<li><strong>工具类（日志、数学计算等）</strong></li>
</ul>
</li>
</ul>
<p><strong>📌 关键点</strong>：</p>
<ul>
<li><strong>每个小游戏必须独立</strong>（即 <strong>不引用其他游戏</strong>，避免删除时影响其他游戏）。</li>
<li><strong>小游戏之间通过接口通信</strong>，而不是直接调用代码。</li>
</ul>
<hr>
<h1 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2. 具体实现"></a><strong>2. 具体实现</strong></h1><h3 id="（1）小游戏代码结构"><a href="#（1）小游戏代码结构" class="headerlink" title="（1）小游戏代码结构"></a><strong>（1）小游戏代码结构</strong></h3><p>示例：<code>GameA.dll</code>  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameA</span> : <span class="title">IGameModule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartGame</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Game A 启动&quot;</span>);</span><br><span class="line">        <span class="comment">// 游戏逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopGame</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Game A 结束&quot;</span>);</span><br><span class="line">        <span class="comment">// 清理资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）定义通用接口（GameHub-统一管理）"><a href="#（2）定义通用接口（GameHub-统一管理）" class="headerlink" title="（2）定义通用接口（GameHub 统一管理）"></a><strong>（2）定义通用接口（GameHub 统一管理）</strong></h3><h2 id="主程序-GameHub-dll-只认识-接口，不依赖具体游戏："><a href="#主程序-GameHub-dll-只认识-接口，不依赖具体游戏：" class="headerlink" title="主程序 GameHub.dll 只认识 接口，不依赖具体游戏："></a>主程序 <code>GameHub.dll</code> 只认识 <strong>接口</strong>，不依赖具体游戏：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IGameModule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StartGame</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StopGame</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h3 id="（3）动态加载游戏（按需加载-DLL）"><a href="#（3）动态加载游戏（按需加载-DLL）" class="headerlink" title="（3）动态加载游戏（按需加载 DLL）"></a><strong>（3）动态加载游戏（按需加载 DLL）</strong></h3><p><strong>📌 核心逻辑：</strong>  </p>
<ul>
<li><strong>GameHub.dll 负责加载&#x2F;卸载游戏</strong></li>
<li><strong>从 <code>PersistentDataPath</code> 读取新的游戏 DLL</strong></li>
<li><strong>实例化 <code>IGameModule</code>，运行游戏</strong></li>
</ul>
<h4 id="✅-加载游戏"><a href="#✅-加载游戏" class="headerlink" title="✅ 加载游戏"></a><strong>✅ 加载游戏</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IGameModule <span class="title">LoadGame</span>(<span class="params"><span class="built_in">string</span> gameName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> path = Path.Combine(Application.persistentDataPath, <span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!File.Exists(path))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="string">$&quot;找不到 <span class="subst">&#123;path&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">byte</span>[] dllBytes = File.ReadAllBytes(path);</span><br><span class="line">    Assembly assembly = Assembly.Load(dllBytes);</span><br><span class="line"></span><br><span class="line">    Type gameType = assembly.GetType(<span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>.GameMain&quot;</span>); <span class="comment">// 确保游戏类符合命名规则</span></span><br><span class="line">    <span class="keyword">if</span> (gameType == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span> 里没有 GameMain 类&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Activator.CreateInstance(gameType) <span class="keyword">as</span> IGameModule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✅-运行游戏"><a href="#✅-运行游戏" class="headerlink" title="✅ 运行游戏"></a><strong>✅ 运行游戏</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IGameModule currentGame = LoadGame(<span class="string">&quot;GameA&quot;</span>);</span><br><span class="line">currentGame?.StartGame();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="（4）删除-下架游戏"><a href="#（4）删除-下架游戏" class="headerlink" title="（4）删除&#x2F;下架游戏"></a><strong>（4）删除&#x2F;下架游戏</strong></h3><p>当 <strong>游戏下架</strong> 时，需要：</p>
<ol>
<li><strong>停止该游戏</strong></li>
<li><strong>卸载 DLL</strong></li>
<li><strong>删除文件</strong></li>
</ol>
<p><strong>✅ 停止游戏并清理</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentGame != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    currentGame.StopGame();</span><br><span class="line">    currentGame = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>✅ 删除 DLL 文件</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> gamePath = Path.Combine(Application.persistentDataPath, <span class="string">&quot;GameA.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (File.Exists(gamePath))</span><br><span class="line">&#123;</span><br><span class="line">    File.Delete(gamePath);</span><br><span class="line">    Debug.Log(<span class="string">&quot;GameA 已删除&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="⚠️-注意-由于-C-不支持卸载单个-DLL，建议：-加载时使用不同-Assembly，避免占用-删除后，建议重启游戏进程"><a href="#⚠️-注意-由于-C-不支持卸载单个-DLL，建议：-加载时使用不同-Assembly，避免占用-删除后，建议重启游戏进程" class="headerlink" title="⚠️ 注意- 由于 C# 不支持卸载单个 DLL，建议：  - 加载时使用不同 Assembly，避免占用  - 删除后，建议重启游戏进程
  "></a><strong>⚠️ 注意</strong><br>- 由于 C# <strong>不支持卸载单个 DLL</strong>，建议：<br>  - <strong>加载时使用不同 Assembly</strong>，避免占用<br>  - <strong>删除后，建议重启游戏进程</strong>
  </h2><h3 id="（5）游戏更新"><a href="#（5）游戏更新" class="headerlink" title="（5）游戏更新"></a><strong>（5）游戏更新</strong></h3><p><strong>1. 服务器推送新版本 <code>GameA_v2.dll</code></strong><br><strong>2. 替换 <code>GameA.dll</code> 并加载新 DLL</strong><br><strong>3. 调用 <code>StopGame()</code> 关闭旧版本</strong><br><strong>4. 重新加载新版本 <code>GameA</code> 并运行</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> oldPath = Path.Combine(Application.persistentDataPath, <span class="string">&quot;GameA.dll&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> newPath = Path.Combine(Application.persistentDataPath, <span class="string">&quot;GameA_v2.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (File.Exists(oldPath)) File.Delete(oldPath);</span><br><span class="line">File.Move(newPath, oldPath);</span><br><span class="line"></span><br><span class="line">IGameModule currentGame = LoadGame(<span class="string">&quot;GameA&quot;</span>);</span><br><span class="line">currentGame?.StartGame();</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="3-HybridCLR-支持点"><a href="#3-HybridCLR-支持点" class="headerlink" title="3. HybridCLR 支持点"></a><strong>3. HybridCLR 支持点</strong></h1><p><strong>HybridCLR 主要用于支持</strong>：</p>
<ol>
<li><strong>运行 IL2CPP 下的热更 C# 代码</strong></li>
<li><strong>动态加载 C# DLL</strong></li>
<li><strong>支持在 iOS&#x2F;Android&#x2F;WebGL 运行 C# 热更代码</strong></li>
</ol>
<p>你可以使用 HybridCLR <strong>动态加载和替换游戏 DLL</strong>，但要注意：</p>
<ul>
<li><strong>不支持完全卸载 DLL</strong>，所以游戏下架后<strong>最好重启进程</strong>清理内存。</li>
<li><strong>要确保新 DLL 兼容老的 <code>IGameModule</code> 接口</strong>，否则会崩溃。</li>
</ul>
<hr>
<h1 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h1><table>
<thead>
<tr>
<th>方案</th>
<th>方案描述</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>每个小游戏一个 DLL</strong></td>
<td>每个游戏 <code>GameA.dll</code>、<code>GameB.dll</code> 独立，主程序动态加载&#x2F;卸载</td>
<td>适合有多个小游戏、可随时更新</td>
</tr>
<tr>
<td><strong>统一管理接口 <code>IGameModule</code></strong></td>
<td>只在 <code>GameHub.dll</code> 里使用 <code>IGameModule</code>，防止硬编码依赖</td>
<td>让 <code>GameHub</code> 代码更稳定，减少改动</td>
</tr>
<tr>
<td><strong>热更新游戏</strong></td>
<td>服务器推送 <code>GameA_v2.dll</code>，删除 <code>GameA.dll</code>，然后重新加载</td>
<td>适合定期更新游戏内容</td>
</tr>
<tr>
<td><strong>下架游戏</strong></td>
<td><code>StopGame()</code> 清理资源，删除 <code>GameA.dll</code>，并建议重启游戏</td>
<td>适合游戏随时下架</td>
</tr>
</tbody></table>
<hr>
<h1 id="5-你接下来的问题"><a href="#5-你接下来的问题" class="headerlink" title="5. 你接下来的问题"></a><strong>5. 你接下来的问题</strong></h1><p>你是更关注 <strong>如何加载&#x2F;卸载 DLL</strong>，还是想了解 <strong>HybridCLR 在不同平台（iOS&#x2F;Android&#x2F;WebGL）的兼容性</strong>？</p>
<h1 id="公共程序集为啥不能与主程序集合并"><a href="#公共程序集为啥不能与主程序集合并" class="headerlink" title="公共程序集为啥不能与主程序集合并"></a>公共程序集为啥不能与主程序集合并</h1><h3 id="1-公共-Assembly-是否可以合并到主程序-Assembly？"><a href="#1-公共-Assembly-是否可以合并到主程序-Assembly？" class="headerlink" title="1. 公共 Assembly 是否可以合并到主程序 Assembly？"></a><strong>1. 公共 Assembly 是否可以合并到主程序 Assembly？</strong></h3><p><strong>✅ 可以合并</strong>，但不推荐，具体情况如下：  </p>
<table>
<thead>
<tr>
<th>方案</th>
<th>适用场景</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>合并到主程序 (GameHub.dll)</strong></td>
<td><strong>小型项目，功能较少</strong></td>
<td>结构简单，减少 DLL 数量</td>
<td>不能动态更新公共逻辑，每次修改都要重打主包</td>
</tr>
<tr>
<td><strong>独立公共 Assembly (Common.dll)</strong></td>
<td><strong>大型项目，多个游戏共享逻辑</strong></td>
<td>允许热更新公共代码，减少主程序改动</td>
<td>需要管理额外的 DLL</td>
</tr>
</tbody></table>
<p><strong>📌 建议</strong></p>
<ul>
<li><strong>如果项目较小（比如只有几个小游戏）</strong>，可以把 <strong>公共代码</strong> 合并到 <code>GameHub.dll</code>，减少 DLL 数量。</li>
<li><strong>如果项目较大（支持几十款游戏）</strong>，推荐<strong>拆分 <code>Common.dll</code><strong>，让公共逻辑独立，这样</strong>既能复用，也能热更新</strong>。</li>
</ul>
<hr>
<h3 id="2-Assembly-与-AssetBundle（AB-包）如何关联？"><a href="#2-Assembly-与-AssetBundle（AB-包）如何关联？" class="headerlink" title="2. Assembly 与 AssetBundle（AB 包）如何关联？"></a><strong>2. Assembly 与 AssetBundle（AB 包）如何关联？</strong></h3><p>在 <strong>Unity 资源管理</strong> 中，<code>Assembly</code>（DLL）和 <code>AssetBundle</code>（AB包）是 <strong>两个独立的概念</strong>，但可以<strong>配合使用</strong>。</p>
<h4 id="（1）如何关联？"><a href="#（1）如何关联？" class="headerlink" title="（1）如何关联？"></a><strong>（1）如何关联？</strong></h4><table>
<thead>
<tr>
<th>目标</th>
<th>方案</th>
</tr>
</thead>
<tbody><tr>
<td><strong>热更新代码</strong></td>
<td><strong>放入 <code>DLL</code>，用 HybridCLR 动态加载</strong></td>
</tr>
<tr>
<td><strong>热更新资源（Prefab、材质等）</strong></td>
<td><strong>打成 <code>AB包</code>，运行时下载 &amp; 加载</strong></td>
</tr>
</tbody></table>
<h4 id="（2）示例：游戏-GameA-结构"><a href="#（2）示例：游戏-GameA-结构" class="headerlink" title="（2）示例：游戏 GameA 结构"></a><strong>（2）示例：游戏 <code>GameA</code> 结构</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">📁 GameA 资源包</span><br><span class="line">├── GameA.dll            // 游戏代码</span><br><span class="line">├── GameA_Assets.ab      // 该游戏的资源（Prefab、材质）</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-具体如何管理-DLL-和-AB-包？"><a href="#3-具体如何管理-DLL-和-AB-包？" class="headerlink" title="3. 具体如何管理 DLL 和 AB 包？"></a><strong>3. 具体如何管理 DLL 和 AB 包？</strong></h3><p><strong>✅ 推荐管理方式：</strong></p>
<ol>
<li><strong>每个游戏一个 DLL + 一个 AB 包</strong></li>
<li><strong>服务器维护 <code>version.json</code> 文件，管理最新版本</strong></li>
<li><strong>客户端比对 <code>version.json</code>，决定是否下载更新</strong></li>
<li><strong>动态加载新 DLL 和 AB 包</strong></li>
</ol>
<hr>
<h3 id="4-AB-包与-DLL-的加载代码"><a href="#4-AB-包与-DLL-的加载代码" class="headerlink" title="4. AB 包与 DLL 的加载代码"></a><strong>4. AB 包与 DLL 的加载代码</strong></h3><p>📌 <strong>示例：同时加载 <code>GameA.dll</code> 和 <code>GameA_Assets.ab</code></strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">LoadGame</span>(<span class="params"><span class="built_in">string</span> gameName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> dllPath = Path.Combine(Application.persistentDataPath, <span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>.dll&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> abPath = Path.Combine(Application.persistentDataPath, <span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>_Assets.ab&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 先加载 DLL</span></span><br><span class="line">    <span class="built_in">byte</span>[] dllBytes = File.ReadAllBytes(dllPath);</span><br><span class="line">    Assembly assembly = Assembly.Load(dllBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 再加载 AB 包</span></span><br><span class="line">    AssetBundle ab = AssetBundle.LoadFromFile(abPath);</span><br><span class="line">    <span class="keyword">if</span> (ab == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="string">&quot;AB 包加载失败：&quot;</span> + abPath);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 实例化游戏主逻辑</span></span><br><span class="line">    Type gameType = assembly.GetType(<span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>.GameMain&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (gameType != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        IGameModule gameInstance = Activator.CreateInstance(gameType) <span class="keyword">as</span> IGameModule;</span><br><span class="line">        gameInstance?.StartGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-热更新时，如何删除废弃的-DLL-和-AB？"><a href="#5-热更新时，如何删除废弃的-DLL-和-AB？" class="headerlink" title="5. 热更新时，如何删除废弃的 DLL 和 AB？"></a><strong>5. 热更新时，如何删除废弃的 DLL 和 AB？</strong></h3><p>当游戏 <strong>下架</strong> 或 <strong>更新版本时</strong>，需要删除旧的 DLL 和 AB 文件：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeleteOldGame</span>(<span class="params"><span class="built_in">string</span> gameName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> dllPath = Path.Combine(Application.persistentDataPath, <span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>.dll&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> abPath = Path.Combine(Application.persistentDataPath, <span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>_Assets.ab&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(dllPath))</span><br><span class="line">    &#123;</span><br><span class="line">        File.Delete(dllPath);</span><br><span class="line">        Debug.Log(<span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>.dll 已删除&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(abPath))</span><br><span class="line">    &#123;</span><br><span class="line">        File.Delete(abPath);</span><br><span class="line">        Debug.Log(<span class="string">$&quot;<span class="subst">&#123;gameName&#125;</span>_Assets.ab 已删除&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h3><table>
<thead>
<tr>
<th>方案</th>
<th>是否推荐</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>公共 Assembly 合并到主程序</strong></td>
<td>❌ <strong>不推荐</strong></td>
<td>不能热更新公共逻辑，改动大</td>
</tr>
<tr>
<td><strong>公共 Assembly 独立 (<code>Common.dll</code>)</strong></td>
<td>✅ <strong>推荐</strong></td>
<td>允许热更新公共代码，减少主程序改动</td>
</tr>
<tr>
<td><strong>DLL 与 AB 包管理</strong></td>
<td>✅ <strong>推荐</strong></td>
<td><strong>游戏代码</strong>放 <code>DLL</code>，<strong>资源</strong>放 <code>AB</code>，分别热更新</td>
</tr>
<tr>
<td><strong>游戏下架时删除 <code>DLL + AB</code></strong></td>
<td>✅ <strong>推荐</strong></td>
<td>确保游戏<strong>彻底卸载</strong>，避免浪费存储</td>
</tr>
</tbody></table>
<p><strong>🔥 你可以根据项目大小选择合适的管理方式，整体来说独立 DLL 和 AB 包管理是最佳方案！</strong> 🚀</p>
<h1 id="热更新的最佳时机和界面选择"><a href="#热更新的最佳时机和界面选择" class="headerlink" title="热更新的最佳时机和界面选择"></a><strong>热更新的最佳时机和界面选择</strong></h1><p>在 Unity 使用 <strong>HybridCLR</strong> 进行热更新时，选择合适的更新时机和界面非常重要，否则可能导致<strong>游戏崩溃</strong>、<strong>逻辑异常</strong>或<strong>资源丢失</strong>。以下是最佳实践：</p>
<hr>
<h2 id="1-热更新的最佳时机"><a href="#1-热更新的最佳时机" class="headerlink" title="1. 热更新的最佳时机"></a><strong>1. 热更新的最佳时机</strong></h2><p>📌 <strong>建议在“非交互”状态下进行更新</strong>，避免玩家正在操作时导致异常：<br>✅ <strong>推荐的时机：</strong></p>
<ul>
<li><strong>游戏启动时</strong>（Splash&#x2F;Loading 界面）</li>
<li><strong>进入主界面前</strong>（下载完资源后进入大厅）</li>
<li><strong>玩家进入游戏前</strong>（在“游戏选择”界面检查更新）</li>
<li><strong>切换大场景时</strong>（如从大厅进入副本&#x2F;新地图）</li>
<li><strong>后台运行时</strong>（玩家暂时离开游戏）</li>
</ul>
<p>❌ <strong>避免在以下情况下更新：</strong></p>
<ul>
<li><strong>游戏进行中</strong>（玩家正在战斗、跑图时更新会导致闪退）</li>
<li><strong>正在加载资源时</strong>（影响加载稳定性）</li>
<li><strong>与服务器交互中</strong>（如果协议更新了但旧逻辑仍在运行，可能导致同步失败）</li>
</ul>
<hr>
<h2 id="2-热更新时的界面选择"><a href="#2-热更新时的界面选择" class="headerlink" title="2. 热更新时的界面选择"></a><strong>2. 热更新时的界面选择</strong></h2><p>📌 <strong>推荐使用“过渡界面”或“更新提示界面”</strong></p>
<table>
<thead>
<tr>
<th><strong>界面类型</strong></th>
<th><strong>是否推荐</strong></th>
<th><strong>理由</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>独立更新界面</strong>（如“正在更新”）</td>
<td>✅ <strong>推荐</strong></td>
<td>提示用户更新进度，防止误操作</td>
</tr>
<tr>
<td><strong>游戏启动界面</strong>（Logo、Loading）</td>
<td>✅ <strong>推荐</strong></td>
<td>最安全，不影响正常游戏流程</td>
</tr>
<tr>
<td><strong>游戏大厅（非交互状态）</strong></td>
<td>✅ <strong>推荐</strong></td>
<td>适用于“在线更新”</td>
</tr>
<tr>
<td><strong>游戏进行中（战斗、副本）</strong></td>
<td>❌ <strong>不推荐</strong></td>
<td>影响玩家体验，容易崩溃</td>
</tr>
<tr>
<td><strong>UI弹窗提醒更新</strong></td>
<td>⚠ <strong>谨慎</strong></td>
<td>适用于小补丁，不适用于大版本更新</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-具体热更新流程"><a href="#3-具体热更新流程" class="headerlink" title="3. 具体热更新流程"></a><strong>3. 具体热更新流程</strong></h2><p>📌 <strong>示例：在“游戏大厅”进行更新</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">CheckForUpdates</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 显示更新界面</span></span><br><span class="line">    UIManager.Instance.ShowUpdatePanel(<span class="string">&quot;正在检查更新...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 下载最新的版本信息</span></span><br><span class="line">    <span class="built_in">string</span> versionUrl = <span class="string">&quot;https://server.com/version.json&quot;</span>;</span><br><span class="line">    UnityWebRequest request = UnityWebRequest.Get(versionUrl);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> request.SendWebRequest();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.result == UnityWebRequest.Result.Success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> versionData = request.downloadHandler.text;</span><br><span class="line">        VersionInfo newVersion = JsonUtility.FromJson&lt;VersionInfo&gt;(versionData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 比对当前版本</span></span><br><span class="line">        <span class="keyword">if</span> (newVersion.version != currentVersion)</span><br><span class="line">        &#123;</span><br><span class="line">            UIManager.Instance.ShowUpdatePanel(<span class="string">&quot;发现新版本，开始更新...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 下载新 DLL 和 AB 包</span></span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">DownloadAndReplace</span>(<span class="params">newVersion</span>)</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5. 更新完成后提示玩家重启</span></span><br><span class="line">            UIManager.Instance.ShowUpdatePanel(<span class="string">&quot;更新完成，请重启游戏！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-避免问题的关键"><a href="#4-避免问题的关键" class="headerlink" title="4. 避免问题的关键"></a><strong>4. 避免问题的关键</strong></h2><h3 id="✅-关键点-1：更新时切断交互"><a href="#✅-关键点-1：更新时切断交互" class="headerlink" title="✅ 关键点 1：更新时切断交互"></a><strong>✅ 关键点 1：更新时切断交互</strong></h3><ul>
<li><strong>更新期间</strong>禁用按钮、滑动等操作，防止玩家误触</li>
<li><strong>建议锁定 UI 操作</strong>，直到更新完成</li>
</ul>
<h3 id="✅-关键点-2：分批更新"><a href="#✅-关键点-2：分批更新" class="headerlink" title="✅ 关键点 2：分批更新"></a><strong>✅ 关键点 2：分批更新</strong></h3><ul>
<li>如果 <strong>游戏大厅 + 多个小游戏</strong>：<ul>
<li><strong>主程序 DLL</strong> 在启动时更新</li>
<li><strong>小游戏 DLL &amp; 资源</strong> 在游戏选择时更新</li>
</ul>
</li>
</ul>
<h3 id="✅-关键点-3：更新后强制重启"><a href="#✅-关键点-3：更新后强制重启" class="headerlink" title="✅ 关键点 3：更新后强制重启"></a><strong>✅ 关键点 3：更新后强制重启</strong></h3><ul>
<li>HybridCLR <strong>不能直接替换运行中的 DLL</strong></li>
<li>更新完成后，需要 <strong>重新启动游戏</strong>，加载新 DLL<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RestartGame</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 退出游戏并重新启动</span></span><br><span class="line">    Application.Quit();</span><br><span class="line">    System.Diagnostics.Process.Start(Application.dataPath.Replace(<span class="string">&quot;_Data&quot;</span>, <span class="string">&quot;.exe&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a><strong>5. 结论</strong></h2><table>
<thead>
<tr>
<th><strong>问题</strong></th>
<th><strong>解决方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>什么时候更新？</strong></td>
<td><strong>游戏启动 &#x2F; 进入大厅 &#x2F; 切换大场景</strong></td>
</tr>
<tr>
<td><strong>在哪里更新？</strong></td>
<td><strong>加载界面 &#x2F; 独立更新界面 &#x2F; 游戏大厅</strong></td>
</tr>
<tr>
<td><strong>如何避免错误？</strong></td>
<td><strong>禁用交互、分批更新、更新后强制重启</strong></td>
</tr>
</tbody></table>
<p>这样可以 <strong>最大化避免游戏崩溃</strong>，让玩家平稳地进行热更新。🚀</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mr-liu-cheng.github.io">LiuCheng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mr-liu-cheng.github.io/2025/01/13/HybridCLR-%E7%AC%94%E8%AE%B0/">https://mr-liu-cheng.github.io/2025/01/13/HybridCLR-%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mr-liu-cheng.github.io" target="_blank">LiuCheng's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/favicon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wxpay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wxpay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/01/13/Unity-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E9%80%89%E6%8B%A9/" title="Unity 渲染管线选择"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Unity 渲染管线选择</div></div><div class="info-2"><div class="info-item-1">选择渲染模式的建议 内置渲染管线 (Built-In Render Pipeline)    优点：稳定、易用，适合新手和简单项目。   缺点：缺乏现代渲染特性，性能调优复杂。   适用场景：小型项目、快速原型开发或简单的 2D&#x2F;3D 游戏。   通用渲染管线 (URP)    优点：支持跨平台优化，性能优良，现代化工具支持（如 Shader Graph）。   缺点：功能不如 HDRP 完善，可能需要手动迁移内置资源。   适用场景：中小型 2D&#x2F;3D 游戏或移动平台开发。   高清渲染管线 (HDRP)    优点：画质卓越，支持高级渲染效果（如实时光线追踪）。   缺点：硬件需求高，不适合低端设备。   适用场景：高质量 3D 游戏、电影制作或建筑可视化等。    根据项目的规模、目标平台和渲染需求选择合适的模板，有助于优化开发体验和性能。 </div></div></div></a><a class="pagination-related" href="/2025/01/14/Unity%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/" title="Unity 环境安装"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Unity 环境安装</div></div><div class="info-2"><div class="info-item-1">unity 模块添加官方解释 这段官方解释详细说明了为什么 “Add Modules” 按钮可能缺失以及如何通过手动方式修复。以下是总结和关键要点：  问题原因 Unity Hub 使用 modules.json 文件来记录某个 Unity 编辑器版本的模块安装状态。 如果该文件缺失或未正确生成，Unity Hub 就无法知道有哪些模块已安装，也无法显示 “Add Modules” 按钮。 如果编辑器是通过非 Unity Hub 安装的（例如手动下载解压安装），默认没有 modules.json 文件，Unity Hub 将无法管理该版本的模块。所以我们安装unity时hub上可能没有列出我们需要的版本，但是我们可以去官网找到对应的版本链接至UnityHub 这样就相当于使用UnityHub下载，支持模块管理。   解决方案如果你的 Unity 安装缺失 “Add Modules” 按钮，可以尝试以下步骤修复： 方法一：手动下载模块 选版本 archive releases，找到组件对应组件模块，如下：     Component installers -&gt;   ...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">LiuCheng</div><div class="author-info-description">不积跬步无以至千里</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Mr-liu-cheng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://mr-liu-cheng.github.io/img/weixin.jpg" target="_blank" title="WeChat"><i class="fa-brands fa-weixin" style="color: #00ff00;"></i></a><a class="social-icon" href="mailto:liuchengyg@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://mr-liu-cheng.github.io/img/qq.jpg" target="_blank" title="QQ"><i class="fa-brands fa-qq" style="color: #ffffff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Stay hungry, stay foolish.</div></div><div class="card-widget study-widget" id="study-list"><div class="item-headline"><i class="fas fa-tasks"></i><span>学习目标</span></div><div class="item-content"><div>
  <ul>
    <li>Shader</li>
    <li>华佗热更新</li>
    <li>微信游戏发布</li>
    <li>Steam游戏发布</li>
    <li>广告SDK接入</li>
  </ul>
</div>
</div></div><div class="card-widget calendar-widget" id="calendar-list"><div class="item-headline"><i class="fas fa-tasks"></i><span>今日事今日毕</span></div><div class="item-content"><head>
    <meta charset="UTF-8">
    <title>FullCalendar 农历和调休示例</title>
    <script src='https://cdn.jsdelivr.net/npm/rrule@2.6.4/dist/es5/rrule.min.js'></script>
    <link href="https://cdn.jsdelivr.net/npm/fullcalendar@latest/main.min.css" rel="stylesheet" />
</head>

<body>
    <a href="/Calendar/">
        <!-- 日历容器 -->
        <div id="calendar_aside"></div>
        <!-- FullCalendar JavaScript -->
        <script src="https://cdn.jsdelivr.net/npm/fullcalendar@latest/main.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.11.6/umd/popper.min.js"></script>
        <!-- 引入农历库 -->
        <script src="https://cdn.jsdelivr.net/npm/lunar-javascript@latest/lunar.min.js"></script>
        <!-- 本地脚本加载路径需要添加根目录节点-->
        <script src="/js/myCalendar.js"></script>
        <script>
            Show("calendar_aside");
        </script>
    </a>
</body>
</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#hybridclr-Package%E6%89%8B%E5%86%8C"><span class="toc-number">1.</span> <span class="toc-text">hybridclr Package手册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.</span> <span class="toc-text">最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E6%94%AF%E6%8C%81%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">不支持特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOT%E6%B3%9B%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">AOT泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E6%9B%B4%E6%96%B0%E7%A8%8B%E5%BA%8F%E9%9B%86%E7%9A%84-auto-reference"><span class="toc-number">5.</span> <span class="toc-text">热更新程序集的 auto reference</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-auto-reference-%E9%80%89%E9%A1%B9%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">1. 什么是 auto reference 选项？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Assembly-CSharp-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">2. Assembly-CSharp 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%83%AD%E6%9B%B4%E6%96%B0%E7%A8%8B%E5%BA%8F%E9%9B%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">3. 热更新程序集是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">5.4.</span> <span class="toc-text">4. 问题的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E5%85%B3%E9%97%AD%E7%83%AD%E6%9B%B4%E6%96%B0%E7%A8%8B%E5%BA%8F%E9%9B%86%E7%9A%84-auto-reference%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">5. 为什么建议关闭热更新程序集的 auto reference？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD-auto-reference%EF%BC%9F"><span class="toc-number">5.6.</span> <span class="toc-text">6. 如何关闭 auto reference？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.7.</span> <span class="toc-text">7. 注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Assembly-CSharp-%E7%A8%8B%E5%BA%8F%E9%9B%86"><span class="toc-number">6.</span> <span class="toc-text">Assembly-CSharp 程序集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Assembly-CSharp-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text">1. Assembly-CSharp 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E5%88%A0%E9%99%A4-Assembly-CSharp%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">2. 什么时候可以删除 Assembly-CSharp？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%9A%E5%B8%B8%E4%B8%8D%E5%BB%BA%E8%AE%AE%E5%88%A0%E9%99%A4%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">3. 为什么通常不建议删除？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8E%A8%E8%8D%90%E7%9A%84%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.4.</span> <span class="toc-text">4. 推荐的实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-number">6.5.</span> <span class="toc-text">5. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scripting-Backend-IL2CPP"><span class="toc-number">7.</span> <span class="toc-text">Scripting Backend -&gt; IL2CPP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-IL2CPP-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">7.1.</span> <span class="toc-text">1. IL2CPP 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-IL2CPP"><span class="toc-number">7.2.</span> <span class="toc-text">2. 为什么要使用 IL2CPP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-IL2CPP-%E4%B8%8E-HybridCLR-%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="toc-number">7.3.</span> <span class="toc-text">3. IL2CPP 与 HybridCLR 的协作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">7.4.</span> <span class="toc-text">4. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Api-Compatibility-Level-NET-Framework"><span class="toc-number">8.</span> <span class="toc-text">Api Compatibility Level -&gt; .NET Framework</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-API-Compatibility-Level-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.1.</span> <span class="toc-text">1. API Compatibility Level 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%80%89%E6%8B%A9-NET-4-x-%E6%88%96-NET-Framework"><span class="toc-number">8.2.</span> <span class="toc-text">2. 为什么要选择 .NET 4.x 或 .NET Framework</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Unity-%E7%89%88%E6%9C%AC%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">8.3.</span> <span class="toc-text">3. Unity 版本的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%80%89%E6%8B%A9-NET-Standard-2-0%EF%BC%9F"><span class="toc-number">8.4.</span> <span class="toc-text">4. 为什么不选择 .NET Standard 2.0？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2-API-Compatibility-Level"><span class="toc-number">8.5.</span> <span class="toc-text">5. 如何切换 API Compatibility Level</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93"><span class="toc-number">8.6.</span> <span class="toc-text">6. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-Compiler-Configuration-Debug"><span class="toc-number">9.</span> <span class="toc-text">C++ Compiler Configuration: Debug</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Debug-%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%BB%E8%A6%81%E7%94%A8%E9%80%94"><span class="toc-number">9.1.</span> <span class="toc-text">1. Debug 配置的主要用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Debug-%E4%B8%8E-Release-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.2.</span> <span class="toc-text">2. Debug 与 Release 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9C%A8-Unity-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">9.3.</span> <span class="toc-text">3. 在 Unity 中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%85%8D%E7%BD%AE-Debug-%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">9.4.</span> <span class="toc-text">4. 配置 Debug 的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%85%8D%E7%BD%AE-Debug-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">9.5.</span> <span class="toc-text">5. 配置 Debug 的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E5%88%B0-Debug-%E9%85%8D%E7%BD%AE"><span class="toc-number">9.6.</span> <span class="toc-text">6. 如何切换到 Debug 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.7.</span> <span class="toc-text">7. 适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%80%BB%E7%BB%93"><span class="toc-number">9.8.</span> <span class="toc-text">8. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Use-Incremental-GC-true"><span class="toc-number">10.</span> <span class="toc-text">Use Incremental GC: true</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88Garbage-Collection-GC%EF%BC%89%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">1. 什么是垃圾回收（Garbage Collection, GC）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88Incremental-GC%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">2. 增量垃圾回收（Incremental GC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%90%AF%E7%94%A8-Use-Incremental-GC-%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">10.3.</span> <span class="toc-text">3. 启用 Use Incremental GC 的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">10.4.</span> <span class="toc-text">4. 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">10.5.</span> <span class="toc-text">5. 注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E5%90%AF%E7%94%A8-Incremental-GC"><span class="toc-number">10.6.</span> <span class="toc-text">6. 如何启用 Incremental GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-number">10.7.</span> <span class="toc-text">7. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E6%94%AF%E6%8C%81%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">11.</span> <span class="toc-text">不支持的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A3%81%E5%89%AA"><span class="toc-number">12.</span> <span class="toc-text">代码裁剪</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF"><span class="toc-number">12.1.</span> <span class="toc-text">问题背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-HybridCLR-Generate-All-%E5%91%BD%E4%BB%A4"><span class="toc-number">12.2.1.</span> <span class="toc-text">1. HybridCLR&#x2F;Generate&#x2F;All 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%8D%E6%96%B0%E6%9E%84%E5%BB%BA%E5%8C%85"><span class="toc-number">12.2.2.</span> <span class="toc-text">2. 重新构建包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-number">12.2.3.</span> <span class="toc-text">3. 动态调用的类型声明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%AD%A5%E9%AA%A4"><span class="toc-number">12.3.</span> <span class="toc-text">运行步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">12.4.</span> <span class="toc-text">其他注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A3%81%E5%89%AA%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">12.5.</span> <span class="toc-text">代码裁剪相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AOT%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%87%BD%E6%95%B0%E9%A2%84%E7%95%99"><span class="toc-number">12.5.1.</span> <span class="toc-text">AOT类型及函数预留</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%9E%84%E5%BB%BA"><span class="toc-number">13.</span> <span class="toc-text">增量构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E8%84%9A%E6%9C%AC%E6%8C%82%E8%BD%BD%E5%88%B0%E7%83%AD%E6%9B%B4%E6%96%B0%E8%B5%84%E6%BA%90"><span class="toc-number">14.</span> <span class="toc-text">将脚本挂载到热更新资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E6%9B%B4%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8AOT%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB%E6%88%96%E5%87%BD%E6%95%B0%E3%80%90%E6%96%B9%E6%A1%88%E3%80%91%EF%BC%88%E8%A1%A5%E5%85%85%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">热更代码中使用AOT中定义的泛型类或函数【方案】（补充元数据）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%A4%8D%E7%8E%B0"><span class="toc-number">15.1.</span> <span class="toc-text">问题复现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">15.2.</span> <span class="toc-text">示例问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOT-%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%88%E4%B8%BB%E5%B7%A5%E7%A8%8B%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="toc-number">15.3.</span> <span class="toc-text">AOT 项目代码（主工程代码）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81%EF%BC%88%E9%9C%80%E8%A6%81-HybridCLR-%E6%94%AF%E6%8C%81%EF%BC%89"><span class="toc-number">15.4.</span> <span class="toc-text">热更新代码（需要 HybridCLR 支持）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%83%AD%E6%9B%B4%E6%96%B0%E7%A8%8B%E5%BA%8F%E9%9B%86"><span class="toc-number">16.</span> <span class="toc-text">配置热更新程序集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HybridCLR-%E4%B8%AD%E7%9A%84%E8%BF%99%E4%B8%89%E4%B8%AA%E7%A8%8B%E5%BA%8F%E9%9B%86%E5%88%97%E8%A1%A8"><span class="toc-number">16.1.</span> <span class="toc-text">HybridCLR 中的这三个程序集列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%A8%8B%E5%BA%8F%E9%9B%86"><span class="toc-number">16.2.</span> <span class="toc-text">配置程序集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%9B%86%E5%88%86%E7%B1%BB"><span class="toc-number">16.2.1.</span> <span class="toc-text">程序集分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%92%E5%88%86%E7%A8%8B%E5%BA%8F%E9%9B%86"><span class="toc-number">16.2.2.</span> <span class="toc-text">划分程序集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">16.3.</span> <span class="toc-text">配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%97%AD-Automatic-References-%E5%B1%9E%E6%80%A7"><span class="toc-number">17.</span> <span class="toc-text">关闭 Automatic References 属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%9B%86%E5%BC%95%E7%94%A8"><span class="toc-number">17.1.</span> <span class="toc-text">1. 避免不必要的程序集引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%B2%E6%AD%A2%E4%B8%8EAOT%E4%BB%A3%E7%A0%81%E7%9A%84%E5%86%B2%E7%AA%81"><span class="toc-number">17.2.</span> <span class="toc-text">2. 防止与AOT代码的冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8E%A7%E5%88%B6%E7%83%AD%E6%9B%B4%E6%96%B0%E7%A8%8B%E5%BA%8F%E9%9B%86%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">17.3.</span> <span class="toc-text">3. 控制热更新程序集的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A7%A3%E5%86%B3%E7%A8%8B%E5%BA%8F%E9%9B%86%E5%A4%A7%E5%B0%8F%E4%B8%8E%E7%83%AD%E6%9B%B4%E6%96%B0%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">17.4.</span> <span class="toc-text">4. 解决程序集大小与热更新性能问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%81%BF%E5%85%8D%E7%83%AD%E6%9B%B4%E6%96%B0%E4%B8%8E%E7%BC%96%E8%BE%91%E6%97%B6%E7%8E%AF%E5%A2%83%E7%9A%84%E8%80%A6%E5%90%88"><span class="toc-number">17.5.</span> <span class="toc-text">5. 避免热更新与编辑时环境的耦合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%81%BF%E5%85%8D%E6%BD%9C%E5%9C%A8%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E7%B1%BB%E5%9E%8B%E4%B8%8E-AOT-%E7%B1%BB%E5%9E%8B%E5%86%B2%E7%AA%81"><span class="toc-number">17.6.</span> <span class="toc-text">6. 避免潜在的热更新类型与 AOT 类型冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">17.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%9B%B4%E6%96%B0assembly"><span class="toc-number">18.</span> <span class="toc-text">加载更新assembly</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">19.</span> <span class="toc-text">打包工作流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B"><span class="toc-number">19.1.</span> <span class="toc-text">打包流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%8D%93%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%E4%BC%98%E5%8C%96%EF%BC%88%E8%80%97%E6%97%B6%EF%BC%89"><span class="toc-number">20.</span> <span class="toc-text">安卓打包流程优化（耗时）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E5%90%8E%E7%AB%AF"><span class="toc-number">20.1.</span> <span class="toc-text">脚本后端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%AF%BC%E5%87%BA%E5%B7%A5%E7%A8%8B%E2%80%9D%EF%BC%9F"><span class="toc-number">20.2.</span> <span class="toc-text">1. 什么是“导出工程”？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%E8%A7%A3%E9%87%8A"><span class="toc-number">20.3.</span> <span class="toc-text">2. 具体流程解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E8%BF%90%E8%A1%8C-HybridCLR-Generate-LinkXml"><span class="toc-number">20.3.1.</span> <span class="toc-text">2.1 运行 HybridCLR&#x2F;Generate&#x2F;LinkXml</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%AF%BC%E5%87%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">20.3.2.</span> <span class="toc-text">2.2 导出工程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E8%BF%90%E8%A1%8C-HybridCLR-Generate-Il2cppDef"><span class="toc-number">20.3.3.</span> <span class="toc-text">2.3 运行 HybridCLR&#x2F;Generate&#x2F;Il2cppDef</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E8%BF%90%E8%A1%8C-HybridCLR-Generate-MethodBridge"><span class="toc-number">20.3.4.</span> <span class="toc-text">2.4 运行 HybridCLR&#x2F;Generate&#x2F;MethodBridge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E8%BF%90%E8%A1%8C-HybridCLR-Generate-PReverseInvokeWrapper%EF%BC%88%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%EF%BC%89"><span class="toc-number">20.3.5.</span> <span class="toc-text">2.5 运行 HybridCLR&#x2F;Generate&#x2F;PReverseInvokeWrapper（如果需要）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E6%9B%BF%E6%8D%A2%E7%94%9F%E6%88%90%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-number">20.3.6.</span> <span class="toc-text">2.6 替换生成的目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E5%9C%A8%E5%AF%BC%E5%87%BA%E5%B7%A5%E7%A8%8B%E4%B8%8A%E6%89%A7%E8%A1%8C-build"><span class="toc-number">20.3.7.</span> <span class="toc-text">2.7 在导出工程上执行 build</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%BB%E7%BB%93"><span class="toc-number">20.4.</span> <span class="toc-text">3. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="toc-number">21.</span> <span class="toc-text">常见错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8GameObject%E4%B8%8AAdd%E7%83%AD%E6%9B%B4%E6%96%B0%E8%84%9A%E6%9C%AC%E6%88%96%E8%80%85%E5%9C%A8%E8%B5%84%E6%BA%90%E4%B8%8A%E7%9B%B4%E6%8E%A5%E6%8C%82%E8%BD%BD-%E7%83%AD%E6%9B%B4%E6%96%B0%E8%84%9A%E6%9C%AC"><span class="toc-number">22.</span> <span class="toc-text">在GameObject上Add热更新脚本或者在资源上直接挂载 热更新脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Add"><span class="toc-number">22.1.</span> <span class="toc-text">Add</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%B5%84%E6%BA%90%E4%B8%8A%E6%8C%82%E8%BD%BD%E7%83%AD%E6%9B%B4%E6%96%B0%E8%84%9A%E6%9C%AC"><span class="toc-number">22.2.</span> <span class="toc-text">在资源上挂载热更新脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E9%97%AE%E9%A2%98"><span class="toc-number">22.3.</span> <span class="toc-text">已知问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8BAddComponent%E5%8F%8A%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E7%BA%BF%E7%A8%8B%E5%8A%A0%E8%BD%BD%E5%8C%85%E5%90%AB%E7%83%AD%E6%9B%B4%E6%96%B0%E8%84%9A%E6%9C%AC%E7%9A%84%E8%B5%84%E6%BA%90%E5%90%8C%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%97%B6%E5%81%B6%E5%8F%91%E7%9A%84%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98"><span class="toc-number">22.3.1.</span> <span class="toc-text">主线程AddComponent及其他资源加载线程加载包含热更新脚本的资源同时进行时偶发的崩溃问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE%E6%89%93AB%E6%97%B6%E4%B8%8D%E8%A6%81%E7%A6%81%E7%94%A8TypeTree"><span class="toc-number">22.3.2.</span> <span class="toc-text">建议打AB时不要禁用TypeTree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8-TypeTree"><span class="toc-number">22.4.</span> <span class="toc-text">如何禁用 TypeTree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E7%A6%81%E7%94%A8-TypeTree-%E6%A0%A1%E9%AA%8C"><span class="toc-number">22.4.1.</span> <span class="toc-text">示例代码：通过反射禁用 TypeTree 校验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">22.5.</span> <span class="toc-text">需要注意的地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B-TypeTree-%E6%98%AF%E5%90%A6%E8%A2%AB%E7%A6%81%E7%94%A8"><span class="toc-number">22.6.</span> <span class="toc-text">如何查看 TypeTree 是否被禁用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">22.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity%E6%89%93%E5%8C%85AB%E6%97%B6%E7%A6%81%E7%94%A8TypeTree%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">23.</span> <span class="toc-text">Unity打包AB时禁用TypeTree的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">23.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">23.2.</span> <span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">23.3.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">23.4.</span> <span class="toc-text">不适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">23.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E5%87%BD%E6%95%B0"><span class="toc-number">24.</span> <span class="toc-text">桥接函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">24.1.</span> <span class="toc-text">桥接函数的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">24.2.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">24.3.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">24.4.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">24.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%9B%B4%E6%96%B0%E5%88%A4%E6%96%AD"><span class="toc-number">25.</span> <span class="toc-text">资源更新判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E7%89%88%E6%9C%AC%E5%8F%B7%E6%88%96%E7%89%88%E6%9C%AC%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83"><span class="toc-number">25.1.</span> <span class="toc-text">1. 使用版本号或版本文件进行比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86"><span class="toc-number">25.1.1.</span> <span class="toc-text">资源版本管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E6%A0%A1%E9%AA%8C%EF%BC%88%E5%93%88%E5%B8%8C%E5%80%BC%E6%A0%A1%E9%AA%8C%EF%BC%89"><span class="toc-number">25.2.</span> <span class="toc-text">2. 文件校验（哈希值校验）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-number">25.2.1.</span> <span class="toc-text">服务器端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">25.2.2.</span> <span class="toc-text">客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%83%AD%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">25.3.</span> <span class="toc-text">3. 热更新流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A3%80%E6%9F%A5%E7%89%88%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">25.3.1.</span> <span class="toc-text">1. 检查版本文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">25.3.2.</span> <span class="toc-text">2. 比较版本号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A0%A1%E9%AA%8C%E8%B5%84%E6%BA%90"><span class="toc-number">25.3.3.</span> <span class="toc-text">3. 校验资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90"><span class="toc-number">25.3.4.</span> <span class="toc-text">4. 下载资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9B%BF%E6%8D%A2%E8%B5%84%E6%BA%90"><span class="toc-number">25.3.5.</span> <span class="toc-text">5. 替换资源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">25.4.</span> <span class="toc-text">4. 示例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">25.5.</span> <span class="toc-text">5. 注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HybridCLR-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E5%BC%83%E7%94%A8%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91"><span class="toc-number"></span> <span class="toc-text">HybridCLR 是如何删除弃用的业务逻辑</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E9%80%BB%E8%BE%91%E5%B1%82%E9%9D%A2%EF%BC%9A%E5%8D%B8%E8%BD%BD%E5%BA%9F%E5%BC%83%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number"></span> <span class="toc-text">1. 逻辑层面：卸载废弃的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%A7%BB%E9%99%A4%E5%B7%B2%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%BA%9F%E5%BC%83%E7%B1%BB"><span class="toc-number">0.1.</span> <span class="toc-text">（1）移除已加载的废弃类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%B8%85%E7%90%86%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-number">0.2.</span> <span class="toc-text">（2）清理静态变量 &amp; 事件监听</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%87%8A%E6%94%BE%E6%97%A7-DLL"><span class="toc-number">0.3.</span> <span class="toc-text">（3）释放旧 DLL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E5%B1%82%E9%9D%A2%EF%BC%9A%E5%88%A0%E9%99%A4%E5%BA%9F%E5%BC%83%E7%9A%84-DLL"><span class="toc-number"></span> <span class="toc-text">2. 文件层面：删除废弃的 DLL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BD%E6%97%A7%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91"><span class="toc-number"></span> <span class="toc-text">3. 如何彻底卸载旧业务逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88-1%EF%BC%9A%E9%87%8D%E5%90%AF%E8%BF%9B%E7%A8%8B"><span class="toc-number">0.1.</span> <span class="toc-text">方案 1：重启进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88-2%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C-Assembly-%E5%8A%A0%E8%BD%BD-DLL"><span class="toc-number">0.2.</span> <span class="toc-text">方案 2：使用不同 Assembly 加载 DLL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number"></span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%92%E5%88%86%E7%A8%8B%E5%BA%8F%E9%9B%86-1"><span class="toc-number"></span> <span class="toc-text">划分程序集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Assembly-%E5%88%92%E5%88%86%E6%96%B9%E6%A1%88"><span class="toc-number"></span> <span class="toc-text">1. Assembly 划分方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%B8%BB%E7%A8%8B%E5%BA%8F-Assembly%EF%BC%88GameHub-dll%EF%BC%89"><span class="toc-number">0.1.</span> <span class="toc-text">（1）主程序 Assembly（GameHub.dll）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%B0%8F%E6%B8%B8%E6%88%8F-Assembly%EF%BC%88GameA-dll%E3%80%81GameB-dll%E2%80%A6%EF%BC%89"><span class="toc-number">0.2.</span> <span class="toc-text">（2）小游戏 Assembly（GameA.dll、GameB.dll…）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%85%AC%E5%85%B1-Assembly%EF%BC%88Common-dll%EF%BC%89"><span class="toc-number">0.3.</span> <span class="toc-text">（3）公共 Assembly（Common.dll）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number"></span> <span class="toc-text">2. 具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%B0%8F%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84"><span class="toc-number">0.1.</span> <span class="toc-text">（1）小游戏代码结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%AE%9A%E4%B9%89%E9%80%9A%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%88GameHub-%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%EF%BC%89"><span class="toc-number">0.2.</span> <span class="toc-text">（2）定义通用接口（GameHub 统一管理）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F-GameHub-dll-%E5%8F%AA%E8%AE%A4%E8%AF%86-%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%B8%8D%E4%BE%9D%E8%B5%96%E5%85%B7%E4%BD%93%E6%B8%B8%E6%88%8F%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">主程序 GameHub.dll 只认识 接口，不依赖具体游戏：12345public interface IGameModule{    void StartGame();    void StopGame();}</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%EF%BC%88%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD-DLL%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">（3）动态加载游戏（按需加载 DLL）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">✅ 加载游戏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E8%BF%90%E8%A1%8C%E6%B8%B8%E6%88%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">✅ 运行游戏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%88%A0%E9%99%A4-%E4%B8%8B%E6%9E%B6%E6%B8%B8%E6%88%8F"><span class="toc-number">1.2.</span> <span class="toc-text">（4）删除&#x2F;下架游戏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E6%B3%A8%E6%84%8F-%E7%94%B1%E4%BA%8E-C-%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8D%B8%E8%BD%BD%E5%8D%95%E4%B8%AA-DLL%EF%BC%8C%E5%BB%BA%E8%AE%AE%EF%BC%9A-%E5%8A%A0%E8%BD%BD%E6%97%B6%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C-Assembly%EF%BC%8C%E9%81%BF%E5%85%8D%E5%8D%A0%E7%94%A8-%E5%88%A0%E9%99%A4%E5%90%8E%EF%BC%8C%E5%BB%BA%E8%AE%AE%E9%87%8D%E5%90%AF%E6%B8%B8%E6%88%8F%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">⚠️ 注意- 由于 C# 不支持卸载单个 DLL，建议：  - 加载时使用不同 Assembly，避免占用  - 删除后，建议重启游戏进程
  </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%B8%B8%E6%88%8F%E6%9B%B4%E6%96%B0"><span class="toc-number">2.1.</span> <span class="toc-text">（5）游戏更新</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-HybridCLR-%E6%94%AF%E6%8C%81%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">3. HybridCLR 支持点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93-1"><span class="toc-number"></span> <span class="toc-text">4. 总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BD%A0%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">5. 你接下来的问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E7%A8%8B%E5%BA%8F%E9%9B%86%E4%B8%BA%E5%95%A5%E4%B8%8D%E8%83%BD%E4%B8%8E%E4%B8%BB%E7%A8%8B%E5%BA%8F%E9%9B%86%E5%90%88%E5%B9%B6"><span class="toc-number"></span> <span class="toc-text">公共程序集为啥不能与主程序集合并</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%AC%E5%85%B1-Assembly-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%90%88%E5%B9%B6%E5%88%B0%E4%B8%BB%E7%A8%8B%E5%BA%8F-Assembly%EF%BC%9F"><span class="toc-number">0.1.</span> <span class="toc-text">1. 公共 Assembly 是否可以合并到主程序 Assembly？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Assembly-%E4%B8%8E-AssetBundle%EF%BC%88AB-%E5%8C%85%EF%BC%89%E5%A6%82%E4%BD%95%E5%85%B3%E8%81%94%EF%BC%9F"><span class="toc-number">0.2.</span> <span class="toc-text">2. Assembly 与 AssetBundle（AB 包）如何关联？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%A6%82%E4%BD%95%E5%85%B3%E8%81%94%EF%BC%9F"><span class="toc-number">0.2.1.</span> <span class="toc-text">（1）如何关联？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%B8%B8%E6%88%8F-GameA-%E7%BB%93%E6%9E%84"><span class="toc-number">0.2.2.</span> <span class="toc-text">（2）示例：游戏 GameA 结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B7%E4%BD%93%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86-DLL-%E5%92%8C-AB-%E5%8C%85%EF%BC%9F"><span class="toc-number">0.3.</span> <span class="toc-text">3. 具体如何管理 DLL 和 AB 包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-AB-%E5%8C%85%E4%B8%8E-DLL-%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%BB%A3%E7%A0%81"><span class="toc-number">0.4.</span> <span class="toc-text">4. AB 包与 DLL 的加载代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%83%AD%E6%9B%B4%E6%96%B0%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E5%BA%9F%E5%BC%83%E7%9A%84-DLL-%E5%92%8C-AB%EF%BC%9F"><span class="toc-number">0.5.</span> <span class="toc-text">5. 热更新时，如何删除废弃的 DLL 和 AB？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93-1"><span class="toc-number">0.6.</span> <span class="toc-text">6. 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%92%8C%E7%95%8C%E9%9D%A2%E9%80%89%E6%8B%A9"><span class="toc-number"></span> <span class="toc-text">热更新的最佳时机和界面选择</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">1.</span> <span class="toc-text">1. 热更新的最佳时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%83%AD%E6%9B%B4%E6%96%B0%E6%97%B6%E7%9A%84%E7%95%8C%E9%9D%A2%E9%80%89%E6%8B%A9"><span class="toc-number">2.</span> <span class="toc-text">2. 热更新时的界面选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B7%E4%BD%93%E7%83%AD%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">3. 具体热更新流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%81%BF%E5%85%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%85%B3%E9%94%AE"><span class="toc-number">4.</span> <span class="toc-text">4. 避免问题的关键</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%85%B3%E9%94%AE%E7%82%B9-1%EF%BC%9A%E6%9B%B4%E6%96%B0%E6%97%B6%E5%88%87%E6%96%AD%E4%BA%A4%E4%BA%92"><span class="toc-number">4.1.</span> <span class="toc-text">✅ 关键点 1：更新时切断交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%85%B3%E9%94%AE%E7%82%B9-2%EF%BC%9A%E5%88%86%E6%89%B9%E6%9B%B4%E6%96%B0"><span class="toc-number">4.2.</span> <span class="toc-text">✅ 关键点 2：分批更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%85%B3%E9%94%AE%E7%82%B9-3%EF%BC%9A%E6%9B%B4%E6%96%B0%E5%90%8E%E5%BC%BA%E5%88%B6%E9%87%8D%E5%90%AF"><span class="toc-number">4.3.</span> <span class="toc-text">✅ 关键点 3：更新后强制重启</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BB%93%E8%AE%BA"><span class="toc-number">5.</span> <span class="toc-text">5. 结论</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/09/%E6%B8%B8%E6%88%8F%E7%A0%94%E5%8F%91%E9%83%A8%E9%97%A8%E5%8D%8F%E4%BD%9C/" title="部门">部门</a><time datetime="2025-06-09T11:20:13.000Z" title="发表于 2025-06-09 11:20:13">2025-06-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/03/%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/" title="登录流程">登录流程</a><time datetime="2025-06-03T11:20:13.000Z" title="发表于 2025-06-03 11:20:13">2025-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/21/%E6%8F%90%E5%8D%87/" title="提升">提升</a><time datetime="2025-05-21T11:20:13.000Z" title="发表于 2025-05-21 11:20:13">2025-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/17/%E7%A4%BE%E4%BF%9D%E5%92%8C%E5%85%AC%E7%A7%AF%E9%87%91%E7%9A%84%E8%A1%A5%E7%BC%B4%E9%97%AE%E9%A2%98/" title="社保和公积金的补缴问题">社保和公积金的补缴问题</a><time datetime="2025-05-17T20:16:02.000Z" title="发表于 2025-05-17 20:16:02">2025-05-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/12/GitHub%20action%20%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/" title="GitHub action 自动发布博客">GitHub action 自动发布博客</a><time datetime="2025-05-12T14:16:02.000Z" title="发表于 2025-05-12 14:16:02">2025-05-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By LiuCheng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="music-button" type="button" title="music"><i class="fas fa-music"> </i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = {"language":"zh-CN","distractionFreeMode":true}

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23lisuIzc4KST5xLzO',
      clientSecret: '55972644d3071dd4c51a2e71064e336d2f51aa66',
      repo: 'mr-liu-cheng.github.io',
      owner: 'Mr-liu-cheng',
      admin: ['Mr-liu-cheng'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'ca3ecc3fa120438d3d97d61c1d9c8770'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><div id="music-player" style="display: none;"></div><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script>  fetch("/music/playlist.json")    .then(response => response.json())    .then(data => {      const ap = new APlayer({        container: document.getElementById("music-player"),        fixed: true,        autoplay: false,        audio: data,        lrcType: 3      });    })    .catch(error => console.error("Error loading playlist:", error));</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>